/*! For license information please see webplayer.bundle.js.LICENSE.txt */
console.log("Webplayer v3.0.0 - 2023/07/10 (modded 2024/02/05 by petrichor to add debugger)")
/*PETRICHOR DEBUGGER MOD START*/
let petrichorIgnoreNextHitBreakpoint = false
const PetrichorPossibleFrameProgressStates = {
	preFrame: 0,
	stageProject: 1,
	stageScene: 2,
	stageRuleGroups: 3,
	inRuleGroup: 4,
	ruleInRuleGroup: 5,
	inRule: 6,
	inStageScript: 7,
	inExecutable: 8,
    inCustomRuleGroups: 9,
}
let petrichorBreakpoints = []
const petrichorDebuggerHandlers = {}
function petrichorBreakpointExistsAt(location) {
    if (!location)
        return false
    if (!location.source)
        return false
    return petrichorBreakpoints.some(e=>e.line==location.start.line && e.source == location.source)
}
const petrichorFrameStateStack = [{id: PetrichorPossibleFrameProgressStates.preFrame}];
function petrichorCurrentFrameState() {
	return petrichorFrameStateStack[petrichorFrameStateStack.length - 1]
}
function petrichorFrame() {
    let r
    for (;r=petrichorStep(),!["FRAMEEND","BREAKPOINT"].includes(r);){}
    return r
}
function petrichorStep() {
	// console.log(petrichorFrameStateStack)
	switch (petrichorCurrentFrameState().id) {
	case PetrichorPossibleFrameProgressStates.preFrame: {
        if (petrichorCurrentFrameState().hasFinished) {
            // this.renderer.render(this.stageProject.activeStageScene.container), this.renderFrameForBackgroundAndDrawing(), this.showPrompts(), this.requestNextFrame(), this.updateAndCleanKeyboardEvents()
            main.renderer.render(main.stageProject.activeStageScene.container)
            main.renderFrameForBackgroundAndDrawing()
            main.showPrompts()
            // Skip this.requestNextFrame()
            main.updateAndCleanKeyboardEvents()
            petrichorCurrentFrameState().hasFinished = false //resuse state for next frame
            return "FRAMEEND"
        }
		// this.stageProject.animationTick(this.visualContext.collisionContext, this.visualContext)
		const stageProject = main.stageProject
		const collisionContext = main.visualContext.collisionContext
		const visualContext = main.visualContext
		petrichorFrameStateStack.push({id: PetrichorPossibleFrameProgressStates.stageProject, stageProject, collisionContext, visualContext})
		break}
	case PetrichorPossibleFrameProgressStates.stageProject: {
        if (petrichorCurrentFrameState().hasFinished) {
            petrichorFrameStateStack.pop()
            petrichorCurrentFrameState().hasFinished = true
            break
        }
		const stageProject = petrichorCurrentFrameState().stageProject
		const collisionContext = petrichorCurrentFrameState().collisionContext
		// stageProject.activeStageScene.animationTick(collisionContext)
		petrichorFrameStateStack.push({id: PetrichorPossibleFrameProgressStates.stageScene, stageScene: stageProject.activeStageScene, collisionContext})
		break}
	case PetrichorPossibleFrameProgressStates.stageScene: {
		const stageScene = petrichorCurrentFrameState().stageScene
        if (petrichorCurrentFrameState().hasFinished) {
            // this.activator.cleanDestroyQueue(), this.swapEventMessageQueue(), this.tickCount++
            stageScene.activator.cleanDestroyQueue()
            stageScene.swapEventMessageQueue()
            stageScene.tickCount++
            petrichorFrameStateStack.pop()
            petrichorCurrentFrameState().hasFinished = true
            break
        }
		const collisionContext = petrichorCurrentFrameState().collisionContext
		// HSStageScene.dirtySort && (HSStageScene.dirtySort = !1, this.sortRenderList()), this.container.removeChildren(), this.renderList.forEach((function(e) {
		//     e.update(), e.view.sprite && stageScene.container.addChild(e.view.sprite)
		// })), this.collisionTest(collisionContext), this.activateRules()
		if (HSStageScene.dirtySort) {
			HSStageScene.dirtySort = false
			stageScene.sortRenderList()
		}
		stageScene.renderList.forEach(e => {
			e.update()
			if (e.view.sprite)
				stageScene.container.addChild(e.view.sprite)
		})
		stageScene.collisionTest(collisionContext)
		stageScene.activateRules()
		// for (var e = stageScene.activator.stageRuleGroups(), t = e.length, r = 0; r < t; ++r) {
		// 	if (void 0 !== e[r]) {
		// 		e[r].executeActiveRules()
		// 	}
		// }
		petrichorFrameStateStack.push({id: PetrichorPossibleFrameProgressStates.stageRuleGroups, groups: stageScene.activator.stageRuleGroups(), currentIndex: 0, })
		break}
	case PetrichorPossibleFrameProgressStates.stageRuleGroups: {
		if (petrichorCurrentFrameState().currentIndex >= petrichorCurrentFrameState().groups.length) {
            petrichorFrameStateStack.pop()
            petrichorCurrentFrameState().hasFinished = true
            break
        }
        const ruleGroup = petrichorCurrentFrameState().groups[petrichorCurrentFrameState().currentIndex]
        petrichorCurrentFrameState().currentIndex++
        // if (void 0 !== e[r]) {
        // 	e[r].executeActiveRules()
        // }
        if (void 0 !== ruleGroup)
            petrichorFrameStateStack.push({id: PetrichorPossibleFrameProgressStates.inRuleGroup, ruleGroup})
		break}
	case PetrichorPossibleFrameProgressStates.inRuleGroup: {
		const ruleGroup = petrichorCurrentFrameState().ruleGroup
		// for (var e = this.rules(), t = e.length, r = 0; r !== t; ++r) {
		petrichorFrameStateStack.push({id: PetrichorPossibleFrameProgressStates.ruleInRuleGroup, ruleGroup, currentIndex: 0})
		break}
	case PetrichorPossibleFrameProgressStates.ruleInRuleGroup: {
		const ruleGroup = petrichorCurrentFrameState().ruleGroup
        if (ruleGroup.rules().length <= petrichorCurrentFrameState().currentIndex) {
            // this.customRuleGroups().forEach((function(e) {
            // 	/*PETRICHOR DEBUGGER MOD START*/
            // 	// TODO: This
            // 	/*PETRICHOR DEBUGGER MOD END*/
            // 	return e.executeActiveRules()
            // }))
            petrichorFrameStateStack.pop()
            petrichorFrameStateStack.push({
                id: PetrichorPossibleFrameProgressStates.inCustomRuleGroups,
                customRuleGroups: ruleGroup.customRuleGroups(),
                currentIndex: 0
            })
            break
        }
		const rule = ruleGroup.rules()[petrichorCurrentFrameState().currentIndex]
		petrichorCurrentFrameState().currentIndex++
		//  e[r].conditionIsTrue(this) && (e[r].hasBlocksToExecute() || (e[r].isActive = !1), e[r].activate())
		if (rule.conditionIsTrue(ruleGroup)) {
            if (!rule.hasBlocksToExecute())
                rule.isActive = false
			rule.activate()
		}
		// 	e[r].execute(this);
		petrichorFrameStateStack.push({id: PetrichorPossibleFrameProgressStates.inRule, rule, ruleGroup})
		break}
    case PetrichorPossibleFrameProgressStates.inCustomRuleGroups: {
        const customRuleGroups = petrichorCurrentFrameState().customRuleGroups
        if (customRuleGroups.length <= petrichorCurrentFrameState().currentIndex) {
            petrichorFrameStateStack.pop()
            petrichorFrameStateStack.pop() // inRuleGroup
            // Goes to stageRuleGroups
            break
        }
        const ruleGroup = customRuleGroups[petrichorCurrentFrameState().currentIndex]
        petrichorCurrentFrameState().currentIndex++
        petrichorFrameStateStack.push({id: PetrichorPossibleFrameProgressStates.inRuleGroup, ruleGroup})
        break}
	case PetrichorPossibleFrameProgressStates.inRule: {
		const rule = petrichorCurrentFrameState().rule
		const ruleGroup = petrichorCurrentFrameState().ruleGroup
		// if (this.isExecutable()) {
		if (rule.isExecutable()) {
		// 	if (this.stageScript.isImmediate)
		// 		this.isActive = false
		if (rule.stageScript.isImmediate)
			rule.isActive = false
		// 	 this.stageScript.execute(ruleGroup)
			petrichorFrameStateStack.push({id: PetrichorPossibleFrameProgressStates.inStageScript, stageScript: rule.stageScript, ruleGroup})
		//  } else {
		} else {
		// 	 this.isActive = false
			rule.isActive = false
			// Return from rule moved here in this case
			petrichorFrameStateStack.pop()
		//  }
		}
		break}
	case PetrichorPossibleFrameProgressStates.inStageScript: {
		const stageScript = petrichorCurrentFrameState().stageScript
		const ruleGroup = petrichorCurrentFrameState().ruleGroup
        if (petrichorCurrentFrameState().hasFinished) {
            // this._blocks = executable.blocksToExecuteLater, this.isImmediate = this._blocks.every((function(e) {
            //     return e.isImmediate
            stageScript._blocks = petrichorCurrentFrameState().executable.blocksToExecuteLater
            stageScript.isImmediate = stageScript._blocks.every(e=>e.isImmediate)
            // })), executable.isImmediate && this.execute(stageRule)
            if (petrichorCurrentFrameState().executable.isImmediate) {
                petrichorCurrentFrameState().hasFinished = false
                petrichorCurrentFrameState().executable = null
                break
            }
            petrichorFrameStateStack.pop()
            petrichorFrameStateStack.pop() // inRule
            // Goes to ruleInRuleGroup
            break
        }
		// var executable = this.executableForStepSize(stageRuleGroup.maxStepSize(), stageRuleGroup);
		const executable = stageScript.executableForStepSize(ruleGroup.maxStepSize(), ruleGroup)
		// executable.execute(stageRuleGroup), 
		petrichorFrameStateStack.push({id: PetrichorPossibleFrameProgressStates.inExecutable, executable, ruleGroup, currentIndex: 0})
		break}
	case PetrichorPossibleFrameProgressStates.inExecutable: {
		const petrichori = petrichorCurrentFrameState().currentIndex
		const executable = petrichorCurrentFrameState().executable
		if (petrichori >= executable.blocksToExecuteNow.length) {
			petrichorFrameStateStack.pop() // inExecutable
            petrichorCurrentFrameState().hasFinished = true
            petrichorCurrentFrameState().executable = executable
			break
		}
		petrichorCurrentFrameState().currentIndex++
		const ruleGroup = petrichorCurrentFrameState().ruleGroup
		// 	const block = t.blocksToExecuteNow[petrichori]
		const block = executable.blocksToExecuteNow[petrichori]
        petrichorCurrentFrameState().petrichorLocation = block.PETRICHOR_BREAKPOINT_POSITION
        if (petrichorBreakpointExistsAt(block.PETRICHOR_BREAKPOINT_POSITION)) {
            if (petrichorIgnoreNextHitBreakpoint) {
                console.log("Ignoring what would normally be a breakpoint")
                petrichorIgnoreNextHitBreakpoint = false
            } else {
                petrichorCurrentFrameState().currentIndex--
                (petrichorDebuggerHandlers.breakpoint || ((location)=>{}))(block.PETRICHOR_BREAKPOINT_POSITION)
                return "BREAKPOINT"
            }
        }
		// 	t.executeBlock(block, e)
		executable.executeBlock(block, ruleGroup)
	break}
	default:
		throw "Unknown state!"
	}
}
function petrichorAnimationTick() {
    if (petrichorFrame() == "BREAKPOINT")
        return
    requestAnimationFrame(petrichorAnimationTick)
}
/*PETRICHOR DEBUGGER MOD END*/
(() => {
    var e = {
            9521: (e, t, r) => {
                "use strict";

                function i(e, t) {
                    (function(e) {
                        return "string" == typeof e && -1 !== e.indexOf(".") && 1 === parseFloat(e)
                    })(e) && (e = "100%");
                    var r = function(e) {
                        return "string" == typeof e && -1 !== e.indexOf("%")
                    }(e);
                    return e = 360 === t ? e : Math.min(t, Math.max(0, parseFloat(e))), r && (e = parseInt(String(e * t), 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : e = 360 === t ? (e < 0 ? e % t + t : e % t) / parseFloat(String(t)) : e % t / parseFloat(String(t))
                }

                function s(e) {
                    return Math.min(1, Math.max(0, e))
                }

                function n(e) {
                    return e = parseFloat(e), (isNaN(e) || e < 0 || e > 1) && (e = 1), e
                }

                function o(e) {
                    return e <= 1 ? "".concat(100 * Number(e), "%") : e
                }

                function a(e) {
                    return 1 === e.length ? "0" + e : String(e)
                }

                function h(e, t, r) {
                    return {
                        r: 255 * i(e, 255),
                        g: 255 * i(t, 255),
                        b: 255 * i(r, 255)
                    }
                }

                function l(e, t, r) {
                    e = i(e, 255), t = i(t, 255), r = i(r, 255);
                    var s = Math.max(e, t, r),
                        n = Math.min(e, t, r),
                        o = 0,
                        a = 0,
                        h = (s + n) / 2;
                    if (s === n) a = 0, o = 0;
                    else {
                        var l = s - n;
                        switch (a = h > .5 ? l / (2 - s - n) : l / (s + n), s) {
                            case e:
                                o = (t - r) / l + (t < r ? 6 : 0);
                                break;
                            case t:
                                o = (r - e) / l + 2;
                                break;
                            case r:
                                o = (e - t) / l + 4
                        }
                        o /= 6
                    }
                    return {
                        h: o,
                        s: a,
                        l: h
                    }
                }

                function u(e, t, r) {
                    return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + 6 * r * (t - e) : r < .5 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e
                }

                function c(e, t, r) {
                    var s, n, o;
                    if (e = i(e, 360), t = i(t, 100), r = i(r, 100), 0 === t) n = r, o = r, s = r;
                    else {
                        var a = r < .5 ? r * (1 + t) : r + t - r * t,
                            h = 2 * r - a;
                        s = u(h, a, e + 1 / 3), n = u(h, a, e), o = u(h, a, e - 1 / 3)
                    }
                    return {
                        r: 255 * s,
                        g: 255 * n,
                        b: 255 * o
                    }
                }

                function d(e, t, r) {
                    e = i(e, 255), t = i(t, 255), r = i(r, 255);
                    var s = Math.max(e, t, r),
                        n = Math.min(e, t, r),
                        o = 0,
                        a = s,
                        h = s - n,
                        l = 0 === s ? 0 : h / s;
                    if (s === n) o = 0;
                    else {
                        switch (s) {
                            case e:
                                o = (t - r) / h + (t < r ? 6 : 0);
                                break;
                            case t:
                                o = (r - e) / h + 2;
                                break;
                            case r:
                                o = (e - t) / h + 4
                        }
                        o /= 6
                    }
                    return {
                        h: o,
                        s: l,
                        v: a
                    }
                }

                function p(e, t, r) {
                    e = 6 * i(e, 360), t = i(t, 100), r = i(r, 100);
                    var s = Math.floor(e),
                        n = e - s,
                        o = r * (1 - t),
                        a = r * (1 - n * t),
                        h = r * (1 - (1 - n) * t),
                        l = s % 6;
                    return {
                        r: 255 * [r, a, o, o, h, r][l],
                        g: 255 * [h, r, r, a, o, o][l],
                        b: 255 * [o, o, h, r, r, a][l]
                    }
                }

                function f(e, t, r, i) {
                    var s = [a(Math.round(e).toString(16)), a(Math.round(t).toString(16)), a(Math.round(r).toString(16))];
                    return i && s[0].startsWith(s[0].charAt(1)) && s[1].startsWith(s[1].charAt(1)) && s[2].startsWith(s[2].charAt(1)) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) : s.join("")
                }

                function m(e, t, r, i, s) {
                    var n = [a(Math.round(e).toString(16)), a(Math.round(t).toString(16)), a(Math.round(r).toString(16)), a(y(i))];
                    return s && n[0].startsWith(n[0].charAt(1)) && n[1].startsWith(n[1].charAt(1)) && n[2].startsWith(n[2].charAt(1)) && n[3].startsWith(n[3].charAt(1)) ? n[0].charAt(0) + n[1].charAt(0) + n[2].charAt(0) + n[3].charAt(0) : n.join("")
                }

                function g(e, t, r, i) {
                    return [a(y(i)), a(Math.round(e).toString(16)), a(Math.round(t).toString(16)), a(Math.round(r).toString(16))].join("")
                }

                function y(e) {
                    return Math.round(255 * parseFloat(e)).toString(16)
                }

                function _(e) {
                    return v(e) / 255
                }

                function v(e) {
                    return parseInt(e, 16)
                }

                function S(e) {
                    return {
                        r: e >> 16,
                        g: (65280 & e) >> 8,
                        b: 255 & e
                    }
                }
                r.r(t), r.d(t, {
                    TinyColor: () => M,
                    bounds: () => U,
                    convertDecimalToHex: () => y,
                    convertHexToDecimal: () => _,
                    default: () => G,
                    fromRatio: () => H,
                    hslToRgb: () => c,
                    hsvToRgb: () => p,
                    inputToRGB: () => b,
                    isReadable: () => I,
                    isValidCSSUnit: () => P,
                    legacyRandom: () => k,
                    mostReadable: () => B,
                    names: () => T,
                    numberInputToObject: () => S,
                    parseIntFromHex: () => v,
                    random: () => F,
                    readability: () => R,
                    rgbToHex: () => f,
                    rgbToHsl: () => l,
                    rgbToHsv: () => d,
                    rgbToRgb: () => h,
                    rgbaToArgbHex: () => g,
                    rgbaToHex: () => m,
                    stringInputToObject: () => A,
                    tinycolor: () => C,
                    toMsFilter: () => D
                });
                var T = {
                    aliceblue: "#f0f8ff",
                    antiquewhite: "#faebd7",
                    aqua: "#00ffff",
                    aquamarine: "#7fffd4",
                    azure: "#f0ffff",
                    beige: "#f5f5dc",
                    bisque: "#ffe4c4",
                    black: "#000000",
                    blanchedalmond: "#ffebcd",
                    blue: "#0000ff",
                    blueviolet: "#8a2be2",
                    brown: "#a52a2a",
                    burlywood: "#deb887",
                    cadetblue: "#5f9ea0",
                    chartreuse: "#7fff00",
                    chocolate: "#d2691e",
                    coral: "#ff7f50",
                    cornflowerblue: "#6495ed",
                    cornsilk: "#fff8dc",
                    crimson: "#dc143c",
                    cyan: "#00ffff",
                    darkblue: "#00008b",
                    darkcyan: "#008b8b",
                    darkgoldenrod: "#b8860b",
                    darkgray: "#a9a9a9",
                    darkgreen: "#006400",
                    darkgrey: "#a9a9a9",
                    darkkhaki: "#bdb76b",
                    darkmagenta: "#8b008b",
                    darkolivegreen: "#556b2f",
                    darkorange: "#ff8c00",
                    darkorchid: "#9932cc",
                    darkred: "#8b0000",
                    darksalmon: "#e9967a",
                    darkseagreen: "#8fbc8f",
                    darkslateblue: "#483d8b",
                    darkslategray: "#2f4f4f",
                    darkslategrey: "#2f4f4f",
                    darkturquoise: "#00ced1",
                    darkviolet: "#9400d3",
                    deeppink: "#ff1493",
                    deepskyblue: "#00bfff",
                    dimgray: "#696969",
                    dimgrey: "#696969",
                    dodgerblue: "#1e90ff",
                    firebrick: "#b22222",
                    floralwhite: "#fffaf0",
                    forestgreen: "#228b22",
                    fuchsia: "#ff00ff",
                    gainsboro: "#dcdcdc",
                    ghostwhite: "#f8f8ff",
                    goldenrod: "#daa520",
                    gold: "#ffd700",
                    gray: "#808080",
                    green: "#008000",
                    greenyellow: "#adff2f",
                    grey: "#808080",
                    honeydew: "#f0fff0",
                    hotpink: "#ff69b4",
                    indianred: "#cd5c5c",
                    indigo: "#4b0082",
                    ivory: "#fffff0",
                    khaki: "#f0e68c",
                    lavenderblush: "#fff0f5",
                    lavender: "#e6e6fa",
                    lawngreen: "#7cfc00",
                    lemonchiffon: "#fffacd",
                    lightblue: "#add8e6",
                    lightcoral: "#f08080",
                    lightcyan: "#e0ffff",
                    lightgoldenrodyellow: "#fafad2",
                    lightgray: "#d3d3d3",
                    lightgreen: "#90ee90",
                    lightgrey: "#d3d3d3",
                    lightpink: "#ffb6c1",
                    lightsalmon: "#ffa07a",
                    lightseagreen: "#20b2aa",
                    lightskyblue: "#87cefa",
                    lightslategray: "#778899",
                    lightslategrey: "#778899",
                    lightsteelblue: "#b0c4de",
                    lightyellow: "#ffffe0",
                    lime: "#00ff00",
                    limegreen: "#32cd32",
                    linen: "#faf0e6",
                    magenta: "#ff00ff",
                    maroon: "#800000",
                    mediumaquamarine: "#66cdaa",
                    mediumblue: "#0000cd",
                    mediumorchid: "#ba55d3",
                    mediumpurple: "#9370db",
                    mediumseagreen: "#3cb371",
                    mediumslateblue: "#7b68ee",
                    mediumspringgreen: "#00fa9a",
                    mediumturquoise: "#48d1cc",
                    mediumvioletred: "#c71585",
                    midnightblue: "#191970",
                    mintcream: "#f5fffa",
                    mistyrose: "#ffe4e1",
                    moccasin: "#ffe4b5",
                    navajowhite: "#ffdead",
                    navy: "#000080",
                    oldlace: "#fdf5e6",
                    olive: "#808000",
                    olivedrab: "#6b8e23",
                    orange: "#ffa500",
                    orangered: "#ff4500",
                    orchid: "#da70d6",
                    palegoldenrod: "#eee8aa",
                    palegreen: "#98fb98",
                    paleturquoise: "#afeeee",
                    palevioletred: "#db7093",
                    papayawhip: "#ffefd5",
                    peachpuff: "#ffdab9",
                    peru: "#cd853f",
                    pink: "#ffc0cb",
                    plum: "#dda0dd",
                    powderblue: "#b0e0e6",
                    purple: "#800080",
                    rebeccapurple: "#663399",
                    red: "#ff0000",
                    rosybrown: "#bc8f8f",
                    royalblue: "#4169e1",
                    saddlebrown: "#8b4513",
                    salmon: "#fa8072",
                    sandybrown: "#f4a460",
                    seagreen: "#2e8b57",
                    seashell: "#fff5ee",
                    sienna: "#a0522d",
                    silver: "#c0c0c0",
                    skyblue: "#87ceeb",
                    slateblue: "#6a5acd",
                    slategray: "#708090",
                    slategrey: "#708090",
                    snow: "#fffafa",
                    springgreen: "#00ff7f",
                    steelblue: "#4682b4",
                    tan: "#d2b48c",
                    teal: "#008080",
                    thistle: "#d8bfd8",
                    tomato: "#ff6347",
                    turquoise: "#40e0d0",
                    violet: "#ee82ee",
                    wheat: "#f5deb3",
                    white: "#ffffff",
                    whitesmoke: "#f5f5f5",
                    yellow: "#ffff00",
                    yellowgreen: "#9acd32"
                };

                function b(e) {
                    var t = {
                            r: 0,
                            g: 0,
                            b: 0
                        },
                        r = 1,
                        i = null,
                        s = null,
                        a = null,
                        l = !1,
                        u = !1;
                    return "string" == typeof e && (e = A(e)), "object" == typeof e && (P(e.r) && P(e.g) && P(e.b) ? (t = h(e.r, e.g, e.b), l = !0, u = "%" === String(e.r).substr(-1) ? "prgb" : "rgb") : P(e.h) && P(e.s) && P(e.v) ? (i = o(e.s), s = o(e.v), t = p(e.h, i, s), l = !0, u = "hsv") : P(e.h) && P(e.s) && P(e.l) && (i = o(e.s), a = o(e.l), t = c(e.h, i, a), l = !0, u = "hsl"), Object.prototype.hasOwnProperty.call(e, "a") && (r = e.a)), r = n(r), {
                        ok: l,
                        format: e.format || u,
                        r: Math.min(255, Math.max(t.r, 0)),
                        g: Math.min(255, Math.max(t.g, 0)),
                        b: Math.min(255, Math.max(t.b, 0)),
                        a: r
                    }
                }
                var E = "(?:".concat("[-\\+]?\\d*\\.\\d+%?", ")|(?:").concat("[-\\+]?\\d+%?", ")"),
                    x = "[\\s|\\(]+(".concat(E, ")[,|\\s]+(").concat(E, ")[,|\\s]+(").concat(E, ")\\s*\\)?"),
                    w = "[\\s|\\(]+(".concat(E, ")[,|\\s]+(").concat(E, ")[,|\\s]+(").concat(E, ")[,|\\s]+(").concat(E, ")\\s*\\)?"),
                    O = {
                        CSS_UNIT: new RegExp(E),
                        rgb: new RegExp("rgb" + x),
                        rgba: new RegExp("rgba" + w),
                        hsl: new RegExp("hsl" + x),
                        hsla: new RegExp("hsla" + w),
                        hsv: new RegExp("hsv" + x),
                        hsva: new RegExp("hsva" + w),
                        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
                        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
                    };

                function A(e) {
                    if (0 === (e = e.trim().toLowerCase()).length) return !1;
                    var t = !1;
                    if (T[e]) e = T[e], t = !0;
                    else if ("transparent" === e) return {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0,
                        format: "name"
                    };
                    var r = O.rgb.exec(e);
                    return r ? {
                        r: r[1],
                        g: r[2],
                        b: r[3]
                    } : (r = O.rgba.exec(e)) ? {
                        r: r[1],
                        g: r[2],
                        b: r[3],
                        a: r[4]
                    } : (r = O.hsl.exec(e)) ? {
                        h: r[1],
                        s: r[2],
                        l: r[3]
                    } : (r = O.hsla.exec(e)) ? {
                        h: r[1],
                        s: r[2],
                        l: r[3],
                        a: r[4]
                    } : (r = O.hsv.exec(e)) ? {
                        h: r[1],
                        s: r[2],
                        v: r[3]
                    } : (r = O.hsva.exec(e)) ? {
                        h: r[1],
                        s: r[2],
                        v: r[3],
                        a: r[4]
                    } : (r = O.hex8.exec(e)) ? {
                        r: v(r[1]),
                        g: v(r[2]),
                        b: v(r[3]),
                        a: _(r[4]),
                        format: t ? "name" : "hex8"
                    } : (r = O.hex6.exec(e)) ? {
                        r: v(r[1]),
                        g: v(r[2]),
                        b: v(r[3]),
                        format: t ? "name" : "hex"
                    } : (r = O.hex4.exec(e)) ? {
                        r: v(r[1] + r[1]),
                        g: v(r[2] + r[2]),
                        b: v(r[3] + r[3]),
                        a: _(r[4] + r[4]),
                        format: t ? "name" : "hex8"
                    } : !!(r = O.hex3.exec(e)) && {
                        r: v(r[1] + r[1]),
                        g: v(r[2] + r[2]),
                        b: v(r[3] + r[3]),
                        format: t ? "name" : "hex"
                    }
                }

                function P(e) {
                    return Boolean(O.CSS_UNIT.exec(String(e)))
                }
                var M = function() {
                    function e(t, r) {
                        var i;
                        if (void 0 === t && (t = ""), void 0 === r && (r = {}), t instanceof e) return t;
                        "number" == typeof t && (t = S(t)), this.originalInput = t;
                        var s = b(t);
                        this.originalInput = t, this.r = s.r, this.g = s.g, this.b = s.b, this.a = s.a, this.roundA = Math.round(100 * this.a) / 100, this.format = null !== (i = r.format) && void 0 !== i ? i : s.format, this.gradientType = r.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = s.ok
                    }
                    return e.prototype.isDark = function() {
                        return this.getBrightness() < 128
                    }, e.prototype.isLight = function() {
                        return !this.isDark()
                    }, e.prototype.getBrightness = function() {
                        var e = this.toRgb();
                        return (299 * e.r + 587 * e.g + 114 * e.b) / 1e3
                    }, e.prototype.getLuminance = function() {
                        var e = this.toRgb(),
                            t = e.r / 255,
                            r = e.g / 255,
                            i = e.b / 255;
                        return .2126 * (t <= .03928 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4)) + .7152 * (r <= .03928 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4)) + .0722 * (i <= .03928 ? i / 12.92 : Math.pow((i + .055) / 1.055, 2.4))
                    }, e.prototype.getAlpha = function() {
                        return this.a
                    }, e.prototype.setAlpha = function(e) {
                        return this.a = n(e), this.roundA = Math.round(100 * this.a) / 100, this
                    }, e.prototype.isMonochrome = function() {
                        return 0 === this.toHsl().s
                    }, e.prototype.toHsv = function() {
                        var e = d(this.r, this.g, this.b);
                        return {
                            h: 360 * e.h,
                            s: e.s,
                            v: e.v,
                            a: this.a
                        }
                    }, e.prototype.toHsvString = function() {
                        var e = d(this.r, this.g, this.b),
                            t = Math.round(360 * e.h),
                            r = Math.round(100 * e.s),
                            i = Math.round(100 * e.v);
                        return 1 === this.a ? "hsv(".concat(t, ", ").concat(r, "%, ").concat(i, "%)") : "hsva(".concat(t, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")")
                    }, e.prototype.toHsl = function() {
                        var e = l(this.r, this.g, this.b);
                        return {
                            h: 360 * e.h,
                            s: e.s,
                            l: e.l,
                            a: this.a
                        }
                    }, e.prototype.toHslString = function() {
                        var e = l(this.r, this.g, this.b),
                            t = Math.round(360 * e.h),
                            r = Math.round(100 * e.s),
                            i = Math.round(100 * e.l);
                        return 1 === this.a ? "hsl(".concat(t, ", ").concat(r, "%, ").concat(i, "%)") : "hsla(".concat(t, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")")
                    }, e.prototype.toHex = function(e) {
                        return void 0 === e && (e = !1), f(this.r, this.g, this.b, e)
                    }, e.prototype.toHexString = function(e) {
                        return void 0 === e && (e = !1), "#" + this.toHex(e)
                    }, e.prototype.toHex8 = function(e) {
                        return void 0 === e && (e = !1), m(this.r, this.g, this.b, this.a, e)
                    }, e.prototype.toHex8String = function(e) {
                        return void 0 === e && (e = !1), "#" + this.toHex8(e)
                    }, e.prototype.toHexShortString = function(e) {
                        return void 0 === e && (e = !1), 1 === this.a ? this.toHexString(e) : this.toHex8String(e)
                    }, e.prototype.toRgb = function() {
                        return {
                            r: Math.round(this.r),
                            g: Math.round(this.g),
                            b: Math.round(this.b),
                            a: this.a
                        }
                    }, e.prototype.toRgbString = function() {
                        var e = Math.round(this.r),
                            t = Math.round(this.g),
                            r = Math.round(this.b);
                        return 1 === this.a ? "rgb(".concat(e, ", ").concat(t, ", ").concat(r, ")") : "rgba(".concat(e, ", ").concat(t, ", ").concat(r, ", ").concat(this.roundA, ")")
                    }, e.prototype.toPercentageRgb = function() {
                        var e = function(e) {
                            return "".concat(Math.round(100 * i(e, 255)), "%")
                        };
                        return {
                            r: e(this.r),
                            g: e(this.g),
                            b: e(this.b),
                            a: this.a
                        }
                    }, e.prototype.toPercentageRgbString = function() {
                        var e = function(e) {
                            return Math.round(100 * i(e, 255))
                        };
                        return 1 === this.a ? "rgb(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%)") : "rgba(".concat(e(this.r), "%, ").concat(e(this.g), "%, ").concat(e(this.b), "%, ").concat(this.roundA, ")")
                    }, e.prototype.toName = function() {
                        if (0 === this.a) return "transparent";
                        if (this.a < 1) return !1;
                        for (var e = "#" + f(this.r, this.g, this.b, !1), t = 0, r = Object.entries(T); t < r.length; t++) {
                            var i = r[t],
                                s = i[0];
                            if (e === i[1]) return s
                        }
                        return !1
                    }, e.prototype.toString = function(e) {
                        var t = Boolean(e);
                        e = null != e ? e : this.format;
                        var r = !1,
                            i = this.a < 1 && this.a >= 0;
                        return t || !i || !e.startsWith("hex") && "name" !== e ? ("rgb" === e && (r = this.toRgbString()), "prgb" === e && (r = this.toPercentageRgbString()), "hex" !== e && "hex6" !== e || (r = this.toHexString()), "hex3" === e && (r = this.toHexString(!0)), "hex4" === e && (r = this.toHex8String(!0)), "hex8" === e && (r = this.toHex8String()), "name" === e && (r = this.toName()), "hsl" === e && (r = this.toHslString()), "hsv" === e && (r = this.toHsvString()), r || this.toHexString()) : "name" === e && 0 === this.a ? this.toName() : this.toRgbString()
                    }, e.prototype.toNumber = function() {
                        return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b)
                    }, e.prototype.clone = function() {
                        return new e(this.toString())
                    }, e.prototype.lighten = function(t) {
                        void 0 === t && (t = 10);
                        var r = this.toHsl();
                        return r.l += t / 100, r.l = s(r.l), new e(r)
                    }, e.prototype.brighten = function(t) {
                        void 0 === t && (t = 10);
                        var r = this.toRgb();
                        return r.r = Math.max(0, Math.min(255, r.r - Math.round(-t / 100 * 255))), r.g = Math.max(0, Math.min(255, r.g - Math.round(-t / 100 * 255))), r.b = Math.max(0, Math.min(255, r.b - Math.round(-t / 100 * 255))), new e(r)
                    }, e.prototype.darken = function(t) {
                        void 0 === t && (t = 10);
                        var r = this.toHsl();
                        return r.l -= t / 100, r.l = s(r.l), new e(r)
                    }, e.prototype.tint = function(e) {
                        return void 0 === e && (e = 10), this.mix("white", e)
                    }, e.prototype.shade = function(e) {
                        return void 0 === e && (e = 10), this.mix("black", e)
                    }, e.prototype.desaturate = function(t) {
                        void 0 === t && (t = 10);
                        var r = this.toHsl();
                        return r.s -= t / 100, r.s = s(r.s), new e(r)
                    }, e.prototype.saturate = function(t) {
                        void 0 === t && (t = 10);
                        var r = this.toHsl();
                        return r.s += t / 100, r.s = s(r.s), new e(r)
                    }, e.prototype.greyscale = function() {
                        return this.desaturate(100)
                    }, e.prototype.spin = function(t) {
                        var r = this.toHsl(),
                            i = (r.h + t) % 360;
                        return r.h = i < 0 ? 360 + i : i, new e(r)
                    }, e.prototype.mix = function(t, r) {
                        void 0 === r && (r = 50);
                        var i = this.toRgb(),
                            s = new e(t).toRgb(),
                            n = r / 100;
                        return new e({
                            r: (s.r - i.r) * n + i.r,
                            g: (s.g - i.g) * n + i.g,
                            b: (s.b - i.b) * n + i.b,
                            a: (s.a - i.a) * n + i.a
                        })
                    }, e.prototype.analogous = function(t, r) {
                        void 0 === t && (t = 6), void 0 === r && (r = 30);
                        var i = this.toHsl(),
                            s = 360 / r,
                            n = [this];
                        for (i.h = (i.h - (s * t >> 1) + 720) % 360; --t;) i.h = (i.h + s) % 360, n.push(new e(i));
                        return n
                    }, e.prototype.complement = function() {
                        var t = this.toHsl();
                        return t.h = (t.h + 180) % 360, new e(t)
                    }, e.prototype.monochromatic = function(t) {
                        void 0 === t && (t = 6);
                        for (var r = this.toHsv(), i = r.h, s = r.s, n = r.v, o = [], a = 1 / t; t--;) o.push(new e({
                            h: i,
                            s,
                            v: n
                        })), n = (n + a) % 1;
                        return o
                    }, e.prototype.splitcomplement = function() {
                        var t = this.toHsl(),
                            r = t.h;
                        return [this, new e({
                            h: (r + 72) % 360,
                            s: t.s,
                            l: t.l
                        }), new e({
                            h: (r + 216) % 360,
                            s: t.s,
                            l: t.l
                        })]
                    }, e.prototype.onBackground = function(t) {
                        var r = this.toRgb(),
                            i = new e(t).toRgb(),
                            s = r.a + i.a * (1 - r.a);
                        return new e({
                            r: (r.r * r.a + i.r * i.a * (1 - r.a)) / s,
                            g: (r.g * r.a + i.g * i.a * (1 - r.a)) / s,
                            b: (r.b * r.a + i.b * i.a * (1 - r.a)) / s,
                            a: s
                        })
                    }, e.prototype.triad = function() {
                        return this.polyad(3)
                    }, e.prototype.tetrad = function() {
                        return this.polyad(4)
                    }, e.prototype.polyad = function(t) {
                        for (var r = this.toHsl(), i = r.h, s = [this], n = 360 / t, o = 1; o < t; o++) s.push(new e({
                            h: (i + o * n) % 360,
                            s: r.s,
                            l: r.l
                        }));
                        return s
                    }, e.prototype.equals = function(t) {
                        return this.toRgbString() === new e(t).toRgbString()
                    }, e
                }();

                function C(e, t) {
                    return void 0 === e && (e = ""), void 0 === t && (t = {}), new M(e, t)
                }

                function R(e, t) {
                    var r = new M(e),
                        i = new M(t);
                    return (Math.max(r.getLuminance(), i.getLuminance()) + .05) / (Math.min(r.getLuminance(), i.getLuminance()) + .05)
                }

                function I(e, t, r) {
                    var i, s;
                    void 0 === r && (r = {
                        level: "AA",
                        size: "small"
                    });
                    var n = R(e, t);
                    switch ((null !== (i = r.level) && void 0 !== i ? i : "AA") + (null !== (s = r.size) && void 0 !== s ? s : "small")) {
                        case "AAsmall":
                        case "AAAlarge":
                            return n >= 4.5;
                        case "AAlarge":
                            return n >= 3;
                        case "AAAsmall":
                            return n >= 7;
                        default:
                            return !1
                    }
                }

                function B(e, t, r) {
                    void 0 === r && (r = {
                        includeFallbackColors: !1,
                        level: "AA",
                        size: "small"
                    });
                    for (var i = null, s = 0, n = r.includeFallbackColors, o = r.level, a = r.size, h = 0, l = t; h < l.length; h++) {
                        var u = l[h],
                            c = R(e, u);
                        c > s && (s = c, i = new M(u))
                    }
                    return I(e, i, {
                        level: o,
                        size: a
                    }) || !n ? i : (r.includeFallbackColors = !1, B(e, ["#fff", "#000"], r))
                }

                function D(e, t) {
                    var r = new M(e),
                        i = "#" + g(r.r, r.g, r.b, r.a),
                        s = i,
                        n = r.gradientType ? "GradientType = 1, " : "";
                    if (t) {
                        var o = new M(t);
                        s = "#" + g(o.r, o.g, o.b, o.a)
                    }
                    return "progid:DXImageTransform.Microsoft.gradient(".concat(n, "startColorstr=").concat(i, ",endColorstr=").concat(s, ")")
                }

                function H(e, t) {
                    var r = {
                        r: o(e.r),
                        g: o(e.g),
                        b: o(e.b)
                    };
                    return void 0 !== e.a && (r.a = Number(e.a)), new M(r, t)
                }

                function k() {
                    return new M({
                        r: Math.random(),
                        g: Math.random(),
                        b: Math.random()
                    })
                }

                function F(e) {
                    if (void 0 === e && (e = {}), void 0 !== e.count && null !== e.count) {
                        var t = e.count,
                            r = [];
                        for (e.count = void 0; t > r.length;) e.count = null, e.seed && (e.seed += 1), r.push(F(e));
                        return e.count = t, r
                    }
                    var i = function(e, t) {
                            var r = L(function(e) {
                                var t = parseInt(e, 10);
                                if (!Number.isNaN(t) && t < 360 && t > 0) return [t, t];
                                if ("string" == typeof e) {
                                    var r = U.find((function(t) {
                                        return t.name === e
                                    }));
                                    if (r) {
                                        var i = j(r);
                                        if (i.hueRange) return i.hueRange
                                    }
                                    var s = new M(e);
                                    if (s.isValid) {
                                        var n = s.toHsv().h;
                                        return [n, n]
                                    }
                                }
                                return [0, 360]
                            }(e), t);
                            return r < 0 && (r = 360 + r), r
                        }(e.hue, e.seed),
                        s = function(e, t) {
                            if ("monochrome" === t.hue) return 0;
                            if ("random" === t.luminosity) return L([0, 100], t.seed);
                            var r = N(e).saturationRange,
                                i = r[0],
                                s = r[1];
                            switch (t.luminosity) {
                                case "bright":
                                    i = 55;
                                    break;
                                case "dark":
                                    i = s - 10;
                                    break;
                                case "light":
                                    s = 55
                            }
                            return L([i, s], t.seed)
                        }(i, e),
                        n = function(e, t, r) {
                            var i = function(e, t) {
                                    for (var r = N(e).lowerBounds, i = 0; i < r.length - 1; i++) {
                                        var s = r[i][0],
                                            n = r[i][1],
                                            o = r[i + 1][0],
                                            a = r[i + 1][1];
                                        if (t >= s && t <= o) {
                                            var h = (a - n) / (o - s);
                                            return h * t + (n - h * s)
                                        }
                                    }
                                    return 0
                                }(e, t),
                                s = 100;
                            switch (r.luminosity) {
                                case "dark":
                                    s = i + 20;
                                    break;
                                case "light":
                                    i = (s + i) / 2;
                                    break;
                                case "random":
                                    i = 0, s = 100
                            }
                            return L([i, s], r.seed)
                        }(i, s, e),
                        o = {
                            h: i,
                            s,
                            v: n
                        };
                    return void 0 !== e.alpha && (o.a = e.alpha), new M(o)
                }

                function N(e) {
                    e >= 334 && e <= 360 && (e -= 360);
                    for (var t = 0, r = U; t < r.length; t++) {
                        var i = j(r[t]);
                        if (i.hueRange && e >= i.hueRange[0] && e <= i.hueRange[1]) return i
                    }
                    throw Error("Color not found")
                }

                function L(e, t) {
                    if (void 0 === t) return Math.floor(e[0] + Math.random() * (e[1] + 1 - e[0]));
                    var r = e[1] || 1,
                        i = e[0] || 0,
                        s = (t = (9301 * t + 49297) % 233280) / 233280;
                    return Math.floor(i + s * (r - i))
                }

                function j(e) {
                    var t = e.lowerBounds[0][0],
                        r = e.lowerBounds[e.lowerBounds.length - 1][0],
                        i = e.lowerBounds[e.lowerBounds.length - 1][1],
                        s = e.lowerBounds[0][1];
                    return {
                        name: e.name,
                        hueRange: e.hueRange,
                        lowerBounds: e.lowerBounds,
                        saturationRange: [t, r],
                        brightnessRange: [i, s]
                    }
                }
                var U = [{
                    name: "monochrome",
                    hueRange: null,
                    lowerBounds: [
                        [0, 0],
                        [100, 0]
                    ]
                }, {
                    name: "red",
                    hueRange: [-26, 18],
                    lowerBounds: [
                        [20, 100],
                        [30, 92],
                        [40, 89],
                        [50, 85],
                        [60, 78],
                        [70, 70],
                        [80, 60],
                        [90, 55],
                        [100, 50]
                    ]
                }, {
                    name: "orange",
                    hueRange: [19, 46],
                    lowerBounds: [
                        [20, 100],
                        [30, 93],
                        [40, 88],
                        [50, 86],
                        [60, 85],
                        [70, 70],
                        [100, 70]
                    ]
                }, {
                    name: "yellow",
                    hueRange: [47, 62],
                    lowerBounds: [
                        [25, 100],
                        [40, 94],
                        [50, 89],
                        [60, 86],
                        [70, 84],
                        [80, 82],
                        [90, 80],
                        [100, 75]
                    ]
                }, {
                    name: "green",
                    hueRange: [63, 178],
                    lowerBounds: [
                        [30, 100],
                        [40, 90],
                        [50, 85],
                        [60, 81],
                        [70, 74],
                        [80, 64],
                        [90, 50],
                        [100, 40]
                    ]
                }, {
                    name: "blue",
                    hueRange: [179, 257],
                    lowerBounds: [
                        [20, 100],
                        [30, 86],
                        [40, 80],
                        [50, 74],
                        [60, 60],
                        [70, 52],
                        [80, 44],
                        [90, 39],
                        [100, 35]
                    ]
                }, {
                    name: "purple",
                    hueRange: [258, 282],
                    lowerBounds: [
                        [20, 100],
                        [30, 87],
                        [40, 79],
                        [50, 70],
                        [60, 65],
                        [70, 59],
                        [80, 52],
                        [90, 45],
                        [100, 42]
                    ]
                }, {
                    name: "pink",
                    hueRange: [283, 334],
                    lowerBounds: [
                        [20, 100],
                        [30, 90],
                        [40, 86],
                        [60, 84],
                        [80, 80],
                        [90, 75],
                        [100, 73]
                    ]
                }];
                const G = C
            },
            6872: (e, t) => {
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = {
                        grad: .9,
                        turn: 360,
                        rad: 360 / (2 * Math.PI)
                    },
                    i = function(e) {
                        return "string" == typeof e ? e.length > 0 : "number" == typeof e
                    },
                    s = function(e, t, r) {
                        return void 0 === t && (t = 0), void 0 === r && (r = Math.pow(10, t)), Math.round(r * e) / r + 0
                    },
                    n = function(e, t, r) {
                        return void 0 === t && (t = 0), void 0 === r && (r = 1), e > r ? r : e > t ? e : t
                    },
                    o = function(e) {
                        return (e = isFinite(e) ? e % 360 : 0) > 0 ? e : e + 360
                    },
                    a = function(e) {
                        return {
                            r: n(e.r, 0, 255),
                            g: n(e.g, 0, 255),
                            b: n(e.b, 0, 255),
                            a: n(e.a)
                        }
                    },
                    h = function(e) {
                        return {
                            r: s(e.r),
                            g: s(e.g),
                            b: s(e.b),
                            a: s(e.a, 3)
                        }
                    },
                    l = /^#([0-9a-f]{3,8})$/i,
                    u = function(e) {
                        var t = e.toString(16);
                        return t.length < 2 ? "0" + t : t
                    },
                    c = function(e) {
                        var t = e.r,
                            r = e.g,
                            i = e.b,
                            s = e.a,
                            n = Math.max(t, r, i),
                            o = n - Math.min(t, r, i),
                            a = o ? n === t ? (r - i) / o : n === r ? 2 + (i - t) / o : 4 + (t - r) / o : 0;
                        return {
                            h: 60 * (a < 0 ? a + 6 : a),
                            s: n ? o / n * 100 : 0,
                            v: n / 255 * 100,
                            a: s
                        }
                    },
                    d = function(e) {
                        var t = e.h,
                            r = e.s,
                            i = e.v,
                            s = e.a;
                        t = t / 360 * 6, r /= 100, i /= 100;
                        var n = Math.floor(t),
                            o = i * (1 - r),
                            a = i * (1 - (t - n) * r),
                            h = i * (1 - (1 - t + n) * r),
                            l = n % 6;
                        return {
                            r: 255 * [i, a, o, o, h, i][l],
                            g: 255 * [h, i, i, a, o, o][l],
                            b: 255 * [o, o, h, i, i, a][l],
                            a: s
                        }
                    },
                    p = function(e) {
                        return {
                            h: o(e.h),
                            s: n(e.s, 0, 100),
                            l: n(e.l, 0, 100),
                            a: n(e.a)
                        }
                    },
                    f = function(e) {
                        return {
                            h: s(e.h),
                            s: s(e.s),
                            l: s(e.l),
                            a: s(e.a, 3)
                        }
                    },
                    m = function(e) {
                        return d((r = (t = e).s, {
                            h: t.h,
                            s: (r *= ((i = t.l) < 50 ? i : 100 - i) / 100) > 0 ? 2 * r / (i + r) * 100 : 0,
                            v: i + r,
                            a: t.a
                        }));
                        var t, r, i
                    },
                    g = function(e) {
                        return {
                            h: (t = c(e)).h,
                            s: (s = (200 - (r = t.s)) * (i = t.v) / 100) > 0 && s < 200 ? r * i / 100 / (s <= 100 ? s : 200 - s) * 100 : 0,
                            l: s / 2,
                            a: t.a
                        };
                        var t, r, i, s
                    },
                    y = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
                    _ = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
                    v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
                    S = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
                    T = {
                        string: [
                            [function(e) {
                                var t = l.exec(e);
                                return t ? (e = t[1]).length <= 4 ? {
                                    r: parseInt(e[0] + e[0], 16),
                                    g: parseInt(e[1] + e[1], 16),
                                    b: parseInt(e[2] + e[2], 16),
                                    a: 4 === e.length ? s(parseInt(e[3] + e[3], 16) / 255, 2) : 1
                                } : 6 === e.length || 8 === e.length ? {
                                    r: parseInt(e.substr(0, 2), 16),
                                    g: parseInt(e.substr(2, 2), 16),
                                    b: parseInt(e.substr(4, 2), 16),
                                    a: 8 === e.length ? s(parseInt(e.substr(6, 2), 16) / 255, 2) : 1
                                } : null : null
                            }, "hex"],
                            [function(e) {
                                var t = v.exec(e) || S.exec(e);
                                return t ? t[2] !== t[4] || t[4] !== t[6] ? null : a({
                                    r: Number(t[1]) / (t[2] ? 100 / 255 : 1),
                                    g: Number(t[3]) / (t[4] ? 100 / 255 : 1),
                                    b: Number(t[5]) / (t[6] ? 100 / 255 : 1),
                                    a: void 0 === t[7] ? 1 : Number(t[7]) / (t[8] ? 100 : 1)
                                }) : null
                            }, "rgb"],
                            [function(e) {
                                var t = y.exec(e) || _.exec(e);
                                if (!t) return null;
                                var i, s, n = p({
                                    h: (i = t[1], s = t[2], void 0 === s && (s = "deg"), Number(i) * (r[s] || 1)),
                                    s: Number(t[3]),
                                    l: Number(t[4]),
                                    a: void 0 === t[5] ? 1 : Number(t[5]) / (t[6] ? 100 : 1)
                                });
                                return m(n)
                            }, "hsl"]
                        ],
                        object: [
                            [function(e) {
                                var t = e.r,
                                    r = e.g,
                                    s = e.b,
                                    n = e.a,
                                    o = void 0 === n ? 1 : n;
                                return i(t) && i(r) && i(s) ? a({
                                    r: Number(t),
                                    g: Number(r),
                                    b: Number(s),
                                    a: Number(o)
                                }) : null
                            }, "rgb"],
                            [function(e) {
                                var t = e.h,
                                    r = e.s,
                                    s = e.l,
                                    n = e.a,
                                    o = void 0 === n ? 1 : n;
                                if (!i(t) || !i(r) || !i(s)) return null;
                                var a = p({
                                    h: Number(t),
                                    s: Number(r),
                                    l: Number(s),
                                    a: Number(o)
                                });
                                return m(a)
                            }, "hsl"],
                            [function(e) {
                                var t = e.h,
                                    r = e.s,
                                    s = e.v,
                                    a = e.a,
                                    h = void 0 === a ? 1 : a;
                                if (!i(t) || !i(r) || !i(s)) return null;
                                var l = function(e) {
                                    return {
                                        h: o(e.h),
                                        s: n(e.s, 0, 100),
                                        v: n(e.v, 0, 100),
                                        a: n(e.a)
                                    }
                                }({
                                    h: Number(t),
                                    s: Number(r),
                                    v: Number(s),
                                    a: Number(h)
                                });
                                return d(l)
                            }, "hsv"]
                        ]
                    },
                    b = function(e, t) {
                        for (var r = 0; r < t.length; r++) {
                            var i = t[r][0](e);
                            if (i) return [i, t[r][1]]
                        }
                        return [null, void 0]
                    },
                    E = function(e) {
                        return "string" == typeof e ? b(e.trim(), T.string) : "object" == typeof e && null !== e ? b(e, T.object) : [null, void 0]
                    },
                    x = function(e, t) {
                        var r = g(e);
                        return {
                            h: r.h,
                            s: n(r.s + 100 * t, 0, 100),
                            l: r.l,
                            a: r.a
                        }
                    },
                    w = function(e) {
                        return (299 * e.r + 587 * e.g + 114 * e.b) / 1e3 / 255
                    },
                    O = function(e, t) {
                        var r = g(e);
                        return {
                            h: r.h,
                            s: r.s,
                            l: n(r.l + 100 * t, 0, 100),
                            a: r.a
                        }
                    },
                    A = function() {
                        function e(e) {
                            this.parsed = E(e)[0], this.rgba = this.parsed || {
                                r: 0,
                                g: 0,
                                b: 0,
                                a: 1
                            }
                        }
                        return e.prototype.isValid = function() {
                            return null !== this.parsed
                        }, e.prototype.brightness = function() {
                            return s(w(this.rgba), 2)
                        }, e.prototype.isDark = function() {
                            return w(this.rgba) < .5
                        }, e.prototype.isLight = function() {
                            return w(this.rgba) >= .5
                        }, e.prototype.toHex = function() {
                            return t = (e = h(this.rgba)).r, r = e.g, i = e.b, o = (n = e.a) < 1 ? u(s(255 * n)) : "", "#" + u(t) + u(r) + u(i) + o;
                            var e, t, r, i, n, o
                        }, e.prototype.toRgb = function() {
                            return h(this.rgba)
                        }, e.prototype.toRgbString = function() {
                            return t = (e = h(this.rgba)).r, r = e.g, i = e.b, (s = e.a) < 1 ? "rgba(" + t + ", " + r + ", " + i + ", " + s + ")" : "rgb(" + t + ", " + r + ", " + i + ")";
                            var e, t, r, i, s
                        }, e.prototype.toHsl = function() {
                            return f(g(this.rgba))
                        }, e.prototype.toHslString = function() {
                            return t = (e = f(g(this.rgba))).h, r = e.s, i = e.l, (s = e.a) < 1 ? "hsla(" + t + ", " + r + "%, " + i + "%, " + s + ")" : "hsl(" + t + ", " + r + "%, " + i + "%)";
                            var e, t, r, i, s
                        }, e.prototype.toHsv = function() {
                            return e = c(this.rgba), {
                                h: s(e.h),
                                s: s(e.s),
                                v: s(e.v),
                                a: s(e.a, 3)
                            };
                            var e
                        }, e.prototype.invert = function() {
                            return P({
                                r: 255 - (e = this.rgba).r,
                                g: 255 - e.g,
                                b: 255 - e.b,
                                a: e.a
                            });
                            var e
                        }, e.prototype.saturate = function(e) {
                            return void 0 === e && (e = .1), P(x(this.rgba, e))
                        }, e.prototype.desaturate = function(e) {
                            return void 0 === e && (e = .1), P(x(this.rgba, -e))
                        }, e.prototype.grayscale = function() {
                            return P(x(this.rgba, -1))
                        }, e.prototype.lighten = function(e) {
                            return void 0 === e && (e = .1), P(O(this.rgba, e))
                        }, e.prototype.darken = function(e) {
                            return void 0 === e && (e = .1), P(O(this.rgba, -e))
                        }, e.prototype.rotate = function(e) {
                            return void 0 === e && (e = 15), this.hue(this.hue() + e)
                        }, e.prototype.alpha = function(e) {
                            return "number" == typeof e ? P({
                                r: (t = this.rgba).r,
                                g: t.g,
                                b: t.b,
                                a: e
                            }) : s(this.rgba.a, 3);
                            var t
                        }, e.prototype.hue = function(e) {
                            var t = g(this.rgba);
                            return "number" == typeof e ? P({
                                h: e,
                                s: t.s,
                                l: t.l,
                                a: t.a
                            }) : s(t.h)
                        }, e.prototype.isEqual = function(e) {
                            return this.toHex() === P(e).toHex()
                        }, e
                    }(),
                    P = function(e) {
                        return e instanceof A ? e : new A(e)
                    },
                    M = [];
                t.Colord = A, t.colord = P, t.extend = function(e) {
                    e.forEach((function(e) {
                        M.indexOf(e) < 0 && (e(A, T), M.push(e))
                    }))
                }, t.getFormat = function(e) {
                    return E(e)[1]
                }, t.random = function() {
                    return new A({
                        r: 255 * Math.random(),
                        g: 255 * Math.random(),
                        b: 255 * Math.random()
                    })
                }
            },
            2121: e => {
                e.exports = function(e, t) {
                    var r = {
                            white: "#ffffff",
                            bisque: "#ffe4c4",
                            blue: "#0000ff",
                            cadetblue: "#5f9ea0",
                            chartreuse: "#7fff00",
                            chocolate: "#d2691e",
                            coral: "#ff7f50",
                            antiquewhite: "#faebd7",
                            aqua: "#00ffff",
                            azure: "#f0ffff",
                            whitesmoke: "#f5f5f5",
                            papayawhip: "#ffefd5",
                            plum: "#dda0dd",
                            blanchedalmond: "#ffebcd",
                            black: "#000000",
                            gold: "#ffd700",
                            goldenrod: "#daa520",
                            gainsboro: "#dcdcdc",
                            cornsilk: "#fff8dc",
                            cornflowerblue: "#6495ed",
                            burlywood: "#deb887",
                            aquamarine: "#7fffd4",
                            beige: "#f5f5dc",
                            crimson: "#dc143c",
                            cyan: "#00ffff",
                            darkblue: "#00008b",
                            darkcyan: "#008b8b",
                            darkgoldenrod: "#b8860b",
                            darkkhaki: "#bdb76b",
                            darkgray: "#a9a9a9",
                            darkgreen: "#006400",
                            darkgrey: "#a9a9a9",
                            peachpuff: "#ffdab9",
                            darkmagenta: "#8b008b",
                            darkred: "#8b0000",
                            darkorchid: "#9932cc",
                            darkorange: "#ff8c00",
                            darkslateblue: "#483d8b",
                            gray: "#808080",
                            darkslategray: "#2f4f4f",
                            darkslategrey: "#2f4f4f",
                            deeppink: "#ff1493",
                            deepskyblue: "#00bfff",
                            wheat: "#f5deb3",
                            firebrick: "#b22222",
                            floralwhite: "#fffaf0",
                            ghostwhite: "#f8f8ff",
                            darkviolet: "#9400d3",
                            magenta: "#ff00ff",
                            green: "#008000",
                            dodgerblue: "#1e90ff",
                            grey: "#808080",
                            honeydew: "#f0fff0",
                            hotpink: "#ff69b4",
                            blueviolet: "#8a2be2",
                            forestgreen: "#228b22",
                            lawngreen: "#7cfc00",
                            indianred: "#cd5c5c",
                            indigo: "#4b0082",
                            fuchsia: "#ff00ff",
                            brown: "#a52a2a",
                            maroon: "#800000",
                            mediumblue: "#0000cd",
                            lightcoral: "#f08080",
                            darkturquoise: "#00ced1",
                            lightcyan: "#e0ffff",
                            ivory: "#fffff0",
                            lightyellow: "#ffffe0",
                            lightsalmon: "#ffa07a",
                            lightseagreen: "#20b2aa",
                            linen: "#faf0e6",
                            mediumaquamarine: "#66cdaa",
                            lemonchiffon: "#fffacd",
                            lime: "#00ff00",
                            khaki: "#f0e68c",
                            mediumseagreen: "#3cb371",
                            limegreen: "#32cd32",
                            mediumspringgreen: "#00fa9a",
                            lightskyblue: "#87cefa",
                            lightblue: "#add8e6",
                            midnightblue: "#191970",
                            lightpink: "#ffb6c1",
                            mistyrose: "#ffe4e1",
                            moccasin: "#ffe4b5",
                            mintcream: "#f5fffa",
                            lightslategray: "#778899",
                            lightslategrey: "#778899",
                            navajowhite: "#ffdead",
                            navy: "#000080",
                            mediumvioletred: "#c71585",
                            powderblue: "#b0e0e6",
                            palegoldenrod: "#eee8aa",
                            oldlace: "#fdf5e6",
                            paleturquoise: "#afeeee",
                            mediumturquoise: "#48d1cc",
                            mediumorchid: "#ba55d3",
                            rebeccapurple: "#663399",
                            lightsteelblue: "#b0c4de",
                            mediumslateblue: "#7b68ee",
                            thistle: "#d8bfd8",
                            tan: "#d2b48c",
                            orchid: "#da70d6",
                            mediumpurple: "#9370db",
                            purple: "#800080",
                            pink: "#ffc0cb",
                            skyblue: "#87ceeb",
                            springgreen: "#00ff7f",
                            palegreen: "#98fb98",
                            red: "#ff0000",
                            yellow: "#ffff00",
                            slateblue: "#6a5acd",
                            lavenderblush: "#fff0f5",
                            peru: "#cd853f",
                            palevioletred: "#db7093",
                            violet: "#ee82ee",
                            teal: "#008080",
                            slategray: "#708090",
                            slategrey: "#708090",
                            aliceblue: "#f0f8ff",
                            darkseagreen: "#8fbc8f",
                            darkolivegreen: "#556b2f",
                            greenyellow: "#adff2f",
                            seagreen: "#2e8b57",
                            seashell: "#fff5ee",
                            tomato: "#ff6347",
                            silver: "#c0c0c0",
                            sienna: "#a0522d",
                            lavender: "#e6e6fa",
                            lightgreen: "#90ee90",
                            orange: "#ffa500",
                            orangered: "#ff4500",
                            steelblue: "#4682b4",
                            royalblue: "#4169e1",
                            turquoise: "#40e0d0",
                            yellowgreen: "#9acd32",
                            salmon: "#fa8072",
                            saddlebrown: "#8b4513",
                            sandybrown: "#f4a460",
                            rosybrown: "#bc8f8f",
                            darksalmon: "#e9967a",
                            lightgoldenrodyellow: "#fafad2",
                            snow: "#fffafa",
                            lightgrey: "#d3d3d3",
                            lightgray: "#d3d3d3",
                            dimgray: "#696969",
                            dimgrey: "#696969",
                            olivedrab: "#6b8e23",
                            olive: "#808000"
                        },
                        i = {};
                    for (var s in r) i[r[s]] = s;
                    var n = {};
                    e.prototype.toName = function(t) {
                        if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
                        var s, o, a = i[this.toHex()];
                        if (a) return a;
                        if (null == t ? void 0 : t.closest) {
                            var h = this.toRgb(),
                                l = 1 / 0,
                                u = "black";
                            if (!n.length)
                                for (var c in r) n[c] = new e(r[c]).toRgb();
                            for (var d in r) {
                                var p = (s = h, o = n[d], Math.pow(s.r - o.r, 2) + Math.pow(s.g - o.g, 2) + Math.pow(s.b - o.b, 2));
                                p < l && (l = p, u = d)
                            }
                            return u
                        }
                    }, t.string.push([function(t) {
                        var i = t.toLowerCase(),
                            s = "transparent" === i ? "#0000" : r[i];
                        return s ? new e(s).toRgb() : null
                    }, "name"])
                }
            },
            9187: e => {
                "use strict";

                function t(e, t, i) {
                    i = i || 2;
                    var n, o, a, h, c, d, f, m = t && t.length,
                        g = m ? t[0] * i : e.length,
                        y = r(e, 0, g, i, !0),
                        _ = [];
                    if (!y || y.next === y.prev) return _;
                    if (m && (y = function(e, t, i, s) {
                            var n, o, a, h = [];
                            for (n = 0, o = t.length; n < o; n++)(a = r(e, t[n] * s, n < o - 1 ? t[n + 1] * s : e.length, s, !1)) === a.next && (a.steiner = !0), h.push(p(a));
                            for (h.sort(l), n = 0; n < h.length; n++) i = u(h[n], i);
                            return i
                        }(e, t, y, i)), e.length > 80 * i) {
                        n = a = e[0], o = h = e[1];
                        for (var v = i; v < g; v += i)(c = e[v]) < n && (n = c), (d = e[v + 1]) < o && (o = d), c > a && (a = c), d > h && (h = d);
                        f = 0 !== (f = Math.max(a - n, h - o)) ? 32767 / f : 0
                    }
                    return s(y, _, i, n, o, f, 0), _
                }

                function r(e, t, r, i, s) {
                    var n, o;
                    if (s === O(e, t, r, i) > 0)
                        for (n = t; n < r; n += i) o = E(n, e[n], e[n + 1], o);
                    else
                        for (n = r - i; n >= t; n -= i) o = E(n, e[n], e[n + 1], o);
                    return o && y(o, o.next) && (x(o), o = o.next), o
                }

                function i(e, t) {
                    if (!e) return e;
                    t || (t = e);
                    var r, i = e;
                    do {
                        if (r = !1, i.steiner || !y(i, i.next) && 0 !== g(i.prev, i, i.next)) i = i.next;
                        else {
                            if (x(i), (i = t = i.prev) === i.next) break;
                            r = !0
                        }
                    } while (r || i !== t);
                    return t
                }

                function s(e, t, r, l, u, c, p) {
                    if (e) {
                        !p && c && function(e, t, r, i) {
                            var s = e;
                            do {
                                0 === s.z && (s.z = d(s.x, s.y, t, r, i)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next
                            } while (s !== e);
                            s.prevZ.nextZ = null, s.prevZ = null,
                                function(e) {
                                    var t, r, i, s, n, o, a, h, l = 1;
                                    do {
                                        for (r = e, e = null, n = null, o = 0; r;) {
                                            for (o++, i = r, a = 0, t = 0; t < l && (a++, i = i.nextZ); t++);
                                            for (h = l; a > 0 || h > 0 && i;) 0 !== a && (0 === h || !i || r.z <= i.z) ? (s = r, r = r.nextZ, a--) : (s = i, i = i.nextZ, h--), n ? n.nextZ = s : e = s, s.prevZ = n, n = s;
                                            r = i
                                        }
                                        n.nextZ = null, l *= 2
                                    } while (o > 1)
                                }(s)
                        }(e, l, u, c);
                        for (var f, m, g = e; e.prev !== e.next;)
                            if (f = e.prev, m = e.next, c ? o(e, l, u, c) : n(e)) t.push(f.i / r | 0), t.push(e.i / r | 0), t.push(m.i / r | 0), x(e), e = m.next, g = m.next;
                            else if ((e = m) === g) {
                            p ? 1 === p ? s(e = a(i(e), t, r), t, r, l, u, c, 2) : 2 === p && h(e, t, r, l, u, c) : s(i(e), t, r, l, u, c, 1);
                            break
                        }
                    }
                }

                function n(e) {
                    var t = e.prev,
                        r = e,
                        i = e.next;
                    if (g(t, r, i) >= 0) return !1;
                    for (var s = t.x, n = r.x, o = i.x, a = t.y, h = r.y, l = i.y, u = s < n ? s < o ? s : o : n < o ? n : o, c = a < h ? a < l ? a : l : h < l ? h : l, d = s > n ? s > o ? s : o : n > o ? n : o, p = a > h ? a > l ? a : l : h > l ? h : l, m = i.next; m !== t;) {
                        if (m.x >= u && m.x <= d && m.y >= c && m.y <= p && f(s, a, n, h, o, l, m.x, m.y) && g(m.prev, m, m.next) >= 0) return !1;
                        m = m.next
                    }
                    return !0
                }

                function o(e, t, r, i) {
                    var s = e.prev,
                        n = e,
                        o = e.next;
                    if (g(s, n, o) >= 0) return !1;
                    for (var a = s.x, h = n.x, l = o.x, u = s.y, c = n.y, p = o.y, m = a < h ? a < l ? a : l : h < l ? h : l, y = u < c ? u < p ? u : p : c < p ? c : p, _ = a > h ? a > l ? a : l : h > l ? h : l, v = u > c ? u > p ? u : p : c > p ? c : p, S = d(m, y, t, r, i), T = d(_, v, t, r, i), b = e.prevZ, E = e.nextZ; b && b.z >= S && E && E.z <= T;) {
                        if (b.x >= m && b.x <= _ && b.y >= y && b.y <= v && b !== s && b !== o && f(a, u, h, c, l, p, b.x, b.y) && g(b.prev, b, b.next) >= 0) return !1;
                        if (b = b.prevZ, E.x >= m && E.x <= _ && E.y >= y && E.y <= v && E !== s && E !== o && f(a, u, h, c, l, p, E.x, E.y) && g(E.prev, E, E.next) >= 0) return !1;
                        E = E.nextZ
                    }
                    for (; b && b.z >= S;) {
                        if (b.x >= m && b.x <= _ && b.y >= y && b.y <= v && b !== s && b !== o && f(a, u, h, c, l, p, b.x, b.y) && g(b.prev, b, b.next) >= 0) return !1;
                        b = b.prevZ
                    }
                    for (; E && E.z <= T;) {
                        if (E.x >= m && E.x <= _ && E.y >= y && E.y <= v && E !== s && E !== o && f(a, u, h, c, l, p, E.x, E.y) && g(E.prev, E, E.next) >= 0) return !1;
                        E = E.nextZ
                    }
                    return !0
                }

                function a(e, t, r) {
                    var s = e;
                    do {
                        var n = s.prev,
                            o = s.next.next;
                        !y(n, o) && _(n, s, s.next, o) && T(n, o) && T(o, n) && (t.push(n.i / r | 0), t.push(s.i / r | 0), t.push(o.i / r | 0), x(s), x(s.next), s = e = o), s = s.next
                    } while (s !== e);
                    return i(s)
                }

                function h(e, t, r, n, o, a) {
                    var h = e;
                    do {
                        for (var l = h.next.next; l !== h.prev;) {
                            if (h.i !== l.i && m(h, l)) {
                                var u = b(h, l);
                                return h = i(h, h.next), u = i(u, u.next), s(h, t, r, n, o, a, 0), void s(u, t, r, n, o, a, 0)
                            }
                            l = l.next
                        }
                        h = h.next
                    } while (h !== e)
                }

                function l(e, t) {
                    return e.x - t.x
                }

                function u(e, t) {
                    var r = function(e, t) {
                        var r, i = t,
                            s = e.x,
                            n = e.y,
                            o = -1 / 0;
                        do {
                            if (n <= i.y && n >= i.next.y && i.next.y !== i.y) {
                                var a = i.x + (n - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                                if (a <= s && a > o && (o = a, r = i.x < i.next.x ? i : i.next, a === s)) return r
                            }
                            i = i.next
                        } while (i !== t);
                        if (!r) return null;
                        var h, l = r,
                            u = r.x,
                            d = r.y,
                            p = 1 / 0;
                        i = r;
                        do {
                            s >= i.x && i.x >= u && s !== i.x && f(n < d ? s : o, n, u, d, n < d ? o : s, n, i.x, i.y) && (h = Math.abs(n - i.y) / (s - i.x), T(i, e) && (h < p || h === p && (i.x > r.x || i.x === r.x && c(r, i))) && (r = i, p = h)), i = i.next
                        } while (i !== l);
                        return r
                    }(e, t);
                    if (!r) return t;
                    var s = b(r, e);
                    return i(s, s.next), i(r, r.next)
                }

                function c(e, t) {
                    return g(e.prev, e, t.prev) < 0 && g(t.next, e, e.next) < 0
                }

                function d(e, t, r, i, s) {
                    return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - r) * s | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - i) * s | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
                }

                function p(e) {
                    var t = e,
                        r = e;
                    do {
                        (t.x < r.x || t.x === r.x && t.y < r.y) && (r = t), t = t.next
                    } while (t !== e);
                    return r
                }

                function f(e, t, r, i, s, n, o, a) {
                    return (s - o) * (t - a) >= (e - o) * (n - a) && (e - o) * (i - a) >= (r - o) * (t - a) && (r - o) * (n - a) >= (s - o) * (i - a)
                }

                function m(e, t) {
                    return e.next.i !== t.i && e.prev.i !== t.i && ! function(e, t) {
                        var r = e;
                        do {
                            if (r.i !== e.i && r.next.i !== e.i && r.i !== t.i && r.next.i !== t.i && _(r, r.next, e, t)) return !0;
                            r = r.next
                        } while (r !== e);
                        return !1
                    }(e, t) && (T(e, t) && T(t, e) && function(e, t) {
                        var r = e,
                            i = !1,
                            s = (e.x + t.x) / 2,
                            n = (e.y + t.y) / 2;
                        do {
                            r.y > n != r.next.y > n && r.next.y !== r.y && s < (r.next.x - r.x) * (n - r.y) / (r.next.y - r.y) + r.x && (i = !i), r = r.next
                        } while (r !== e);
                        return i
                    }(e, t) && (g(e.prev, e, t.prev) || g(e, t.prev, t)) || y(e, t) && g(e.prev, e, e.next) > 0 && g(t.prev, t, t.next) > 0)
                }

                function g(e, t, r) {
                    return (t.y - e.y) * (r.x - t.x) - (t.x - e.x) * (r.y - t.y)
                }

                function y(e, t) {
                    return e.x === t.x && e.y === t.y
                }

                function _(e, t, r, i) {
                    var s = S(g(e, t, r)),
                        n = S(g(e, t, i)),
                        o = S(g(r, i, e)),
                        a = S(g(r, i, t));
                    return s !== n && o !== a || !(0 !== s || !v(e, r, t)) || !(0 !== n || !v(e, i, t)) || !(0 !== o || !v(r, e, i)) || !(0 !== a || !v(r, t, i))
                }

                function v(e, t, r) {
                    return t.x <= Math.max(e.x, r.x) && t.x >= Math.min(e.x, r.x) && t.y <= Math.max(e.y, r.y) && t.y >= Math.min(e.y, r.y)
                }

                function S(e) {
                    return e > 0 ? 1 : e < 0 ? -1 : 0
                }

                function T(e, t) {
                    return g(e.prev, e, e.next) < 0 ? g(e, t, e.next) >= 0 && g(e, e.prev, t) >= 0 : g(e, t, e.prev) < 0 || g(e, e.next, t) < 0
                }

                function b(e, t) {
                    var r = new w(e.i, e.x, e.y),
                        i = new w(t.i, t.x, t.y),
                        s = e.next,
                        n = t.prev;
                    return e.next = t, t.prev = e, r.next = s, s.prev = r, i.next = r, r.prev = i, n.next = i, i.prev = n, i
                }

                function E(e, t, r, i) {
                    var s = new w(e, t, r);
                    return i ? (s.next = i.next, s.prev = i, i.next.prev = s, i.next = s) : (s.prev = s, s.next = s), s
                }

                function x(e) {
                    e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
                }

                function w(e, t, r) {
                    this.i = e, this.x = t, this.y = r, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
                }

                function O(e, t, r, i) {
                    for (var s = 0, n = t, o = r - i; n < r; n += i) s += (e[o] - e[n]) * (e[n + 1] + e[o + 1]), o = n;
                    return s
                }
                e.exports = t, e.exports.default = t, t.deviation = function(e, t, r, i) {
                    var s = t && t.length,
                        n = s ? t[0] * r : e.length,
                        o = Math.abs(O(e, 0, n, r));
                    if (s)
                        for (var a = 0, h = t.length; a < h; a++) {
                            var l = t[a] * r,
                                u = a < h - 1 ? t[a + 1] * r : e.length;
                            o -= Math.abs(O(e, l, u, r))
                        }
                    var c = 0;
                    for (a = 0; a < i.length; a += 3) {
                        var d = i[a] * r,
                            p = i[a + 1] * r,
                            f = i[a + 2] * r;
                        c += Math.abs((e[d] - e[f]) * (e[p + 1] - e[d + 1]) - (e[d] - e[p]) * (e[f + 1] - e[d + 1]))
                    }
                    return 0 === o && 0 === c ? 0 : Math.abs((c - o) / o)
                }, t.flatten = function(e) {
                    for (var t = e[0][0].length, r = {
                            vertices: [],
                            holes: [],
                            dimensions: t
                        }, i = 0, s = 0; s < e.length; s++) {
                        for (var n = 0; n < e[s].length; n++)
                            for (var o = 0; o < t; o++) r.vertices.push(e[s][n][o]);
                        s > 0 && (i += e[s - 1].length, r.holes.push(i))
                    }
                    return r
                }
            },
            6729: e => {
                "use strict";
                var t = Object.prototype.hasOwnProperty,
                    r = "~";

                function i() {}

                function s(e, t, r) {
                    this.fn = e, this.context = t, this.once = r || !1
                }

                function n(e, t, i, n, o) {
                    if ("function" != typeof i) throw new TypeError("The listener must be a function");
                    var a = new s(i, n || e, o),
                        h = r ? r + t : t;
                    return e._events[h] ? e._events[h].fn ? e._events[h] = [e._events[h], a] : e._events[h].push(a) : (e._events[h] = a, e._eventsCount++), e
                }

                function o(e, t) {
                    0 == --e._eventsCount ? e._events = new i : delete e._events[t]
                }

                function a() {
                    this._events = new i, this._eventsCount = 0
                }
                Object.create && (i.prototype = Object.create(null), (new i).__proto__ || (r = !1)), a.prototype.eventNames = function() {
                    var e, i, s = [];
                    if (0 === this._eventsCount) return s;
                    for (i in e = this._events) t.call(e, i) && s.push(r ? i.slice(1) : i);
                    return Object.getOwnPropertySymbols ? s.concat(Object.getOwnPropertySymbols(e)) : s
                }, a.prototype.listeners = function(e) {
                    var t = r ? r + e : e,
                        i = this._events[t];
                    if (!i) return [];
                    if (i.fn) return [i.fn];
                    for (var s = 0, n = i.length, o = new Array(n); s < n; s++) o[s] = i[s].fn;
                    return o
                }, a.prototype.listenerCount = function(e) {
                    var t = r ? r + e : e,
                        i = this._events[t];
                    return i ? i.fn ? 1 : i.length : 0
                }, a.prototype.emit = function(e, t, i, s, n, o) {
                    var a = r ? r + e : e;
                    if (!this._events[a]) return !1;
                    var h, l, u = this._events[a],
                        c = arguments.length;
                    if (u.fn) {
                        switch (u.once && this.removeListener(e, u.fn, void 0, !0), c) {
                            case 1:
                                return u.fn.call(u.context), !0;
                            case 2:
                                return u.fn.call(u.context, t), !0;
                            case 3:
                                return u.fn.call(u.context, t, i), !0;
                            case 4:
                                return u.fn.call(u.context, t, i, s), !0;
                            case 5:
                                return u.fn.call(u.context, t, i, s, n), !0;
                            case 6:
                                return u.fn.call(u.context, t, i, s, n, o), !0
                        }
                        for (l = 1, h = new Array(c - 1); l < c; l++) h[l - 1] = arguments[l];
                        u.fn.apply(u.context, h)
                    } else {
                        var d, p = u.length;
                        for (l = 0; l < p; l++) switch (u[l].once && this.removeListener(e, u[l].fn, void 0, !0), c) {
                            case 1:
                                u[l].fn.call(u[l].context);
                                break;
                            case 2:
                                u[l].fn.call(u[l].context, t);
                                break;
                            case 3:
                                u[l].fn.call(u[l].context, t, i);
                                break;
                            case 4:
                                u[l].fn.call(u[l].context, t, i, s);
                                break;
                            default:
                                if (!h)
                                    for (d = 1, h = new Array(c - 1); d < c; d++) h[d - 1] = arguments[d];
                                u[l].fn.apply(u[l].context, h)
                        }
                    }
                    return !0
                }, a.prototype.on = function(e, t, r) {
                    return n(this, e, t, r, !1)
                }, a.prototype.once = function(e, t, r) {
                    return n(this, e, t, r, !0)
                }, a.prototype.removeListener = function(e, t, i, s) {
                    var n = r ? r + e : e;
                    if (!this._events[n]) return this;
                    if (!t) return o(this, n), this;
                    var a = this._events[n];
                    if (a.fn) a.fn !== t || s && !a.once || i && a.context !== i || o(this, n);
                    else {
                        for (var h = 0, l = [], u = a.length; h < u; h++)(a[h].fn !== t || s && !a[h].once || i && a[h].context !== i) && l.push(a[h]);
                        l.length ? this._events[n] = 1 === l.length ? l[0] : l : o(this, n)
                    }
                    return this
                }, a.prototype.removeAllListeners = function(e) {
                    var t;
                    return e ? (t = r ? r + e : e, this._events[t] && o(this, t)) : (this._events = new i, this._eventsCount = 0), this
                }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, e.exports = a
            },
            891: (e, t, r) => {
                "use strict";
                r.r(t), r.d(t, {
                    default: () => v
                });
                var i = /iPhone/i,
                    s = /iPod/i,
                    n = /iPad/i,
                    o = /\biOS-universal(?:.+)Mac\b/i,
                    a = /\bAndroid(?:.+)Mobile\b/i,
                    h = /Android/i,
                    l = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
                    u = /Silk/i,
                    c = /Windows Phone/i,
                    d = /\bWindows(?:.+)ARM\b/i,
                    p = /BlackBerry/i,
                    f = /BB10/i,
                    m = /Opera Mini/i,
                    g = /\b(CriOS|Chrome)(?:.+)Mobile/i,
                    y = /Mobile(?:.+)Firefox\b/i,
                    _ = function(e) {
                        return void 0 !== e && "MacIntel" === e.platform && "number" == typeof e.maxTouchPoints && e.maxTouchPoints > 1 && "undefined" == typeof MSStream
                    };

                function v(e) {
                    var t = {
                        userAgent: "",
                        platform: "",
                        maxTouchPoints: 0
                    };
                    e || "undefined" == typeof navigator ? "string" == typeof e ? t.userAgent = e : e && e.userAgent && (t = {
                        userAgent: e.userAgent,
                        platform: e.platform,
                        maxTouchPoints: e.maxTouchPoints || 0
                    }) : t = {
                        userAgent: navigator.userAgent,
                        platform: navigator.platform,
                        maxTouchPoints: navigator.maxTouchPoints || 0
                    };
                    var r = t.userAgent,
                        v = r.split("[FBAN");
                    void 0 !== v[1] && (r = v[0]), void 0 !== (v = r.split("Twitter"))[1] && (r = v[0]);
                    var S = function(e) {
                            return function(t) {
                                return t.test(e)
                            }
                        }(r),
                        T = {
                            apple: {
                                phone: S(i) && !S(c),
                                ipod: S(s),
                                tablet: !S(i) && (S(n) || _(t)) && !S(c),
                                universal: S(o),
                                device: (S(i) || S(s) || S(n) || S(o) || _(t)) && !S(c)
                            },
                            amazon: {
                                phone: S(l),
                                tablet: !S(l) && S(u),
                                device: S(l) || S(u)
                            },
                            android: {
                                phone: !S(c) && S(l) || !S(c) && S(a),
                                tablet: !S(c) && !S(l) && !S(a) && (S(u) || S(h)),
                                device: !S(c) && (S(l) || S(u) || S(a) || S(h)) || S(/\bokhttp\b/i)
                            },
                            windows: {
                                phone: S(c),
                                tablet: S(d),
                                device: S(c) || S(d)
                            },
                            other: {
                                blackberry: S(p),
                                blackberry10: S(f),
                                opera: S(m),
                                firefox: S(y),
                                chrome: S(g),
                                device: S(p) || S(f) || S(m) || S(y) || S(g)
                            },
                            any: !1,
                            phone: !1,
                            tablet: !1
                        };
                    return T.any = T.apple.device || T.android.device || T.windows.device || T.other.device, T.phone = T.apple.phone || T.android.phone || T.windows.phone, T.tablet = T.apple.tablet || T.android.tablet || T.windows.tablet, T
                }
            },
            741: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(2005),
                    n = r(7155),
                    o = r(1496),
                    a = r(7290),
                    h = r(9798),
                    l = r(9030);
                const u = {
                    AlphaFilter: s.AlphaFilter,
                    BlurFilter: n.BlurFilter,
                    BlurFilterPass: n.BlurFilterPass,
                    ColorMatrixFilter: o.ColorMatrixFilter,
                    DisplacementFilter: a.DisplacementFilter,
                    FXAAFilter: h.FXAAFilter,
                    NoiseFilter: l.NoiseFilter
                };
                Object.entries(u).forEach((([e, t]) => {
                    Object.defineProperty(u, e, {
                        get: () => (i.utils.deprecation("7.1.0", `filters.${e} has moved to ${e}`), t)
                    })
                })), t.filters = u
            },
            8687: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), r(4142), r(1181), r(9989);
                var i = r(741),
                    s = r(8495),
                    n = r(8249),
                    o = r(4645),
                    a = r(4018),
                    h = r(7163),
                    l = r(2781),
                    u = r(4868),
                    c = r(2110),
                    d = r(2005),
                    p = r(7155),
                    f = r(1496),
                    m = r(7290),
                    g = r(9798),
                    y = r(9030),
                    _ = r(4742),
                    v = r(1917),
                    S = r(151),
                    T = r(9212),
                    b = r(8642),
                    E = r(2517),
                    x = r(9189),
                    w = r(1198),
                    O = r(7551),
                    A = r(1418),
                    P = r(138),
                    M = r(3826);
                t.filters = i.filters, Object.keys(s).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return s[e]
                        }
                    })
                })), Object.keys(n).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return n[e]
                        }
                    })
                })), Object.keys(o).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return o[e]
                        }
                    })
                })), Object.keys(a).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return a[e]
                        }
                    })
                })), Object.keys(h).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return h[e]
                        }
                    })
                })), Object.keys(l).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return l[e]
                        }
                    })
                })), Object.keys(u).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return u[e]
                        }
                    })
                })), Object.keys(c).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return c[e]
                        }
                    })
                })), Object.keys(d).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return d[e]
                        }
                    })
                })), Object.keys(p).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return p[e]
                        }
                    })
                })), Object.keys(f).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return f[e]
                        }
                    })
                })), Object.keys(m).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return m[e]
                        }
                    })
                })), Object.keys(g).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return g[e]
                        }
                    })
                })), Object.keys(y).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return y[e]
                        }
                    })
                })), Object.keys(_).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return _[e]
                        }
                    })
                })), Object.keys(v).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return v[e]
                        }
                    })
                })), Object.keys(S).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return S[e]
                        }
                    })
                })), Object.keys(T).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return T[e]
                        }
                    })
                })), Object.keys(b).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return b[e]
                        }
                    })
                })), Object.keys(E).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return E[e]
                        }
                    })
                })), Object.keys(x).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return x[e]
                        }
                    })
                })), Object.keys(w).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return w[e]
                        }
                    })
                })), Object.keys(O).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return O[e]
                        }
                    })
                })), Object.keys(A).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return A[e]
                        }
                    })
                })), Object.keys(P).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return P[e]
                        }
                    })
                })), Object.keys(M).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return M[e]
                        }
                    })
                }))
            },
            569: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(2781),
                    n = r(4868),
                    o = r(1690);
                s.DisplayObject.mixin(o.accessibleTarget);
                class a {
                    constructor(e) {
                        this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (i.utils.isMobile.tablet || i.utils.isMobile.phone) && this.createTouchHook();
                        const t = document.createElement("div");
                        t.style.width = "100px", t.style.height = "100px", t.style.position = "absolute", t.style.top = "0px", t.style.left = "0px", t.style.zIndex = 2..toString(), this.div = t, this.renderer = e, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1)
                    }
                    get isActive() {
                        return this._isActive
                    }
                    get isMobileAccessibility() {
                        return this._isMobileAccessibility
                    }
                    createTouchHook() {
                        const e = document.createElement("button");
                        e.style.width = "1px", e.style.height = "1px", e.style.position = "absolute", e.style.top = "-1000px", e.style.left = "-1000px", e.style.zIndex = 2..toString(), e.style.backgroundColor = "#FF0000", e.title = "select to enable accessibility for this content", e.addEventListener("focus", (() => {
                            this._isMobileAccessibility = !0, this.activate(), this.destroyTouchHook()
                        })), document.body.appendChild(e), this._hookDiv = e
                    }
                    destroyTouchHook() {
                        this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null)
                    }
                    activate() {
                        this._isActive || (this._isActive = !0, globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), this.renderer.view.parentNode?.appendChild(this.div))
                    }
                    deactivate() {
                        this._isActive && !this._isMobileAccessibility && (this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), this.div.parentNode?.removeChild(this.div))
                    }
                    updateAccessibleObjects(e) {
                        if (!e.visible || !e.accessibleChildren) return;
                        e.accessible && e.isInteractive() && (e._accessibleActive || this.addChild(e), e.renderId = this.renderId);
                        const t = e.children;
                        if (t)
                            for (let e = 0; e < t.length; e++) this.updateAccessibleObjects(t[e])
                    }
                    update() {
                        const e = performance.now();
                        if (i.utils.isMobile.android.device && e < this.androidUpdateCount) return;
                        if (this.androidUpdateCount = e + this.androidUpdateFrequency, !this.renderer.renderingToScreen) return;
                        this.renderer.lastObjectRendered && this.updateAccessibleObjects(this.renderer.lastObjectRendered);
                        const {
                            x: t,
                            y: r,
                            width: s,
                            height: n
                        } = this.renderer.view.getBoundingClientRect(), {
                            width: o,
                            height: a,
                            resolution: h
                        } = this.renderer, l = s / o * h, u = n / a * h;
                        let c = this.div;
                        c.style.left = `${t}px`, c.style.top = `${r}px`, c.style.width = `${o}px`, c.style.height = `${a}px`;
                        for (let e = 0; e < this.children.length; e++) {
                            const t = this.children[e];
                            if (t.renderId !== this.renderId) t._accessibleActive = !1, i.utils.removeItems(this.children, e, 1), this.div.removeChild(t._accessibleDiv), this.pool.push(t._accessibleDiv), t._accessibleDiv = null, e--;
                            else {
                                c = t._accessibleDiv;
                                let e = t.hitArea;
                                const r = t.worldTransform;
                                t.hitArea ? (c.style.left = (r.tx + e.x * r.a) * l + "px", c.style.top = (r.ty + e.y * r.d) * u + "px", c.style.width = e.width * r.a * l + "px", c.style.height = e.height * r.d * u + "px") : (e = t.getBounds(), this.capHitArea(e), c.style.left = e.x * l + "px", c.style.top = e.y * u + "px", c.style.width = e.width * l + "px", c.style.height = e.height * u + "px", c.title !== t.accessibleTitle && null !== t.accessibleTitle && (c.title = t.accessibleTitle), c.getAttribute("aria-label") !== t.accessibleHint && null !== t.accessibleHint && c.setAttribute("aria-label", t.accessibleHint)), t.accessibleTitle === c.title && t.tabIndex === c.tabIndex || (c.title = t.accessibleTitle, c.tabIndex = t.tabIndex, this.debug && this.updateDebugHTML(c))
                            }
                        }
                        this.renderId++
                    }
                    updateDebugHTML(e) {
                        e.innerHTML = `type: ${e.type}</br> title : ${e.title}</br> tabIndex: ${e.tabIndex}`
                    }
                    capHitArea(e) {
                        e.x < 0 && (e.width += e.x, e.x = 0), e.y < 0 && (e.height += e.y, e.y = 0);
                        const {
                            width: t,
                            height: r
                        } = this.renderer;
                        e.x + e.width > t && (e.width = t - e.x), e.y + e.height > r && (e.height = r - e.y)
                    }
                    addChild(e) {
                        let t = this.pool.pop();
                        t || (t = document.createElement("button"), t.style.width = "100px", t.style.height = "100px", t.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", t.style.position = "absolute", t.style.zIndex = 2..toString(), t.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? t.setAttribute("aria-live", "off") : t.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? t.setAttribute("aria-relevant", "additions") : t.setAttribute("aria-relevant", "text"), t.addEventListener("click", this._onClick.bind(this)), t.addEventListener("focus", this._onFocus.bind(this)), t.addEventListener("focusout", this._onFocusOut.bind(this))), t.style.pointerEvents = e.accessiblePointerEvents, t.type = e.accessibleType, e.accessibleTitle && null !== e.accessibleTitle ? t.title = e.accessibleTitle : e.accessibleHint && null !== e.accessibleHint || (t.title = `displayObject ${e.tabIndex}`), e.accessibleHint && null !== e.accessibleHint && t.setAttribute("aria-label", e.accessibleHint), this.debug && this.updateDebugHTML(t), e._accessibleActive = !0, e._accessibleDiv = t, t.displayObject = e, this.children.push(e), this.div.appendChild(e._accessibleDiv), e._accessibleDiv.tabIndex = e.tabIndex
                    }
                    _dispatchEvent(e, t) {
                        const {
                            displayObject: r
                        } = e.target, i = this.renderer.events.rootBoundary, s = Object.assign(new n.FederatedEvent(i), {
                            target: r
                        });
                        i.rootTarget = this.renderer.lastObjectRendered, t.forEach((e => i.dispatchEvent(s, e)))
                    }
                    _onClick(e) {
                        this._dispatchEvent(e, ["click", "pointertap", "tap"])
                    }
                    _onFocus(e) {
                        e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "assertive"), this._dispatchEvent(e, ["mouseover"])
                    }
                    _onFocusOut(e) {
                        e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "polite"), this._dispatchEvent(e, ["mouseout"])
                    }
                    _onKeyDown(e) {
                        9 === e.keyCode && this.activate()
                    }
                    _onMouseMove(e) {
                        0 === e.movementX && 0 === e.movementY || this.deactivate()
                    }
                    destroy() {
                        this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null
                    }
                }
                a.extension = {
                    name: "accessibility",
                    type: [i.ExtensionType.RendererPlugin, i.ExtensionType.CanvasRendererPlugin]
                }, i.extensions.add(a), t.AccessibilityManager = a
            },
            1690: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.accessibleTarget = {
                    accessible: !1,
                    accessibleTitle: null,
                    accessibleHint: null,
                    tabIndex: 0,
                    _accessibleActive: !1,
                    _accessibleDiv: null,
                    accessibleType: "button",
                    accessiblePointerEvents: "auto",
                    accessibleChildren: !0,
                    renderId: -1
                }
            },
            8495: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(569),
                    s = r(1690);
                t.AccessibilityManager = i.AccessibilityManager, t.accessibleTarget = s.accessibleTarget
            },
            736: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(2781);
                const n = class {
                    constructor(e) {
                        this.stage = new s.Container, e = Object.assign({
                            forceCanvas: !1
                        }, e), this.renderer = i.autoDetectRenderer(e), n._plugins.forEach((t => {
                            t.init.call(this, e)
                        }))
                    }
                    render() {
                        this.renderer.render(this.stage)
                    }
                    get view() {
                        return this.renderer.view
                    }
                    get screen() {
                        return this.renderer.screen
                    }
                    destroy(e, t) {
                        const r = n._plugins.slice(0);
                        r.reverse(), r.forEach((e => {
                            e.destroy.call(this)
                        })), this.stage.destroy(t), this.stage = null, this.renderer.destroy(e), this.renderer = null
                    }
                };
                let o = n;
                o._plugins = [], i.extensions.handleByList(i.ExtensionType.Application, o._plugins), t.Application = o
            },
            3682: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                class s {
                    static init(e) {
                        Object.defineProperty(this, "resizeTo", {
                            set(e) {
                                globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = e, e && (globalThis.addEventListener("resize", this.queueResize), this.resize())
                            },
                            get() {
                                return this._resizeTo
                            }
                        }), this.queueResize = () => {
                            this._resizeTo && (this.cancelResize(), this._resizeId = requestAnimationFrame((() => this.resize())))
                        }, this.cancelResize = () => {
                            this._resizeId && (cancelAnimationFrame(this._resizeId), this._resizeId = null)
                        }, this.resize = () => {
                            if (!this._resizeTo) return;
                            let e, t;
                            if (this.cancelResize(), this._resizeTo === globalThis.window) e = globalThis.innerWidth, t = globalThis.innerHeight;
                            else {
                                const {
                                    clientWidth: r,
                                    clientHeight: i
                                } = this._resizeTo;
                                e = r, t = i
                            }
                            this.renderer.resize(e, t), this.render()
                        }, this._resizeId = null, this._resizeTo = null, this.resizeTo = e.resizeTo || null
                    }
                    static destroy() {
                        globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null
                    }
                }
                s.extension = i.ExtensionType.Application, i.extensions.add(s), t.ResizePlugin = s
            },
            8249: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(736),
                    s = r(3682);
                t.Application = i.Application, t.ResizePlugin = s.ResizePlugin
            },
            9673: (e, t, r) => {
                "use strict";
                var i = r(7163);
                const s = {
                    loader: i.ExtensionType.LoadParser,
                    resolver: i.ExtensionType.ResolveParser,
                    cache: i.ExtensionType.CacheParser,
                    detection: i.ExtensionType.DetectionParser
                };
                i.extensions.handle(i.ExtensionType.Asset, (e => {
                    const t = e.ref;
                    Object.entries(s).filter((([e]) => !!t[e])).forEach((([e, r]) => i.extensions.add(Object.assign(t[e], {
                        extension: t[e].extension ?? r
                    }))))
                }), (e => {
                    const t = e.ref;
                    Object.keys(s).filter((e => !!t[e])).forEach((e => i.extensions.remove(t[e])))
                }))
            },
            6990: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(6128),
                    n = r(7235),
                    o = r(9203),
                    a = r(4268);
                r(8683);
                var h = r(2658),
                    l = r(1044),
                    u = r(98),
                    c = r(4992);
                class d {
                    constructor() {
                        this._detections = [], this._initialized = !1, this.resolver = new h.Resolver, this.loader = new a.Loader, this.cache = o.Cache, this._backgroundLoader = new n.BackgroundLoader(this.loader), this._backgroundLoader.active = !0, this.reset()
                    }
                    async init(e = {}) {
                        if (this._initialized) return void console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
                        if (this._initialized = !0, e.defaultSearchParams && this.resolver.setDefaultSearchParams(e.defaultSearchParams), e.basePath && (this.resolver.basePath = e.basePath), e.bundleIdentifier && this.resolver.setBundleIdentifier(e.bundleIdentifier), e.manifest) {
                            let t = e.manifest;
                            "string" == typeof t && (t = await this.load(t)), this.resolver.addManifest(t)
                        }
                        const t = e.texturePreference?.resolution ?? 1,
                            r = "number" == typeof t ? [t] : t;
                        let i = [];
                        if (e.texturePreference?.format) {
                            const t = e.texturePreference?.format;
                            i = "string" == typeof t ? [t] : t;
                            for (const e of this._detections) await e.test() || (i = await e.remove(i))
                        } else
                            for (const e of this._detections) await e.test() && (i = await e.add(i));
                        this.resolver.prefer({
                            params: {
                                format: i,
                                resolution: r
                            }
                        }), e.preferences && this.setPreferences(e.preferences)
                    }
                    add(e, t, r) {
                        this.resolver.add(e, t, r)
                    }
                    async load(e, t) {
                        this._initialized || await this.init();
                        const r = u.isSingleItem(e),
                            i = l.convertToList(e).map((e => "string" != typeof e ? (this.resolver.add(e.src, e), e.src) : (this.resolver.hasKey(e) || this.resolver.add(e, e), e))),
                            s = this.resolver.resolve(i),
                            n = await this._mapLoadToResolve(s, t);
                        return r ? n[i[0]] : n
                    }
                    addBundle(e, t) {
                        this.resolver.addBundle(e, t)
                    }
                    async loadBundle(e, t) {
                        this._initialized || await this.init();
                        let r = !1;
                        "string" == typeof e && (r = !0, e = [e]);
                        const i = this.resolver.resolveBundle(e),
                            s = {},
                            n = Object.keys(i);
                        let o = 0,
                            a = 0;
                        const h = () => {
                                t?.(++o / a)
                            },
                            l = n.map((e => {
                                const t = i[e];
                                return a += Object.keys(t).length, this._mapLoadToResolve(t, h).then((t => {
                                    s[e] = t
                                }))
                            }));
                        return await Promise.all(l), r ? s[e[0]] : s
                    }
                    async backgroundLoad(e) {
                        this._initialized || await this.init(), "string" == typeof e && (e = [e]);
                        const t = this.resolver.resolve(e);
                        this._backgroundLoader.add(Object.values(t))
                    }
                    async backgroundLoadBundle(e) {
                        this._initialized || await this.init(), "string" == typeof e && (e = [e]);
                        const t = this.resolver.resolveBundle(e);
                        Object.values(t).forEach((e => {
                            this._backgroundLoader.add(Object.values(e))
                        }))
                    }
                    reset() {
                        this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = !1
                    }
                    get(e) {
                        if ("string" == typeof e) return o.Cache.get(e);
                        const t = {};
                        for (let r = 0; r < e.length; r++) t[r] = o.Cache.get(e[r]);
                        return t
                    }
                    async _mapLoadToResolve(e, t) {
                        const r = Object.values(e),
                            i = Object.keys(e);
                        this._backgroundLoader.active = !1;
                        const s = await this.loader.load(r, t);
                        this._backgroundLoader.active = !0;
                        const n = {};
                        return r.forEach(((e, t) => {
                            const r = s[e.src],
                                a = [e.src];
                            e.alias && a.push(...e.alias), n[i[t]] = r, o.Cache.set(a, r)
                        })), n
                    }
                    async unload(e) {
                        this._initialized || await this.init();
                        const t = l.convertToList(e).map((e => "string" != typeof e ? e.src : e)),
                            r = this.resolver.resolve(t);
                        await this._unloadFromResolved(r)
                    }
                    async unloadBundle(e) {
                        this._initialized || await this.init(), e = l.convertToList(e);
                        const t = this.resolver.resolveBundle(e),
                            r = Object.keys(t).map((e => this._unloadFromResolved(t[e])));
                        await Promise.all(r)
                    }
                    async _unloadFromResolved(e) {
                        const t = Object.values(e);
                        t.forEach((e => {
                            o.Cache.remove(e.src)
                        })), await this.loader.unload(t)
                    }
                    get detections() {
                        return this._detections
                    }
                    get preferWorkers() {
                        return c.loadTextures.config.preferWorkers
                    }
                    set preferWorkers(e) {
                        s.deprecation("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead."), this.setPreferences({
                            preferWorkers: e
                        })
                    }
                    setPreferences(e) {
                        this.loader.parsers.forEach((t => {
                            t.config && Object.keys(t.config).filter((t => t in e)).forEach((r => {
                                t.config[r] = e[r]
                            }))
                        }))
                    }
                }
                const p = new d;
                i.extensions.handleByList(i.ExtensionType.LoadParser, p.loader.parsers).handleByList(i.ExtensionType.ResolveParser, p.resolver.parsers).handleByList(i.ExtensionType.CacheParser, p.cache.parsers).handleByList(i.ExtensionType.DetectionParser, p.detections), t.Assets = p, t.AssetsClass = d
            },
            7235: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.BackgroundLoader = class {
                    constructor(e, t = !1) {
                        this._loader = e, this._assetList = [], this._isLoading = !1, this._maxConcurrent = 1, this.verbose = t
                    }
                    add(e) {
                        e.forEach((e => {
                            this._assetList.push(e)
                        })), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next()
                    }
                    async _next() {
                        if (this._assetList.length && this._isActive) {
                            this._isLoading = !0;
                            const e = [],
                                t = Math.min(this._assetList.length, this._maxConcurrent);
                            for (let r = 0; r < t; r++) e.push(this._assetList.pop());
                            await this._loader.load(e), this._isLoading = !1, this._next()
                        }
                    }
                    get active() {
                        return this._isActive
                    }
                    set active(e) {
                        this._isActive !== e && (this._isActive = e, e && !this._isLoading && this._next())
                    }
                }
            },
            9203: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                r(8736);
                var s = r(1044);
                const n = new class {
                    constructor() {
                        this._parsers = [], this._cache = new Map, this._cacheMap = new Map
                    }
                    reset() {
                        this._cacheMap.clear(), this._cache.clear()
                    }
                    has(e) {
                        return this._cache.has(e)
                    }
                    get(e) {
                        const t = this._cache.get(e);
                        return t || console.warn(`[Assets] Asset id ${e} was not found in the Cache`), t
                    }
                    set(e, t) {
                        const r = s.convertToList(e);
                        let n;
                        for (let e = 0; e < this.parsers.length; e++) {
                            const i = this.parsers[e];
                            if (i.test(t)) {
                                n = i.getCacheableAssets(r, t);
                                break
                            }
                        }
                        n || (n = {}, r.forEach((e => {
                            n[e] = t
                        })));
                        const o = Object.keys(n),
                            a = {
                                cacheKeys: o,
                                keys: r
                            };
                        if (r.forEach((e => {
                                this._cacheMap.set(e, a)
                            })), o.forEach((e => {
                                this._cache.has(e) && this._cache.get(e) !== t && console.warn("[Cache] already has key:", e), this._cache.set(e, n[e])
                            })), t instanceof i.Texture) {
                            const e = t;
                            r.forEach((t => {
                                e.baseTexture !== i.Texture.EMPTY.baseTexture && i.BaseTexture.addToCache(e.baseTexture, t), i.Texture.addToCache(e, t)
                            }))
                        }
                    }
                    remove(e) {
                        if (this._cacheMap.get(e), !this._cacheMap.has(e)) return void console.warn(`[Assets] Asset id ${e} was not found in the Cache`);
                        const t = this._cacheMap.get(e);
                        t.cacheKeys.forEach((e => {
                            this._cache.delete(e)
                        })), t.keys.forEach((e => {
                            this._cacheMap.delete(e)
                        }))
                    }
                    get parsers() {
                        return this._parsers
                    }
                };
                t.Cache = n
            },
            4712: () => {},
            9059: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(9203);
                r(4712), r(3557), t.Cache = i.Cache
            },
            9392: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                const s = {
                    extension: i.ExtensionType.CacheParser,
                    test: e => Array.isArray(e) && e.every((e => e instanceof i.Texture)),
                    getCacheableAssets: (e, t) => {
                        const r = {};
                        return e.forEach((e => {
                            t.forEach(((t, i) => {
                                r[e + (0 === i ? "" : i + 1)] = t
                            }))
                        })), r
                    }
                };
                i.extensions.add(s), t.cacheTextureArray = s
            },
            3557: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(9392);
                t.cacheTextureArray = i.cacheTextureArray
            },
            6932: (e, t, r) => {
                "use strict";
                r(5130)
            },
            5838: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                const s = {
                    extension: {
                        type: i.ExtensionType.DetectionParser,
                        priority: 1
                    },
                    test: async () => {
                        if (!globalThis.createImageBitmap) return !1;
                        const e = await i.settings.ADAPTER.fetch("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=").then((e => e.blob()));
                        return createImageBitmap(e).then((() => !0), (() => !1))
                    },
                    add: async e => [...e, "avif"],
                    remove: async e => e.filter((e => "avif" !== e))
                };
                i.extensions.add(s), t.detectAvif = s
            },
            9464: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                const s = ["png", "jpg", "jpeg"],
                    n = {
                        extension: {
                            type: i.ExtensionType.DetectionParser,
                            priority: -1
                        },
                        test: () => Promise.resolve(!0),
                        add: async e => [...e, ...s],
                        remove: async e => e.filter((e => !s.includes(e)))
                    };
                i.extensions.add(n), t.detectDefaults = n
            },
            6629: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                const s = {
                    extension: {
                        type: i.ExtensionType.DetectionParser,
                        priority: 0
                    },
                    test: async () => {
                        if (!globalThis.createImageBitmap) return !1;
                        const e = await i.settings.ADAPTER.fetch("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=").then((e => e.blob()));
                        return createImageBitmap(e).then((() => !0), (() => !1))
                    },
                    add: async e => [...e, "webp"],
                    remove: async e => e.filter((e => "webp" !== e))
                };
                i.extensions.add(s), t.detectWebp = s
            },
            5130: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(5838),
                    s = r(6629),
                    n = r(9464);
                t.detectAvif = i.detectAvif, t.detectWebp = s.detectWebp, t.detectDefaults = n.detectDefaults
            },
            4645: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), r(9673);
                var i = r(6990);
                r(9059), r(6932), r(4006), r(3135), r(8736);
                var s = r(9203),
                    n = r(9392),
                    o = r(5838),
                    a = r(6629),
                    h = r(9464),
                    l = r(7479),
                    u = r(1499),
                    c = r(3045),
                    d = r(517),
                    p = r(3504),
                    f = r(4992),
                    m = r(8037),
                    g = r(2114),
                    y = r(762),
                    _ = r(4146),
                    v = r(1044),
                    S = r(4497),
                    T = r(4624),
                    b = r(98);
                t.Assets = i.Assets, t.AssetsClass = i.AssetsClass, t.Cache = s.Cache, t.cacheTextureArray = n.cacheTextureArray, t.detectAvif = o.detectAvif, t.detectWebp = a.detectWebp, t.detectDefaults = h.detectDefaults, t.LoaderParserPriority = l.LoaderParserPriority, t.loadJson = u.loadJson, t.loadTxt = c.loadTxt, t.getFontFamilyName = d.getFontFamilyName, t.loadWebFont = d.loadWebFont, t.loadSVG = p.loadSVG, t.loadImageBitmap = f.loadImageBitmap, t.loadTextures = f.loadTextures, t.createTexture = m.createTexture, t.resolveTextureUrl = g.resolveTextureUrl, t.checkDataUrl = y.checkDataUrl, t.checkExtension = _.checkExtension, t.convertToList = v.convertToList, t.copySearchParams = S.copySearchParams, t.createStringVariations = T.createStringVariations, t.isSingleItem = b.isSingleItem
            },
            4268: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                r(8736);
                var s = r(98),
                    n = r(1044);
                t.Loader = class {
                    constructor() {
                        this._parsers = [], this._parsersValidated = !1, this.parsers = new Proxy(this._parsers, {
                            set: (e, t, r) => (this._parsersValidated = !1, e[t] = r, !0)
                        }), this.promiseCache = {}
                    }
                    reset() {
                        this._parsersValidated = !1, this.promiseCache = {}
                    }
                    _getLoadPromiseAndParser(e, t) {
                        const r = {
                            promise: null,
                            parser: null
                        };
                        return r.promise = (async () => {
                            let i = null,
                                s = null;
                            if (t.loadParser && (s = this._parserHash[t.loadParser], s || console.warn(`[Assets] specified load parser "${t.loadParser}" not found while loading ${e}`)), !s) {
                                for (let r = 0; r < this.parsers.length; r++) {
                                    const i = this.parsers[r];
                                    if (i.load && i.test?.(e, t, this)) {
                                        s = i;
                                        break
                                    }
                                }
                                if (!s) return console.warn(`[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null
                            }
                            i = await s.load(e, t, this), r.parser = s;
                            for (let e = 0; e < this.parsers.length; e++) {
                                const s = this.parsers[e];
                                s.parse && s.parse && await (s.testParse?.(i, t, this)) && (i = await s.parse(i, t, this) || i, r.parser = s)
                            }
                            return i
                        })(), r
                    }
                    async load(e, t) {
                        this._parsersValidated || this._validateParsers();
                        let r = 0;
                        const o = {},
                            a = s.isSingleItem(e),
                            h = n.convertToList(e, (e => ({
                                src: e
                            }))),
                            l = h.length,
                            u = h.map((async e => {
                                const s = i.utils.path.toAbsolute(e.src);
                                if (!o[e.src]) try {
                                    this.promiseCache[s] || (this.promiseCache[s] = this._getLoadPromiseAndParser(s, e)), o[e.src] = await this.promiseCache[s].promise, t && t(++r / l)
                                } catch (t) {
                                    throw delete this.promiseCache[s], delete o[e.src], new Error(`[Loader.load] Failed to load ${s}.\n${t}`)
                                }
                            }));
                        return await Promise.all(u), a ? o[h[0].src] : o
                    }
                    async unload(e) {
                        const t = n.convertToList(e, (e => ({
                            src: e
                        }))).map((async e => {
                            const t = i.utils.path.toAbsolute(e.src),
                                r = this.promiseCache[t];
                            if (r) {
                                const i = await r.promise;
                                r.parser?.unload?.(i, e, this), delete this.promiseCache[t]
                            }
                        }));
                        await Promise.all(t)
                    }
                    _validateParsers() {
                        this._parsersValidated = !0, this._parserHash = this._parsers.filter((e => e.name)).reduce(((e, t) => (e[t.name] && console.warn(`[Assets] loadParser name conflict "${t.name}"`), {
                            ...e,
                            [t.name]: t
                        })), {})
                    }
                }
            },
            4006: (e, t, r) => {
                "use strict";
                r(8683), r(942)
            },
            7479: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = (e => (e[e.Low = 0] = "Low", e[e.Normal = 1] = "Normal", e[e.High = 2] = "High", e))(r || {});
                t.LoaderParserPriority = r
            },
            8389: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                let r, i = 0;
                const s = "\n    async function checkImageBitmap()\n    {\n        try\n        {\n            if (typeof createImageBitmap !== 'function') return false;\n\n            const response = await fetch('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=');\n            const imageBlob =  await response.blob();\n            const imageBitmap = await createImageBitmap(imageBlob);\n\n            return imageBitmap.width === 1 && imageBitmap.height === 1;\n        }\n        catch (e)\n        {\n            return false;\n        }\n    }\n    checkImageBitmap().then((result) => { self.postMessage(result); });\n    ",
                    n = "\n    async function loadImageBitmap(url)\n    {\n        const response = await fetch(url);\n\n        if (!response.ok)\n        {\n            throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: `\n                + `${response.status} ${response.statusText}`);\n        }\n\n        const imageBlob =  await response.blob();\n        const imageBitmap = await createImageBitmap(imageBlob);\n\n        return imageBitmap;\n    }\n    self.onmessage = async (event) =>\n    {\n        try\n        {\n            const imageBitmap = await loadImageBitmap(event.data.data[0]);\n\n            self.postMessage({\n                data: imageBitmap,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            }, [imageBitmap]);\n        }\n        catch(e)\n        {\n            self.postMessage({\n                error: e,\n                uuid: event.data.uuid,\n                id: event.data.id,\n            });\n        }\n    };";
                let o;
                const a = new class {
                    constructor() {
                        this._initialized = !1, this._createdWorkers = 0, this.workerPool = [], this.queue = [], this.resolveHash = {}
                    }
                    isImageBitmapSupported() {
                        return void 0 !== this._isImageBitmapSupported || (this._isImageBitmapSupported = new Promise((e => {
                            const t = URL.createObjectURL(new Blob([s], {
                                    type: "application/javascript"
                                })),
                                r = new Worker(t);
                            r.addEventListener("message", (i => {
                                r.terminate(), URL.revokeObjectURL(t), e(i.data)
                            }))
                        }))), this._isImageBitmapSupported
                    }
                    loadImageBitmap(e) {
                        return this._run("loadImageBitmap", [e])
                    }
                    async _initWorkers() {
                        this._initialized || (this._initialized = !0)
                    }
                    getWorker() {
                        void 0 === r && (r = navigator.hardwareConcurrency || 4);
                        let e = this.workerPool.pop();
                        return !e && this._createdWorkers < r && (o || (o = URL.createObjectURL(new Blob([n], {
                            type: "application/javascript"
                        }))), this._createdWorkers++, e = new Worker(o), e.addEventListener("message", (e => {
                            this.complete(e.data), this.returnWorker(e.target), this.next()
                        }))), e
                    }
                    returnWorker(e) {
                        this.workerPool.push(e)
                    }
                    complete(e) {
                        void 0 !== e.error ? this.resolveHash[e.uuid].reject(e.error) : this.resolveHash[e.uuid].resolve(e.data), this.resolveHash[e.uuid] = null
                    }
                    async _run(e, t) {
                        await this._initWorkers();
                        const r = new Promise(((r, i) => {
                            this.queue.push({
                                id: e,
                                arguments: t,
                                resolve: r,
                                reject: i
                            })
                        }));
                        return this.next(), r
                    }
                    next() {
                        if (!this.queue.length) return;
                        const e = this.getWorker();
                        if (!e) return;
                        const t = this.queue.pop(),
                            r = t.id;
                        this.resolveHash[i] = {
                            resolve: t.resolve,
                            reject: t.reject
                        }, e.postMessage({
                            data: t.arguments,
                            uuid: i++,
                            id: r
                        })
                    }
                };
                t.WorkerManager = a
            },
            8683: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7479),
                    s = r(1499),
                    n = r(3045),
                    o = r(517);
                r(2524), t.LoaderParserPriority = i.LoaderParserPriority, t.loadJson = s.loadJson, t.loadTxt = n.loadTxt, t.getFontFamilyName = o.getFontFamilyName, t.loadWebFont = o.loadWebFont
            },
            1499: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(762),
                    n = r(4146),
                    o = r(7479);
                const a = {
                    extension: {
                        type: i.ExtensionType.LoadParser,
                        priority: o.LoaderParserPriority.Low
                    },
                    name: "loadJson",
                    test: e => s.checkDataUrl(e, "application/json") || n.checkExtension(e, ".json"),
                    async load(e) {
                        const t = await i.settings.ADAPTER.fetch(e);
                        return await t.json()
                    }
                };
                i.extensions.add(a), t.loadJson = a
            },
            3045: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(762),
                    n = r(4146),
                    o = r(7479);
                const a = {
                    name: "loadTxt",
                    extension: {
                        type: i.ExtensionType.LoadParser,
                        priority: o.LoaderParserPriority.Low
                    },
                    test: e => s.checkDataUrl(e, "text/plain") || n.checkExtension(e, ".txt"),
                    async load(e) {
                        const t = await i.settings.ADAPTER.fetch(e);
                        return await t.text()
                    }
                };
                i.extensions.add(a), t.loadTxt = a
            },
            517: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(762),
                    n = r(4146),
                    o = r(7479);
                const a = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"],
                    h = [".ttf", ".otf", ".woff", ".woff2"],
                    l = ["font/ttf", "font/otf", "font/woff", "font/woff2"];

                function u(e) {
                    const t = i.utils.path.extname(e);
                    return i.utils.path.basename(e, t).replace(/(-|_)/g, " ").toLowerCase().split(" ").map((e => e.charAt(0).toUpperCase() + e.slice(1))).join(" ")
                }
                const c = {
                    extension: {
                        type: i.ExtensionType.LoadParser,
                        priority: o.LoaderParserPriority.Low
                    },
                    name: "loadWebFont",
                    test: e => s.checkDataUrl(e, l) || n.checkExtension(e, h),
                    async load(e, t) {
                        const r = i.settings.ADAPTER.getFontFaceSet();
                        if (r) {
                            const i = [],
                                s = t.data?.family ?? u(e),
                                n = t.data?.weights?.filter((e => a.includes(e))) ?? ["normal"],
                                o = t.data ?? {};
                            for (let t = 0; t < n.length; t++) {
                                const a = n[t],
                                    h = new FontFace(s, `url(${encodeURI(e)})`, {
                                        ...o,
                                        weight: a
                                    });
                                await h.load(), r.add(h), i.push(h)
                            }
                            return 1 === i.length ? i[0] : i
                        }
                        return console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font"), null
                    },
                    unload(e) {
                        (Array.isArray(e) ? e : [e]).forEach((e => i.settings.ADAPTER.getFontFaceSet().delete(e)))
                    }
                };
                i.extensions.add(c), t.getFontFamilyName = u, t.loadWebFont = c
            },
            2524: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(3504),
                    s = r(4992);
                r(9091), t.loadSVG = i.loadSVG, t.loadImageBitmap = s.loadImageBitmap, t.loadTextures = s.loadTextures
            },
            3504: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(762),
                    n = r(4146),
                    o = r(7479),
                    a = r(4992),
                    h = r(8037);
                const l = {
                    extension: {
                        type: i.ExtensionType.LoadParser,
                        priority: o.LoaderParserPriority.High
                    },
                    name: "loadSVG",
                    test: e => s.checkDataUrl(e, "image/svg+xml") || n.checkExtension(e, ".svg"),
                    testParse: async e => i.SVGResource.test(e),
                    async parse(e, t, r) {
                        const s = new i.SVGResource(e, t?.data?.resourceOptions),
                            n = new i.BaseTexture(s, {
                                resolution: i.utils.getResolutionOfUrl(e),
                                ...t?.data
                            });
                        n.resource.src = e;
                        const o = h.createTexture(n, r, e);
                        return t?.data?.resourceOptions?.autoLoad || await s.load(), o
                    },
                    load: async (e, t) => (await i.settings.ADAPTER.fetch(e)).text(),
                    unload: a.loadTextures.unload
                };
                i.extensions.add(l), t.loadSVG = l
            },
            4992: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(762),
                    n = r(4146),
                    o = r(7479),
                    a = r(8389),
                    h = r(8037);
                const l = [".jpeg", ".jpg", ".png", ".webp", ".avif"],
                    u = ["image/jpeg", "image/png", "image/webp", "image/avif"];
                async function c(e) {
                    const t = await i.settings.ADAPTER.fetch(e);
                    if (!t.ok) throw new Error(`[loadImageBitmap] Failed to fetch ${e}: ${t.status} ${t.statusText}`);
                    const r = await t.blob();
                    return await createImageBitmap(r)
                }
                const d = {
                    name: "loadTextures",
                    extension: {
                        type: i.ExtensionType.LoadParser,
                        priority: o.LoaderParserPriority.High
                    },
                    config: {
                        preferWorkers: !0,
                        preferCreateImageBitmap: !0,
                        crossOrigin: "anonymous"
                    },
                    test: e => s.checkDataUrl(e, u) || n.checkExtension(e, l),
                    async load(e, t, r) {
                        let s = null;
                        s = globalThis.createImageBitmap && this.config.preferCreateImageBitmap ? this.config.preferWorkers && await a.WorkerManager.isImageBitmapSupported() ? await a.WorkerManager.loadImageBitmap(e) : await c(e) : await new Promise((t => {
                            s = new Image, s.crossOrigin = this.config.crossOrigin, s.src = e, s.complete ? t(s) : s.onload = () => {
                                t(s)
                            }
                        }));
                        const n = new i.BaseTexture(s, {
                            resolution: i.utils.getResolutionOfUrl(e),
                            ...t.data
                        });
                        return n.resource.src = e, h.createTexture(n, r, e)
                    },
                    unload(e) {
                        e.destroy(!0)
                    }
                };
                i.extensions.add(d), t.loadImageBitmap = c, t.loadTextures = d
            },
            8037: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                t.createTexture = function(e, t, r) {
                    const s = new i.Texture(e);
                    return s.baseTexture.on("dispose", (() => {
                        delete t.promiseCache[r]
                    })), s
                }
            },
            9091: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(8037);
                t.createTexture = i.createTexture
            },
            942: () => {},
            2658: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(1044),
                    n = r(4624),
                    o = r(98);
                t.Resolver = class {
                    constructor() {
                        this._defaultBundleIdentifierOptions = {
                            connector: "-",
                            createBundleAssetId: (e, t) => `${e}${this._bundleIdConnector}${t}`,
                            extractAssetIdFromBundle: (e, t) => t.replace(`${e}${this._bundleIdConnector}`, "")
                        }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {}
                    }
                    setBundleIdentifier(e) {
                        if (this._bundleIdConnector = e.connector ?? this._bundleIdConnector, this._createBundleAssetId = e.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = e.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, "bar" !== this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar"))) throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")
                    }
                    prefer(...e) {
                        e.forEach((e => {
                            this._preferredOrder.push(e), e.priority || (e.priority = Object.keys(e.params))
                        })), this._resolverHash = {}
                    }
                    set basePath(e) {
                        this._basePath = e
                    }
                    get basePath() {
                        return this._basePath
                    }
                    set rootPath(e) {
                        this._rootPath = e
                    }
                    get rootPath() {
                        return this._rootPath
                    }
                    get parsers() {
                        return this._parsers
                    }
                    reset() {
                        this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null
                    }
                    setDefaultSearchParams(e) {
                        if ("string" == typeof e) this._defaultSearchParams = e;
                        else {
                            const t = e;
                            this._defaultSearchParams = Object.keys(t).map((e => `${encodeURIComponent(e)}=${encodeURIComponent(t[e])}`)).join("&")
                        }
                    }
                    addManifest(e) {
                        this._manifest && console.warn("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = e, e.bundles.forEach((e => {
                            this.addBundle(e.name, e.assets)
                        }))
                    }
                    addBundle(e, t) {
                        const r = [];
                        Array.isArray(t) ? t.forEach((t => {
                            if ("string" == typeof t.name) {
                                const i = this._createBundleAssetId(e, t.name);
                                r.push(i), this.add([t.name, i], t.srcs, t.data)
                            } else {
                                const i = t.name.map((t => this._createBundleAssetId(e, t)));
                                i.forEach((e => {
                                    r.push(e)
                                })), this.add([...t.name, ...i], t.srcs)
                            }
                        })) : Object.keys(t).forEach((i => {
                            r.push(this._createBundleAssetId(e, i)), this.add([i, this._createBundleAssetId(e, i)], t[i])
                        })), this._bundles[e] = r
                    }
                    add(e, t, r) {
                        const o = s.convertToList(e);
                        o.forEach((e => {
                            this.hasKey(e) && console.warn(`[Resolver] already has key: ${e} overwriting`)
                        })), Array.isArray(t) || (t = "string" == typeof t ? n.createStringVariations(t) : [t]);
                        const a = t.map((e => {
                            let t = e;
                            if ("string" == typeof e) {
                                let r = !1;
                                for (let i = 0; i < this._parsers.length; i++) {
                                    const s = this._parsers[i];
                                    if (s.test(e)) {
                                        t = s.parse(e), r = !0;
                                        break
                                    }
                                }
                                r || (t = {
                                    src: e
                                })
                            }
                            return t.format || (t.format = t.src.split(".").pop()), t.alias || (t.alias = o), (this._basePath || this._rootPath) && (t.src = i.utils.path.toAbsolute(t.src, this._basePath, this._rootPath)), t.src = this._appendDefaultSearchParams(t.src), t.data = t.data ?? r, t
                        }));
                        o.forEach((e => {
                            this._assetMap[e] = a
                        }))
                    }
                    resolveBundle(e) {
                        const t = o.isSingleItem(e);
                        e = s.convertToList(e);
                        const r = {};
                        return e.forEach((e => {
                            const t = this._bundles[e];
                            if (t) {
                                const i = this.resolve(t),
                                    s = {};
                                for (const t in i) {
                                    const r = i[t];
                                    s[this._extractAssetIdFromBundle(e, t)] = r
                                }
                                r[e] = s
                            }
                        })), t ? r[e[0]] : r
                    }
                    resolveUrl(e) {
                        const t = this.resolve(e);
                        if ("string" != typeof e) {
                            const e = {};
                            for (const r in t) e[r] = t[r].src;
                            return e
                        }
                        return t.src
                    }
                    resolve(e) {
                        const t = o.isSingleItem(e);
                        e = s.convertToList(e);
                        const r = {};
                        return e.forEach((e => {
                            if (!this._resolverHash[e])
                                if (this._assetMap[e]) {
                                    let t = this._assetMap[e];
                                    const r = this._getPreferredOrder(t),
                                        i = t[0];
                                    r?.priority.forEach((e => {
                                        r.params[e].forEach((r => {
                                            const i = t.filter((t => !!t[e] && t[e] === r));
                                            i.length && (t = i)
                                        }))
                                    })), this._resolverHash[e] = t[0] ?? i
                                } else {
                                    let t = e;
                                    (this._basePath || this._rootPath) && (t = i.utils.path.toAbsolute(t, this._basePath, this._rootPath)), t = this._appendDefaultSearchParams(t), this._resolverHash[e] = {
                                        src: t
                                    }
                                } r[e] = this._resolverHash[e]
                        })), t ? r[e[0]] : r
                    }
                    hasKey(e) {
                        return !!this._assetMap[e]
                    }
                    hasBundle(e) {
                        return !!this._bundles[e]
                    }
                    _getPreferredOrder(e) {
                        for (let t = 0; t < e.length; t++) {
                            const t = e[0],
                                r = this._preferredOrder.find((e => e.params.format.includes(t.format)));
                            if (r) return r
                        }
                        return this._preferredOrder[0]
                    }
                    _appendDefaultSearchParams(e) {
                        return this._defaultSearchParams ? `${e}${/\?/.test(e)?"&":"?"}${this._defaultSearchParams}` : e
                    }
                }
            },
            3135: (e, t, r) => {
                "use strict";
                r(8987), r(5449)
            },
            8987: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2114);
                t.resolveTextureUrl = i.resolveTextureUrl
            },
            2114: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                r(4006);
                var s = r(4992);
                const n = {
                    extension: i.ExtensionType.ResolveParser,
                    test: s.loadTextures.test,
                    parse: e => ({
                        resolution: parseFloat(i.settings.RETINA_PREFIX.exec(e)?.[1] ?? "1"),
                        format: e.split(".").pop(),
                        src: e
                    })
                };
                i.extensions.add(n), t.resolveTextureUrl = n
            },
            5449: () => {},
            762: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.checkDataUrl = function(e, t) {
                    if (Array.isArray(t)) {
                        for (const r of t)
                            if (e.startsWith(`data:${r}`)) return !0;
                        return !1
                    }
                    return e.startsWith(`data:${t}`)
                }
            },
            4146: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                t.checkExtension = function(e, t) {
                    const r = e.split("?")[0],
                        s = i.utils.path.extname(r).toLowerCase();
                    return Array.isArray(t) ? t.includes(s) : s === t
                }
            },
            1044: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.convertToList = (e, t) => (Array.isArray(e) || (e = [e]), t ? e.map((e => "string" == typeof e ? t(e) : e)) : e)
            },
            4497: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.copySearchParams = (e, t) => {
                    const r = t.split("?")[1];
                    return r && (e += `?${r}`), e
                }
            },
            4624: (e, t) => {
                "use strict";

                function r(e, t, i, s, n) {
                    const o = t[i];
                    for (let a = 0; a < o.length; a++) {
                        const h = o[a];
                        i < t.length - 1 ? r(e.replace(s[i], h), t, i + 1, s, n) : n.push(e.replace(s[i], h))
                    }
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.createStringVariations = function(e) {
                    const t = e.match(/\{(.*?)\}/g),
                        i = [];
                    if (t) {
                        const s = [];
                        t.forEach((e => {
                            const t = e.substring(1, e.length - 1).split(",");
                            s.push(t)
                        })), r(e, s, 0, t, i)
                    } else i.push(e);
                    return i
                }
            },
            8736: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(762),
                    s = r(4146),
                    n = r(1044),
                    o = r(4497),
                    a = r(4624),
                    h = r(98);
                t.checkDataUrl = i.checkDataUrl, t.checkExtension = s.checkExtension, t.convertToList = n.convertToList, t.copySearchParams = o.copySearchParams, t.createStringVariations = a.createStringVariations, t.isSingleItem = h.isSingleItem
            },
            98: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isSingleItem = e => !Array.isArray(e)
            },
            8789: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(6872);

                function s(e) {
                    return e && "object" == typeof e && "default" in e ? e : {
                        default: e
                    }
                }
                var n = s(r(2121));
                i.extend([n.default]);
                const o = class {
                    constructor(e = 16777215) {
                        this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = e
                    }
                    get red() {
                        return this._components[0]
                    }
                    get green() {
                        return this._components[1]
                    }
                    get blue() {
                        return this._components[2]
                    }
                    get alpha() {
                        return this._components[3]
                    }
                    setValue(e) {
                        return this.value = e, this
                    }
                    set value(e) {
                        if (e instanceof o) this._value = this.cloneSource(e._value), this._int = e._int, this._components.set(e._components);
                        else {
                            if (null === e) throw new Error("Cannot set PIXI.Color#value to null");
                            null !== this._value && this.isSourceEqual(this._value, e) || (this.normalize(e), this._value = this.cloneSource(e))
                        }
                    }
                    get value() {
                        return this._value
                    }
                    cloneSource(e) {
                        return "string" == typeof e || "number" == typeof e || e instanceof Number || null === e ? e : Array.isArray(e) || ArrayBuffer.isView(e) ? e.slice(0) : "object" == typeof e && null !== e ? {
                            ...e
                        } : e
                    }
                    isSourceEqual(e, t) {
                        const r = typeof e;
                        if (r !== typeof t) return !1;
                        if ("number" === r || "string" === r || e instanceof Number) return e === t;
                        if (Array.isArray(e) && Array.isArray(t) || ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) return e.length === t.length && e.every(((e, r) => e === t[r]));
                        if (null !== e && null !== t) {
                            const r = Object.keys(e),
                                i = Object.keys(t);
                            return r.length === i.length && r.every((r => e[r] === t[r]))
                        }
                        return e === t
                    }
                    toRgba() {
                        const [e, t, r, i] = this._components;
                        return {
                            r: e,
                            g: t,
                            b: r,
                            a: i
                        }
                    }
                    toRgb() {
                        const [e, t, r] = this._components;
                        return {
                            r: e,
                            g: t,
                            b: r
                        }
                    }
                    toRgbaString() {
                        const [e, t, r] = this.toUint8RgbArray();
                        return `rgba(${e},${t},${r},${this.alpha})`
                    }
                    toUint8RgbArray(e) {
                        const [t, r, i] = this._components;
                        return (e = e ?? [])[0] = Math.round(255 * t), e[1] = Math.round(255 * r), e[2] = Math.round(255 * i), e
                    }
                    toRgbArray(e) {
                        e = e ?? [];
                        const [t, r, i] = this._components;
                        return e[0] = t, e[1] = r, e[2] = i, e
                    }
                    toNumber() {
                        return this._int
                    }
                    toLittleEndianNumber() {
                        const e = this._int;
                        return (e >> 16) + (65280 & e) + ((255 & e) << 16)
                    }
                    multiply(e) {
                        const [t, r, i, s] = o.temp.setValue(e)._components;
                        return this._components[0] *= t, this._components[1] *= r, this._components[2] *= i, this._components[3] *= s, this.refreshInt(), this._value = null, this
                    }
                    premultiply(e, t = !0) {
                        return t && (this._components[0] *= e, this._components[1] *= e, this._components[2] *= e), this._components[3] = e, this.refreshInt(), this._value = null, this
                    }
                    toPremultiplied(e) {
                        if (1 === e) return (255 * e << 24) + this._int;
                        if (0 === e) return 0;
                        let t = this._int >> 16 & 255,
                            r = this._int >> 8 & 255,
                            i = 255 & this._int;
                        return t = t * e + .5 | 0, r = r * e + .5 | 0, i = i * e + .5 | 0, (255 * e << 24) + (t << 16) + (r << 8) + i
                    }
                    toHex() {
                        const e = this._int.toString(16);
                        return `#${"000000".substring(0,6-e.length)+e}`
                    }
                    toHexa() {
                        const e = Math.round(255 * this._components[3]).toString(16);
                        return this.toHex() + "00".substring(0, 2 - e.length) + e
                    }
                    setAlpha(e) {
                        return this._components[3] = this._clamp(e), this
                    }
                    round(e) {
                        const [t, r, i] = this._components;
                        return this._components[0] = Math.round(t * e) / e, this._components[1] = Math.round(r * e) / e, this._components[2] = Math.round(i * e) / e, this.refreshInt(), this._value = null, this
                    }
                    toArray(e) {
                        e = e ?? [];
                        const [t, r, i, s] = this._components;
                        return e[0] = t, e[1] = r, e[2] = i, e[3] = s, e
                    }
                    normalize(e) {
                        let t;
                        if (("number" == typeof e || e instanceof Number) && e >= 0 && e <= 16777215) t = [(e >> 16 & 255) / 255, (e >> 8 & 255) / 255, (255 & e) / 255, 1];
                        else if ((Array.isArray(e) || e instanceof Float32Array) && e.length >= 3 && e.length <= 4) {
                            e = this._clamp(e);
                            const [r, i, s, n = 1] = e;
                            t = [r, i, s, n]
                        } else if ((e instanceof Uint8Array || e instanceof Uint8ClampedArray) && e.length >= 3 && e.length <= 4) {
                            e = this._clamp(e, 0, 255);
                            const [r, i, s, n = 255] = e;
                            t = [r / 255, i / 255, s / 255, n / 255]
                        } else if ("string" == typeof e || "object" == typeof e) {
                            if ("string" == typeof e) {
                                const t = o.HEX_PATTERN.exec(e);
                                t && (e = `#${t[2]}`)
                            }
                            const r = i.colord(e);
                            if (r.isValid()) {
                                const {
                                    r: e,
                                    g: i,
                                    b: s,
                                    a: n
                                } = r.rgba;
                                t = [e / 255, i / 255, s / 255, n]
                            }
                        }
                        if (!t) throw new Error(`Unable to convert color ${e}`);
                        this._components.set(t), this.refreshInt()
                    }
                    refreshInt() {
                        this._clamp(this._components);
                        const [e, t, r] = this._components;
                        this._int = (255 * e << 16) + (255 * t << 8) + (255 * r | 0)
                    }
                    _clamp(e, t = 0, r = 1) {
                        return "number" == typeof e ? Math.min(Math.max(e, t), r) : (e.forEach(((i, s) => {
                            e[s] = Math.min(Math.max(i, t), r)
                        })), e)
                    }
                };
                let a = o;
                a.shared = new o, a.temp = new o, a.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i, t.Color = a
            },
            2264: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(8789);
                t.Color = i.Color
            },
            632: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = (e => (e[e.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", e[e.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", e[e.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", e[e.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", e[e.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", e[e.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", e[e.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", e[e.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", e[e.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", e[e.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", e[e.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", e[e.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", e[e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", e[e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", e[e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", e[e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", e[e.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", e[e.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", e[e.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", e[e.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", e[e.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", e))(r || {});
                t.INTERNAL_FORMATS = r, t.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = {
                    33776: .5,
                    33777: .5,
                    33778: 1,
                    33779: 1,
                    35916: .5,
                    35917: .5,
                    35918: 1,
                    35919: 1,
                    37488: .5,
                    37489: .5,
                    37490: 1,
                    37491: 1,
                    37492: .5,
                    37496: 1,
                    37493: .5,
                    37497: 1,
                    37494: .5,
                    37495: .5,
                    35840: .5,
                    35842: .5,
                    35841: .25,
                    35843: .25,
                    36196: .5,
                    35986: .5,
                    35986: 1,
                    34798: 1,
                    37808: 1
                }
            },
            4018: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(632);
                r(5542), r(8098), r(5400);
                var s = r(2384),
                    n = r(5333),
                    o = r(8169),
                    a = r(4943),
                    h = r(9608),
                    l = r(6287),
                    u = r(8643),
                    c = r(5985);
                t.INTERNAL_FORMATS = i.INTERNAL_FORMATS, t.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL = i.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL, t.detectCompressedTextures = s.detectCompressedTextures, t.loadDDS = n.loadDDS, t.loadKTX = o.loadKTX, t.resolveCompressedTextureUrl = a.resolveCompressedTextureUrl, t.parseDDS = h.parseDDS, t.FORMATS_TO_COMPONENTS = l.FORMATS_TO_COMPONENTS, t.TYPES_TO_BYTES_PER_COMPONENT = l.TYPES_TO_BYTES_PER_COMPONENT, t.TYPES_TO_BYTES_PER_PIXEL = l.TYPES_TO_BYTES_PER_PIXEL, t.parseKTX = l.parseKTX, t.BlobResource = u.BlobResource, t.CompressedTextureResource = c.CompressedTextureResource
            },
            6156: () => {},
            2384: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                let s, n;

                function o() {
                    n = {
                        s3tc: s.getExtension("WEBGL_compressed_texture_s3tc"),
                        s3tc_sRGB: s.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
                        etc: s.getExtension("WEBGL_compressed_texture_etc"),
                        etc1: s.getExtension("WEBGL_compressed_texture_etc1"),
                        pvrtc: s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                        atc: s.getExtension("WEBGL_compressed_texture_atc"),
                        astc: s.getExtension("WEBGL_compressed_texture_astc")
                    }
                }
                const a = {
                    extension: {
                        type: i.ExtensionType.DetectionParser,
                        priority: 2
                    },
                    test: async () => {
                        const e = i.settings.ADAPTER.createCanvas().getContext("webgl");
                        return e ? (s = e, !0) : (console.warn("WebGL not available for compressed textures."), !1)
                    },
                    add: async e => {
                        n || o();
                        const t = [];
                        for (const e in n) n[e] && t.push(e);
                        return [...t, ...e]
                    },
                    remove: async e => (n || o(), e.filter((e => !(e in n))))
                };
                i.extensions.add(a), t.detectCompressedTextures = a
            },
            5542: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), r(6156);
                var i = r(2384),
                    s = r(5333),
                    n = r(8169),
                    o = r(4943);
                t.detectCompressedTextures = i.detectCompressedTextures, t.loadDDS = s.loadDDS, t.loadKTX = n.loadKTX, t.resolveCompressedTextureUrl = o.resolveCompressedTextureUrl
            },
            5333: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(4645),
                    s = r(7163);
                r(8098);
                var n = r(9608);
                const o = {
                    extension: {
                        type: s.ExtensionType.LoadParser,
                        priority: i.LoaderParserPriority.High
                    },
                    name: "loadDDS",
                    test: e => i.checkExtension(e, ".dds"),
                    async load(e, t, r) {
                        const o = await s.settings.ADAPTER.fetch(e),
                            a = await o.arrayBuffer(),
                            h = n.parseDDS(a).map((n => {
                                const o = new s.BaseTexture(n, {
                                    mipmap: s.MIPMAP_MODES.OFF,
                                    alphaMode: s.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
                                    resolution: s.utils.getResolutionOfUrl(e),
                                    ...t.data
                                });
                                return i.createTexture(o, r, e)
                            }));
                        return 1 === h.length ? h[0] : h
                    },
                    unload(e) {
                        Array.isArray(e) ? e.forEach((e => e.destroy(!0))) : e.destroy(!0)
                    }
                };
                s.extensions.add(o), t.loadDDS = o
            },
            8169: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(4645),
                    s = r(7163);
                r(8098);
                var n = r(6287);
                const o = {
                    extension: {
                        type: s.ExtensionType.LoadParser,
                        priority: i.LoaderParserPriority.High
                    },
                    name: "loadKTX",
                    test: e => i.checkExtension(e, ".ktx"),
                    async load(e, t, r) {
                        const o = await s.settings.ADAPTER.fetch(e),
                            a = await o.arrayBuffer(),
                            {
                                compressed: h,
                                uncompressed: l,
                                kvData: u
                            } = n.parseKTX(e, a),
                            c = h ?? l,
                            d = {
                                mipmap: s.MIPMAP_MODES.OFF,
                                alphaMode: s.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA,
                                resolution: s.utils.getResolutionOfUrl(e),
                                ...t.data
                            },
                            p = c.map((t => {
                                c === l && Object.assign(d, {
                                    type: t.type,
                                    format: t.format
                                });
                                const n = new s.BaseTexture(t, d);
                                return n.ktxKeyValueData = u, i.createTexture(n, r, e)
                            }));
                        return 1 === p.length ? p[0] : p
                    },
                    unload(e) {
                        Array.isArray(e) ? e.forEach((e => e.destroy(!0))) : e.destroy(!0)
                    }
                };
                s.extensions.add(o), t.loadKTX = o
            },
            4943: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                const s = {
                    extension: i.ExtensionType.ResolveParser,
                    test: e => {
                        const t = e.split("?")[0].split(".").pop();
                        return ["basis", "ktx", "dds"].includes(t)
                    },
                    parse: e => {
                        if ("ktx" === e.split("?")[0].split(".").pop()) {
                            const t = [".s3tc.ktx", ".s3tc_sRGB.ktx", ".etc.ktx", ".etc1.ktx", ".pvrt.ktx", ".atc.ktx", ".astc.ktx"];
                            if (t.some((t => e.endsWith(t)))) return {
                                resolution: parseFloat(i.settings.RETINA_PREFIX.exec(e)?.[1] ?? "1"),
                                format: t.find((t => e.endsWith(t))),
                                src: e
                            }
                        }
                        return {
                            resolution: parseFloat(i.settings.RETINA_PREFIX.exec(e)?.[1] ?? "1"),
                            format: e.split(".").pop(),
                            src: e
                        }
                    }
                };
                i.extensions.add(s), t.resolveCompressedTextureUrl = s
            },
            8098: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(9608),
                    s = r(6287);
                t.parseDDS = i.parseDDS, t.FORMATS_TO_COMPONENTS = s.FORMATS_TO_COMPONENTS, t.TYPES_TO_BYTES_PER_COMPONENT = s.TYPES_TO_BYTES_PER_COMPONENT, t.TYPES_TO_BYTES_PER_PIXEL = s.TYPES_TO_BYTES_PER_PIXEL, t.parseKTX = s.parseKTX
            },
            9608: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(632);
                r(5400);
                var s = r(5985);
                const n = {
                        827611204: i.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
                        861165636: i.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
                        894720068: i.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    },
                    o = {
                        70: i.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
                        71: i.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
                        73: i.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
                        74: i.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
                        76: i.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
                        77: i.INTERNAL_FORMATS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
                        72: i.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
                        75: i.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
                        78: i.INTERNAL_FORMATS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                    };
                t.parseDDS = function(e) {
                    const t = new Uint32Array(e);
                    if (542327876 !== t[0]) throw new Error("Invalid DDS file magic word");
                    const r = new Uint32Array(e, 0, 124 / Uint32Array.BYTES_PER_ELEMENT),
                        a = r[3],
                        h = r[4],
                        l = r[7],
                        u = new Uint32Array(e, 19 * Uint32Array.BYTES_PER_ELEMENT, 32 / Uint32Array.BYTES_PER_ELEMENT),
                        c = u[1];
                    if (4 & c) {
                        const r = u[2];
                        if (808540228 !== r) {
                            const t = n[r],
                                i = new Uint8Array(e, 128);
                            return [new s.CompressedTextureResource(i, {
                                format: t,
                                width: h,
                                height: a,
                                levels: l
                            })]
                        }
                        const c = 128,
                            d = new Uint32Array(t.buffer, c, 20 / Uint32Array.BYTES_PER_ELEMENT),
                            p = d[0],
                            f = d[1],
                            m = d[2],
                            g = d[3],
                            y = o[p];
                        if (void 0 === y) throw new Error(`DDSParser cannot parse texture data with DXGI format ${p}`);
                        if (4 === m) throw new Error("DDSParser does not support cubemap textures");
                        if (6 === f) throw new Error("DDSParser does not supported 3D texture data");
                        const _ = new Array,
                            v = 148;
                        if (1 === g) _.push(new Uint8Array(e, v));
                        else {
                            const t = i.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[y];
                            let r = 0,
                                s = h,
                                n = a;
                            for (let e = 0; e < l; e++) r += Math.max(1, s + 3 & -4) * Math.max(1, n + 3 & -4) * t, s >>>= 1, n >>>= 1;
                            let o = v;
                            for (let t = 0; t < g; t++) _.push(new Uint8Array(e, o, r)), o += r
                        }
                        return _.map((e => new s.CompressedTextureResource(e, {
                            format: y,
                            width: h,
                            height: a,
                            levels: l
                        })))
                    }
                    if (64 & c) throw new Error("DDSParser does not support uncompressed texture data.");
                    if (512 & c) throw new Error("DDSParser does not supported YUV uncompressed texture data.");
                    if (131072 & c) throw new Error("DDSParser does not support single-channel (lumninance) texture data!");
                    if (2 & c) throw new Error("DDSParser does not support single-channel (alpha) texture data!");
                    throw new Error("DDSParser failed to load a texture file due to an unknown reason!")
                }
            },
            6287: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(632);
                r(5400);
                var n = r(5985);
                const o = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10],
                    a = {
                        [i.TYPES.UNSIGNED_BYTE]: 1,
                        [i.TYPES.UNSIGNED_SHORT]: 2,
                        [i.TYPES.INT]: 4,
                        [i.TYPES.UNSIGNED_INT]: 4,
                        [i.TYPES.FLOAT]: 4,
                        [i.TYPES.HALF_FLOAT]: 8
                    },
                    h = {
                        [i.FORMATS.RGBA]: 4,
                        [i.FORMATS.RGB]: 3,
                        [i.FORMATS.RG]: 2,
                        [i.FORMATS.RED]: 1,
                        [i.FORMATS.LUMINANCE]: 1,
                        [i.FORMATS.LUMINANCE_ALPHA]: 2,
                        [i.FORMATS.ALPHA]: 1
                    },
                    l = {
                        [i.TYPES.UNSIGNED_SHORT_4_4_4_4]: 2,
                        [i.TYPES.UNSIGNED_SHORT_5_5_5_1]: 2,
                        [i.TYPES.UNSIGNED_SHORT_5_6_5]: 2
                    };

                function u(e) {
                    switch (e) {
                        case i.FORMATS.RGBA:
                            return i.FORMATS.RGBA_INTEGER;
                        case i.FORMATS.RGB:
                            return i.FORMATS.RGB_INTEGER;
                        case i.FORMATS.RG:
                            return i.FORMATS.RG_INTEGER;
                        case i.FORMATS.RED:
                            return i.FORMATS.RED_INTEGER;
                        default:
                            return e
                    }
                }
                t.FORMATS_TO_COMPONENTS = h, t.TYPES_TO_BYTES_PER_COMPONENT = a, t.TYPES_TO_BYTES_PER_PIXEL = l, t.parseKTX = function(e, t, r = !1) {
                    const c = new DataView(t);
                    if (! function(e, t) {
                            for (let r = 0; r < o.length; r++)
                                if (t.getUint8(r) !== o[r]) return console.error(`${e} is not a valid *.ktx file!`), !1;
                            return !0
                        }(e, c)) return null;
                    const d = 67305985 === c.getUint32(12, !0),
                        p = c.getUint32(16, d),
                        f = c.getUint32(24, d),
                        m = c.getUint32(28, d),
                        g = c.getUint32(36, d),
                        y = c.getUint32(40, d) || 1,
                        _ = c.getUint32(44, d) || 1,
                        v = c.getUint32(48, d) || 1,
                        S = c.getUint32(52, d),
                        T = c.getUint32(56, d),
                        b = c.getUint32(60, d);
                    if (0 === y || 1 !== _) throw new Error("Only 2D textures are supported");
                    if (1 !== S) throw new Error("CubeTextures are not supported by KTXLoader yet!");
                    if (1 !== v) throw new Error("WebGL does not support array textures");
                    const E = g + 3 & -4,
                        x = y + 3 & -4,
                        w = new Array(v);
                    let O, A = g * y;
                    if (0 === p && (A = E * x), O = 0 !== p ? a[p] ? a[p] * h[f] : l[p] : s.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[m], void 0 === O) throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
                    const P = r ? function(e, t, r) {
                        const i = new Map;
                        let s = 0;
                        for (; s < t;) {
                            const n = e.getUint32(64 + s, r),
                                o = 64 + s + 4,
                                a = 3 - (n + 3) % 4;
                            if (0 === n || n > t - s) {
                                console.error("KTXLoader: keyAndValueByteSize out of bounds");
                                break
                            }
                            let h = 0;
                            for (; h < n && 0 !== e.getUint8(o + h); h++);
                            if (-1 === h) {
                                console.error("KTXLoader: Failed to find null byte terminating kvData key");
                                break
                            }
                            const l = (new TextDecoder).decode(new Uint8Array(e.buffer, o, h)),
                                u = new DataView(e.buffer, o + h + 1, n - h - 1);
                            i.set(l, u), s += 4 + n + a
                        }
                        return i
                    }(c, b, d) : null;
                    let M = A * O,
                        C = g,
                        R = y,
                        I = E,
                        B = x,
                        D = 64 + b;
                    for (let e = 0; e < T; e++) {
                        const r = c.getUint32(D, d);
                        let i = D + 4;
                        for (let r = 0; r < v; r++) {
                            let s = w[r];
                            s || (s = w[r] = new Array(T)), s[e] = {
                                levelID: e,
                                levelWidth: T > 1 || 0 !== p ? C : I,
                                levelHeight: T > 1 || 0 !== p ? R : B,
                                levelBuffer: new Uint8Array(t, i, M)
                            }, i += M
                        }
                        D += r + 4, D = D % 4 != 0 ? D + 4 - D % 4 : D, C = C >> 1 || 1, R = R >> 1 || 1, I = C + 4 - 1 & -4, B = R + 4 - 1 & -4, M = I * B * O
                    }
                    return 0 !== p ? {
                        uncompressed: w.map((e => {
                            let t = e[0].levelBuffer,
                                r = !1;
                            return p === i.TYPES.FLOAT ? t = new Float32Array(e[0].levelBuffer.buffer, e[0].levelBuffer.byteOffset, e[0].levelBuffer.byteLength / 4) : p === i.TYPES.UNSIGNED_INT ? (r = !0, t = new Uint32Array(e[0].levelBuffer.buffer, e[0].levelBuffer.byteOffset, e[0].levelBuffer.byteLength / 4)) : p === i.TYPES.INT && (r = !0, t = new Int32Array(e[0].levelBuffer.buffer, e[0].levelBuffer.byteOffset, e[0].levelBuffer.byteLength / 4)), {
                                resource: new i.BufferResource(t, {
                                    width: e[0].levelWidth,
                                    height: e[0].levelHeight
                                }),
                                type: p,
                                format: r ? u(f) : f
                            }
                        })),
                        kvData: P
                    } : {
                        compressed: w.map((e => new n.CompressedTextureResource(null, {
                            format: m,
                            width: g,
                            height: y,
                            levels: T,
                            levelBuffers: e
                        }))),
                        kvData: P
                    }
                }
            },
            8643: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                class s extends i.BufferResource {
                    constructor(e, t = {
                        width: 1,
                        height: 1,
                        autoLoad: !0
                    }) {
                        let r, s;
                        "string" == typeof e ? (r = e, s = new Uint8Array) : (r = null, s = e), super(s, t), this.origin = r, this.buffer = s ? new i.ViewableBuffer(s) : null, this.origin && !1 !== t.autoLoad && this.load(), s?.length && (this.loaded = !0, this.onBlobLoaded(this.buffer.rawBinaryData))
                    }
                    onBlobLoaded(e) {}
                    async load() {
                        const e = await fetch(this.origin),
                            t = await e.blob(),
                            r = await t.arrayBuffer();
                        return this.data = new Uint32Array(r), this.buffer = new i.ViewableBuffer(r), this.loaded = !0, this.onBlobLoaded(r), this.update(), this
                    }
                }
                t.BlobResource = s
            },
            5985: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(632),
                    s = r(8643);
                class n extends s.BlobResource {
                    constructor(e, t) {
                        super(e, t), this.format = t.format, this.levels = t.levels || 1, this._width = t.width, this._height = t.height, this._extension = n._formatToExtension(this.format), (t.levelBuffers || this.buffer) && (this._levelBuffers = t.levelBuffers || n._createLevelBuffers(e instanceof Uint8Array ? e : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height))
                    }
                    upload(e, t, r) {
                        const i = e.gl;
                        if (!e.context.extensions[this._extension]) throw new Error(`${this._extension} textures are not supported on the current machine`);
                        if (!this._levelBuffers) return !1;
                        for (let e = 0, t = this.levels; e < t; e++) {
                            const {
                                levelID: t,
                                levelWidth: r,
                                levelHeight: s,
                                levelBuffer: n
                            } = this._levelBuffers[e];
                            i.compressedTexImage2D(i.TEXTURE_2D, t, this.format, r, s, 0, n)
                        }
                        return !0
                    }
                    onBlobLoaded() {
                        this._levelBuffers = n._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height)
                    }
                    static _formatToExtension(e) {
                        if (e >= 33776 && e <= 33779) return "s3tc";
                        if (e >= 37488 && e <= 37497) return "etc";
                        if (e >= 35840 && e <= 35843) return "pvrtc";
                        if (e >= 36196) return "etc1";
                        if (e >= 35986 && e <= 34798) return "atc";
                        throw new Error("Invalid (compressed) texture format given!")
                    }
                    static _createLevelBuffers(e, t, r, s, n, o, a) {
                        const h = new Array(r);
                        let l = e.byteOffset,
                            u = o,
                            c = a,
                            d = u + s - 1 & ~(s - 1),
                            p = c + n - 1 & ~(n - 1),
                            f = d * p * i.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[t];
                        for (let o = 0; o < r; o++) h[o] = {
                            levelID: o,
                            levelWidth: r > 1 ? u : d,
                            levelHeight: r > 1 ? c : p,
                            levelBuffer: new Uint8Array(e.buffer, l, f)
                        }, l += f, u = u >> 1 || 1, c = c >> 1 || 1, d = u + s - 1 & ~(s - 1), p = c + n - 1 & ~(n - 1), f = d * p * i.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[t];
                        return h
                    }
                }
                t.CompressedTextureResource = n
            },
            5400: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(8643),
                    s = r(5985);
                t.BlobResource = i.BlobResource, t.CompressedTextureResource = s.CompressedTextureResource
            },
            2386: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = (e => (e[e.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", e[e.WEBGL = 1] = "WEBGL", e[e.WEBGL2 = 2] = "WEBGL2", e))(r || {}),
                    i = (e => (e[e.UNKNOWN = 0] = "UNKNOWN", e[e.WEBGL = 1] = "WEBGL", e[e.CANVAS = 2] = "CANVAS", e))(i || {}),
                    s = (e => (e[e.COLOR = 16384] = "COLOR", e[e.DEPTH = 256] = "DEPTH", e[e.STENCIL = 1024] = "STENCIL", e))(s || {}),
                    n = (e => (e[e.NORMAL = 0] = "NORMAL", e[e.ADD = 1] = "ADD", e[e.MULTIPLY = 2] = "MULTIPLY", e[e.SCREEN = 3] = "SCREEN", e[e.OVERLAY = 4] = "OVERLAY", e[e.DARKEN = 5] = "DARKEN", e[e.LIGHTEN = 6] = "LIGHTEN", e[e.COLOR_DODGE = 7] = "COLOR_DODGE", e[e.COLOR_BURN = 8] = "COLOR_BURN", e[e.HARD_LIGHT = 9] = "HARD_LIGHT", e[e.SOFT_LIGHT = 10] = "SOFT_LIGHT", e[e.DIFFERENCE = 11] = "DIFFERENCE", e[e.EXCLUSION = 12] = "EXCLUSION", e[e.HUE = 13] = "HUE", e[e.SATURATION = 14] = "SATURATION", e[e.COLOR = 15] = "COLOR", e[e.LUMINOSITY = 16] = "LUMINOSITY", e[e.NORMAL_NPM = 17] = "NORMAL_NPM", e[e.ADD_NPM = 18] = "ADD_NPM", e[e.SCREEN_NPM = 19] = "SCREEN_NPM", e[e.NONE = 20] = "NONE", e[e.SRC_OVER = 0] = "SRC_OVER", e[e.SRC_IN = 21] = "SRC_IN", e[e.SRC_OUT = 22] = "SRC_OUT", e[e.SRC_ATOP = 23] = "SRC_ATOP", e[e.DST_OVER = 24] = "DST_OVER", e[e.DST_IN = 25] = "DST_IN", e[e.DST_OUT = 26] = "DST_OUT", e[e.DST_ATOP = 27] = "DST_ATOP", e[e.ERASE = 26] = "ERASE", e[e.SUBTRACT = 28] = "SUBTRACT", e[e.XOR = 29] = "XOR", e))(n || {}),
                    o = (e => (e[e.POINTS = 0] = "POINTS", e[e.LINES = 1] = "LINES", e[e.LINE_LOOP = 2] = "LINE_LOOP", e[e.LINE_STRIP = 3] = "LINE_STRIP", e[e.TRIANGLES = 4] = "TRIANGLES", e[e.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", e[e.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", e))(o || {}),
                    a = (e => (e[e.RGBA = 6408] = "RGBA", e[e.RGB = 6407] = "RGB", e[e.RG = 33319] = "RG", e[e.RED = 6403] = "RED", e[e.RGBA_INTEGER = 36249] = "RGBA_INTEGER", e[e.RGB_INTEGER = 36248] = "RGB_INTEGER", e[e.RG_INTEGER = 33320] = "RG_INTEGER", e[e.RED_INTEGER = 36244] = "RED_INTEGER", e[e.ALPHA = 6406] = "ALPHA", e[e.LUMINANCE = 6409] = "LUMINANCE", e[e.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", e[e.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", e[e.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", e))(a || {}),
                    h = (e => (e[e.TEXTURE_2D = 3553] = "TEXTURE_2D", e[e.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", e[e.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", e[e.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", e[e.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", e[e.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", e[e.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", e[e.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", e[e.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", e))(h || {}),
                    l = (e => (e[e.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", e[e.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", e[e.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", e[e.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", e[e.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", e[e.UNSIGNED_INT = 5125] = "UNSIGNED_INT", e[e.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", e[e.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", e[e.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", e[e.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", e[e.BYTE = 5120] = "BYTE", e[e.SHORT = 5122] = "SHORT", e[e.INT = 5124] = "INT", e[e.FLOAT = 5126] = "FLOAT", e[e.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", e[e.HALF_FLOAT = 36193] = "HALF_FLOAT", e))(l || {}),
                    u = (e => (e[e.FLOAT = 0] = "FLOAT", e[e.INT = 1] = "INT", e[e.UINT = 2] = "UINT", e))(u || {}),
                    c = (e => (e[e.NEAREST = 0] = "NEAREST", e[e.LINEAR = 1] = "LINEAR", e))(c || {}),
                    d = (e => (e[e.CLAMP = 33071] = "CLAMP", e[e.REPEAT = 10497] = "REPEAT", e[e.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", e))(d || {}),
                    p = (e => (e[e.OFF = 0] = "OFF", e[e.POW2 = 1] = "POW2", e[e.ON = 2] = "ON", e[e.ON_MANUAL = 3] = "ON_MANUAL", e))(p || {}),
                    f = (e => (e[e.NPM = 0] = "NPM", e[e.UNPACK = 1] = "UNPACK", e[e.PMA = 2] = "PMA", e[e.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", e[e.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", e[e.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA", e))(f || {}),
                    m = (e => (e[e.NO = 0] = "NO", e[e.YES = 1] = "YES", e[e.AUTO = 2] = "AUTO", e[e.BLEND = 0] = "BLEND", e[e.CLEAR = 1] = "CLEAR", e[e.BLIT = 2] = "BLIT", e))(m || {}),
                    g = (e => (e[e.AUTO = 0] = "AUTO", e[e.MANUAL = 1] = "MANUAL", e))(g || {}),
                    y = (e => (e.LOW = "lowp", e.MEDIUM = "mediump", e.HIGH = "highp", e))(y || {}),
                    _ = (e => (e[e.NONE = 0] = "NONE", e[e.SCISSOR = 1] = "SCISSOR", e[e.STENCIL = 2] = "STENCIL", e[e.SPRITE = 3] = "SPRITE", e[e.COLOR = 4] = "COLOR", e))(_ || {}),
                    v = (e => (e[e.RED = 1] = "RED", e[e.GREEN = 2] = "GREEN", e[e.BLUE = 4] = "BLUE", e[e.ALPHA = 8] = "ALPHA", e))(v || {}),
                    S = (e => (e[e.NONE = 0] = "NONE", e[e.LOW = 2] = "LOW", e[e.MEDIUM = 4] = "MEDIUM", e[e.HIGH = 8] = "HIGH", e))(S || {}),
                    T = (e => (e[e.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", e[e.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", e[e.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", e))(T || {});
                t.ALPHA_MODES = f, t.BLEND_MODES = n, t.BUFFER_BITS = s, t.BUFFER_TYPE = T, t.CLEAR_MODES = m, t.COLOR_MASK_BITS = v, t.DRAW_MODES = o, t.ENV = r, t.FORMATS = a, t.GC_MODES = g, t.MASK_TYPES = _, t.MIPMAP_MODES = p, t.MSAA_QUALITY = S, t.PRECISION = y, t.RENDERER_TYPE = i, t.SAMPLER_TYPES = u, t.SCALE_MODES = c, t.TARGETS = h, t.TYPES = l, t.WRAP_MODES = d
            },
            178: () => {},
            2564: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(7222),
                    n = r(8153),
                    o = r(6667),
                    a = r(6128),
                    h = r(4353),
                    l = r(4462);
                const u = class extends l.SystemManager {
                    constructor(e) {
                        super(), this.type = i.RENDERER_TYPE.WEBGL, e = Object.assign({}, o.settings.RENDER_OPTIONS, e), this.gl = null, this.CONTEXT_UID = 0, this.globalUniforms = new h.UniformGroup({
                            projectionMatrix: new n.Matrix
                        }, !0);
                        const t = {
                            runners: ["init", "destroy", "contextChange", "resolutionChange", "reset", "update", "postrender", "prerender", "resize"],
                            systems: u.__systems,
                            priority: ["_view", "textureGenerator", "background", "_plugin", "startup", "context", "state", "texture", "buffer", "geometry", "framebuffer", "transformFeedback", "mask", "scissor", "stencil", "projection", "textureGC", "filter", "renderTexture", "batch", "objectRenderer", "_multisample"]
                        };
                        this.setup(t), "useContextAlpha" in e && (a.deprecation("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"), e.premultipliedAlpha = e.useContextAlpha && "notMultiplied" !== e.useContextAlpha, e.backgroundAlpha = !1 === e.useContextAlpha ? 1 : e.backgroundAlpha), this._plugin.rendererPlugins = u.__plugins, this.options = e, this.startup.run(this.options)
                    }
                    static test(e) {
                        return !e?.forceCanvas && a.isWebGLSupported()
                    }
                    render(e, t) {
                        this.objectRenderer.render(e, t)
                    }
                    resize(e, t) {
                        this._view.resizeView(e, t)
                    }
                    reset() {
                        return this.runners.reset.emit(), this
                    }
                    clear() {
                        this.renderTexture.bind(), this.renderTexture.clear()
                    }
                    destroy(e = !1) {
                        this.runners.destroy.items.reverse(), this.emitWithCustomOptions(this.runners.destroy, {
                            _view: e
                        }), super.destroy()
                    }
                    get plugins() {
                        return this._plugin.plugins
                    }
                    get multisample() {
                        return this._multisample.multisample
                    }
                    get width() {
                        return this._view.element.width
                    }
                    get height() {
                        return this._view.element.height
                    }
                    get resolution() {
                        return this._view.resolution
                    }
                    set resolution(e) {
                        this._view.resolution = e, this.runners.resolutionChange.emit(e)
                    }
                    get autoDensity() {
                        return this._view.autoDensity
                    }
                    get view() {
                        return this._view.element
                    }
                    get screen() {
                        return this._view.screen
                    }
                    get lastObjectRendered() {
                        return this.objectRenderer.lastObjectRendered
                    }
                    get renderingToScreen() {
                        return this.objectRenderer.renderingToScreen
                    }
                    get rendererLogId() {
                        return `WebGL ${this.context.webGLVersion}`
                    }
                    get clearBeforeRender() {
                        return a.deprecation("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."), this.background.clearBeforeRender
                    }
                    get useContextAlpha() {
                        return a.deprecation("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."), this.context.useContextAlpha
                    }
                    get preserveDrawingBuffer() {
                        return a.deprecation("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"), this.context.preserveDrawingBuffer
                    }
                    get backgroundColor() {
                        return a.deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color
                    }
                    set backgroundColor(e) {
                        a.deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color = e
                    }
                    get backgroundAlpha() {
                        return a.deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha
                    }
                    set backgroundAlpha(e) {
                        a.deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha = e
                    }
                    get powerPreference() {
                        return a.deprecation("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"), this.context.powerPreference
                    }
                    generateTexture(e, t) {
                        return this.textureGenerator.generateTexture(e, t)
                    }
                };
                let c = u;
                c.extension = {
                    type: s.ExtensionType.Renderer,
                    priority: 1
                }, c.__plugins = {}, c.__systems = {}, s.extensions.handleByMap(s.ExtensionType.RendererPlugin, c.__plugins), s.extensions.handleByMap(s.ExtensionType.RendererSystem, c.__systems), s.extensions.add(c), t.Renderer = c
            },
            2555: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7222);
                const s = [];
                i.extensions.handleByList(i.ExtensionType.Renderer, s), t.autoDetectRenderer = function(e) {
                    for (const t of s)
                        if (t.test(e)) return new t(e);
                    throw new Error("Unable to auto-detect a suitable renderer.")
                }
            },
            3346: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2264),
                    s = r(7222);
                class n {
                    constructor() {
                        this.clearBeforeRender = !0, this._backgroundColor = new i.Color(0), this.alpha = 1
                    }
                    init(e) {
                        this.clearBeforeRender = e.clearBeforeRender;
                        const {
                            backgroundColor: t,
                            background: r,
                            backgroundAlpha: i
                        } = e, s = r ?? t;
                        void 0 !== s && (this.color = s), this.alpha = i
                    }
                    get color() {
                        return this._backgroundColor.value
                    }
                    set color(e) {
                        this._backgroundColor.setValue(e)
                    }
                    get alpha() {
                        return this._backgroundColor.alpha
                    }
                    set alpha(e) {
                        this._backgroundColor.setAlpha(e)
                    }
                    get backgroundColor() {
                        return this._backgroundColor
                    }
                    destroy() {}
                }
                n.defaultOptions = {
                    backgroundAlpha: 1,
                    backgroundColor: 0,
                    clearBeforeRender: !0
                }, n.extension = {
                    type: [s.ExtensionType.RendererSystem, s.ExtensionType.CanvasRendererSystem],
                    name: "background"
                }, s.extensions.add(n), t.BackgroundSystem = n
            },
            8713: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386);
                t.BatchDrawCall = class {
                    constructor() {
                        this.texArray = null, this.blend = 0, this.type = i.DRAW_MODES.TRIANGLES, this.start = 0, this.size = 0, this.data = null
                    }
                }
            },
            1966: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(9202),
                    n = r(1990);
                class o extends n.Geometry {
                    constructor(e = !1) {
                        super(), this._buffer = new s.Buffer(null, e, !1), this._indexBuffer = new s.Buffer(null, e, !0), this.addAttribute("aVertexPosition", this._buffer, 2, !1, i.TYPES.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, !1, i.TYPES.FLOAT).addAttribute("aColor", this._buffer, 4, !0, i.TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, !0, i.TYPES.FLOAT).addIndex(this._indexBuffer)
                    }
                }
                t.BatchGeometry = o
            },
            7159: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2264),
                    s = r(2386),
                    n = r(7222),
                    o = r(6667),
                    a = r(6128),
                    h = r(5951),
                    l = r(3576),
                    u = r(8303),
                    c = r(4291),
                    d = r(8713),
                    p = r(1966),
                    f = r(3865),
                    m = r(9120),
                    g = r(1299),
                    y = r(7641),
                    _ = r(5886),
                    v = r(7321),
                    S = r(9800);
                const T = class extends _.ObjectRenderer {
                    constructor(e) {
                        super(e), this.setShaderGenerator(), this.geometryClass = p.BatchGeometry, this.vertexSize = 6, this.state = u.State.for2d(), this.size = 4 * T.defaultBatchSize, this._vertexCount = 0, this._indexCount = 0, this._bufferedElements = [], this._bufferedTextures = [], this._bufferSize = 0, this._shader = null, this._packedGeometries = [], this._packedGeometryPoolSize = 2, this._flushId = 0, this._aBuffers = {}, this._iBuffers = {}, this.maxTextures = 1, this.renderer.on("prerender", this.onPrerender, this), e.runners.contextChange.add(this), this._dcIndex = 0, this._aIndex = 0, this._iIndex = 0, this._attributeBuffer = null, this._indexBuffer = null, this._tempBoundTextures = []
                    }
                    static get defaultMaxTextures() {
                        return this._defaultMaxTextures = this._defaultMaxTextures ?? y.maxRecommendedTextures(32), this._defaultMaxTextures
                    }
                    static set defaultMaxTextures(e) {
                        this._defaultMaxTextures = e
                    }
                    static get canUploadSameBuffer() {
                        return this._canUploadSameBuffer = this._canUploadSameBuffer ?? g.canUploadSameBuffer(), this._canUploadSameBuffer
                    }
                    static set canUploadSameBuffer(e) {
                        this._canUploadSameBuffer = e
                    }
                    get MAX_TEXTURES() {
                        return a.deprecation("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"), this.maxTextures
                    }
                    static get defaultVertexSrc() {
                        return S.default
                    }
                    static get defaultFragmentTemplate() {
                        return v.default
                    }
                    setShaderGenerator({
                        vertex: e = T.defaultVertexSrc,
                        fragment: t = T.defaultFragmentTemplate
                    } = {}) {
                        this.shaderGenerator = new f.BatchShaderGenerator(e, t)
                    }
                    contextChange() {
                        const e = this.renderer.gl;
                        o.settings.PREFER_ENV === s.ENV.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), T.defaultMaxTextures), this.maxTextures = l.checkMaxIfStatementsInShader(this.maxTextures, e)), this._shader = this.shaderGenerator.generateShader(this.maxTextures);
                        for (let e = 0; e < this._packedGeometryPoolSize; e++) this._packedGeometries[e] = new this.geometryClass;
                        this.initFlushBuffers()
                    }
                    initFlushBuffers() {
                        const {
                            _drawCallPool: e,
                            _textureArrayPool: t
                        } = T, r = this.size / 4, i = Math.floor(r / this.maxTextures) + 1;
                        for (; e.length < r;) e.push(new d.BatchDrawCall);
                        for (; t.length < i;) t.push(new m.BatchTextureArray);
                        for (let e = 0; e < this.maxTextures; e++) this._tempBoundTextures[e] = null
                    }
                    onPrerender() {
                        this._flushId = 0
                    }
                    render(e) {
                        e._texture.valid && (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += e.vertexData.length / 2, this._indexCount += e.indices.length, this._bufferedTextures[this._bufferSize] = e._texture.baseTexture, this._bufferedElements[this._bufferSize++] = e)
                    }
                    buildTexturesAndDrawCalls() {
                        const {
                            _bufferedTextures: e,
                            maxTextures: t
                        } = this, r = T._textureArrayPool, i = this.renderer.batch, s = this._tempBoundTextures, n = this.renderer.textureGC.count;
                        let o = ++c.BaseTexture._globalBatch,
                            a = 0,
                            h = r[0],
                            l = 0;
                        i.copyBoundTextures(s, t);
                        for (let u = 0; u < this._bufferSize; ++u) {
                            const c = e[u];
                            e[u] = null, c._batchEnabled !== o && (h.count >= t && (i.boundArray(h, s, o, t), this.buildDrawCalls(h, l, u), l = u, h = r[++a], ++o), c._batchEnabled = o, c.touched = n, h.elements[h.count++] = c)
                        }
                        h.count > 0 && (i.boundArray(h, s, o, t), this.buildDrawCalls(h, l, this._bufferSize), ++a, ++o);
                        for (let e = 0; e < s.length; e++) s[e] = null;
                        c.BaseTexture._globalBatch = o
                    }
                    buildDrawCalls(e, t, r) {
                        const {
                            _bufferedElements: i,
                            _attributeBuffer: s,
                            _indexBuffer: n,
                            vertexSize: o
                        } = this, h = T._drawCallPool;
                        let l = this._dcIndex,
                            u = this._aIndex,
                            c = this._iIndex,
                            d = h[l];
                        d.start = this._iIndex, d.texArray = e;
                        for (let p = t; p < r; ++p) {
                            const r = i[p],
                                f = r._texture.baseTexture,
                                m = a.premultiplyBlendMode[f.alphaMode ? 1 : 0][r.blendMode];
                            i[p] = null, t < p && d.blend !== m && (d.size = c - d.start, t = p, d = h[++l], d.texArray = e, d.start = c), this.packInterleavedGeometry(r, s, n, u, c), u += r.vertexData.length / 2 * o, c += r.indices.length, d.blend = m
                        }
                        t < r && (d.size = c - d.start, ++l), this._dcIndex = l, this._aIndex = u, this._iIndex = c
                    }
                    bindAndClearTexArray(e) {
                        const t = this.renderer.texture;
                        for (let r = 0; r < e.count; r++) t.bind(e.elements[r], e.ids[r]), e.elements[r] = null;
                        e.count = 0
                    }
                    updateGeometry() {
                        const {
                            _packedGeometries: e,
                            _attributeBuffer: t,
                            _indexBuffer: r
                        } = this;
                        T.canUploadSameBuffer ? (e[this._flushId]._buffer.update(t.rawBinaryData), e[this._flushId]._indexBuffer.update(r), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, e[this._flushId] = new this.geometryClass), e[this._flushId]._buffer.update(t.rawBinaryData), e[this._flushId]._indexBuffer.update(r), this.renderer.geometry.bind(e[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++)
                    }
                    drawBatches() {
                        const e = this._dcIndex,
                            {
                                gl: t,
                                state: r
                            } = this.renderer,
                            i = T._drawCallPool;
                        let s = null;
                        for (let n = 0; n < e; n++) {
                            const {
                                texArray: e,
                                type: o,
                                size: a,
                                start: h,
                                blend: l
                            } = i[n];
                            s !== e && (s = e, this.bindAndClearTexArray(e)), this.state.blendMode = l, r.set(this.state), t.drawElements(o, a, t.UNSIGNED_SHORT, 2 * h)
                        }
                    }
                    flush() {
                        0 !== this._vertexCount && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0)
                    }
                    start() {
                        this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.maxTextures), this.renderer.shader.bind(this._shader), T.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId])
                    }
                    stop() {
                        this.flush()
                    }
                    destroy() {
                        for (let e = 0; e < this._packedGeometryPoolSize; e++) this._packedGeometries[e] && this._packedGeometries[e].destroy();
                        this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), super.destroy()
                    }
                    getAttributeBuffer(e) {
                        const t = a.nextPow2(Math.ceil(e / 8)),
                            r = a.log2(t),
                            i = 8 * t;
                        this._aBuffers.length <= r && (this._iBuffers.length = r + 1);
                        let s = this._aBuffers[i];
                        return s || (this._aBuffers[i] = s = new h.ViewableBuffer(i * this.vertexSize * 4)), s
                    }
                    getIndexBuffer(e) {
                        const t = a.nextPow2(Math.ceil(e / 12)),
                            r = a.log2(t),
                            i = 12 * t;
                        this._iBuffers.length <= r && (this._iBuffers.length = r + 1);
                        let s = this._iBuffers[r];
                        return s || (this._iBuffers[r] = s = new Uint16Array(i)), s
                    }
                    packInterleavedGeometry(e, t, r, s, n) {
                        const {
                            uint32View: o,
                            float32View: a
                        } = t, h = s / this.vertexSize, l = e.uvs, u = e.indices, c = e.vertexData, d = e._texture.baseTexture._batchLocation, p = Math.min(e.worldAlpha, 1), f = i.Color.shared.setValue(e._tintRGB).toPremultiplied(p);
                        for (let e = 0; e < c.length; e += 2) a[s++] = c[e], a[s++] = c[e + 1], a[s++] = l[e], a[s++] = l[e + 1], o[s++] = f, a[s++] = d;
                        for (let e = 0; e < u.length; e++) r[n++] = h + u[e]
                    }
                };
                let b = T;
                b.defaultBatchSize = 4096, b.extension = {
                    name: "batch",
                    type: n.ExtensionType.RendererPlugin
                }, b._drawCallPool = [], b._textureArrayPool = [], n.extensions.add(b), t.BatchRenderer = b
            },
            3865: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(8153),
                    s = r(7685),
                    n = r(510),
                    o = r(4353);
                t.BatchShaderGenerator = class {
                    constructor(e, t) {
                        if (this.vertexSrc = e, this.fragTemplate = t, this.programCache = {}, this.defaultGroupCache = {}, !t.includes("%count%")) throw new Error('Fragment template must contain "%count%".');
                        if (!t.includes("%forloop%")) throw new Error('Fragment template must contain "%forloop%".')
                    }
                    generateShader(e) {
                        if (!this.programCache[e]) {
                            const t = new Int32Array(e);
                            for (let r = 0; r < e; r++) t[r] = r;
                            this.defaultGroupCache[e] = o.UniformGroup.from({
                                uSamplers: t
                            }, !0);
                            let r = this.fragTemplate;
                            r = r.replace(/%count%/gi, `${e}`), r = r.replace(/%forloop%/gi, this.generateSampleSrc(e)), this.programCache[e] = new s.Program(this.vertexSrc, r)
                        }
                        const t = {
                            tint: new Float32Array([1, 1, 1, 1]),
                            translationMatrix: new i.Matrix,
                            default: this.defaultGroupCache[e]
                        };
                        return new n.Shader(this.programCache[e], t)
                    }
                    generateSampleSrc(e) {
                        let t = "";
                        t += "\n", t += "\n";
                        for (let r = 0; r < e; r++) r > 0 && (t += "\nelse "), r < e - 1 && (t += `if(vTextureId < ${r}.5)`), t += "\n{", t += `\n\tcolor = texture2D(uSamplers[${r}], vTextureCoord);`, t += "\n}";
                        return t += "\n", t += "\n", t
                    }
                }
            },
            9769: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7222),
                    s = r(5886);
                class n {
                    constructor(e) {
                        this.renderer = e, this.emptyRenderer = new s.ObjectRenderer(e), this.currentRenderer = this.emptyRenderer
                    }
                    setObjectRenderer(e) {
                        this.currentRenderer !== e && (this.currentRenderer.stop(), this.currentRenderer = e, this.currentRenderer.start())
                    }
                    flush() {
                        this.setObjectRenderer(this.emptyRenderer)
                    }
                    reset() {
                        this.setObjectRenderer(this.emptyRenderer)
                    }
                    copyBoundTextures(e, t) {
                        const {
                            boundTextures: r
                        } = this.renderer.texture;
                        for (let i = t - 1; i >= 0; --i) e[i] = r[i] || null, e[i] && (e[i]._batchLocation = i)
                    }
                    boundArray(e, t, r, i) {
                        const {
                            elements: s,
                            ids: n,
                            count: o
                        } = e;
                        let a = 0;
                        for (let e = 0; e < o; e++) {
                            const o = s[e],
                                h = o._batchLocation;
                            if (h >= 0 && h < i && t[h] === o) n[e] = h;
                            else
                                for (; a < i;) {
                                    const i = t[a];
                                    if (!i || i._batchEnabled !== r || i._batchLocation !== a) {
                                        n[e] = a, o._batchLocation = a, t[a] = o;
                                        break
                                    }
                                    a++
                                }
                        }
                    }
                    destroy() {
                        this.renderer = null
                    }
                }
                n.extension = {
                    type: i.ExtensionType.RendererSystem,
                    name: "batch"
                }, i.extensions.add(n), t.BatchSystem = n
            },
            9120: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.BatchTextureArray = class {
                    constructor() {
                        this.elements = [], this.ids = [], this.count = 0
                    }
                    clear() {
                        for (let e = 0; e < this.count; e++) this.elements[e] = null;
                        this.count = 0
                    }
                }
            },
            5886: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ObjectRenderer = class {
                    constructor(e) {
                        this.renderer = e
                    }
                    flush() {}
                    destroy() {
                        this.renderer = null
                    }
                    start() {}
                    stop() {
                        this.flush()
                    }
                    render(e) {}
                }
            },
            1299: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(6667);
                t.canUploadSameBuffer = function() {
                    return !i.isMobile.apple.device
                }
            },
            7641: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(6667);
                t.maxRecommendedTextures = function(e) {
                    let t = !0;
                    const r = i.settings.ADAPTER.getNavigator();
                    if (i.isMobile.tablet || i.isMobile.phone) {
                        if (i.isMobile.apple.device) {
                            const e = r.userAgent.match(/OS (\d+)_(\d+)?/);
                            e && parseInt(e[1], 10) < 11 && (t = !1)
                        }
                        if (i.isMobile.android.device) {
                            const e = r.userAgent.match(/Android\s([0-9.]*)/);
                            e && parseInt(e[1], 10) < 7 && (t = !1)
                        }
                    }
                    return t ? e : 4
                }
            },
            7321: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\nuniform sampler2D uSamplers[%count%];\n\nvoid main(void){\n    vec4 color;\n    %forloop%\n    gl_FragColor = color * vColor;\n}\n"
            },
            9800: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = aColor * tint;\n}\n"
            },
            4866: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(7222),
                    n = r(6667);
                let o = 0;
                class a {
                    constructor(e) {
                        this.renderer = e, this.webGLVersion = 1, this.extensions = {}, this.supports = {
                            uint32Indices: !1
                        }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this)
                    }
                    get isLost() {
                        return !this.gl || this.gl.isContextLost()
                    }
                    contextChange(e) {
                        this.gl = e, this.renderer.gl = e, this.renderer.CONTEXT_UID = o++
                    }
                    init(e) {
                        if (e.context) this.initFromContext(e.context);
                        else {
                            const t = this.renderer.background.alpha < 1,
                                r = e.premultipliedAlpha;
                            this.preserveDrawingBuffer = e.preserveDrawingBuffer, this.useContextAlpha = e.useContextAlpha, this.powerPreference = e.powerPreference, this.initFromOptions({
                                alpha: t,
                                premultipliedAlpha: r,
                                antialias: e.antialias,
                                stencil: !0,
                                preserveDrawingBuffer: e.preserveDrawingBuffer,
                                powerPreference: e.powerPreference
                            })
                        }
                    }
                    initFromContext(e) {
                        this.gl = e, this.validateContext(e), this.renderer.gl = e, this.renderer.CONTEXT_UID = o++, this.renderer.runners.contextChange.emit(e);
                        const t = this.renderer.view;
                        void 0 !== t.addEventListener && (t.addEventListener("webglcontextlost", this.handleContextLost, !1), t.addEventListener("webglcontextrestored", this.handleContextRestored, !1))
                    }
                    initFromOptions(e) {
                        const t = this.createContext(this.renderer.view, e);
                        this.initFromContext(t)
                    }
                    createContext(e, t) {
                        let r;
                        if (n.settings.PREFER_ENV >= i.ENV.WEBGL2 && (r = e.getContext("webgl2", t)), r) this.webGLVersion = 2;
                        else if (this.webGLVersion = 1, r = e.getContext("webgl", t) || e.getContext("experimental-webgl", t), !r) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
                        return this.gl = r, this.getExtensions(), this.gl
                    }
                    getExtensions() {
                        const {
                            gl: e
                        } = this, t = {
                            loseContext: e.getExtension("WEBGL_lose_context"),
                            anisotropicFiltering: e.getExtension("EXT_texture_filter_anisotropic"),
                            floatTextureLinear: e.getExtension("OES_texture_float_linear"),
                            s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
                            s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
                            etc: e.getExtension("WEBGL_compressed_texture_etc"),
                            etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
                            pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                            atc: e.getExtension("WEBGL_compressed_texture_atc"),
                            astc: e.getExtension("WEBGL_compressed_texture_astc")
                        };
                        1 === this.webGLVersion ? Object.assign(this.extensions, t, {
                            drawBuffers: e.getExtension("WEBGL_draw_buffers"),
                            depthTexture: e.getExtension("WEBGL_depth_texture"),
                            vertexArrayObject: e.getExtension("OES_vertex_array_object") || e.getExtension("MOZ_OES_vertex_array_object") || e.getExtension("WEBKIT_OES_vertex_array_object"),
                            uint32ElementIndex: e.getExtension("OES_element_index_uint"),
                            floatTexture: e.getExtension("OES_texture_float"),
                            floatTextureLinear: e.getExtension("OES_texture_float_linear"),
                            textureHalfFloat: e.getExtension("OES_texture_half_float"),
                            textureHalfFloatLinear: e.getExtension("OES_texture_half_float_linear")
                        }) : 2 === this.webGLVersion && Object.assign(this.extensions, t, {
                            colorBufferFloat: e.getExtension("EXT_color_buffer_float")
                        })
                    }
                    handleContextLost(e) {
                        e.preventDefault(), setTimeout((() => {
                            this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext()
                        }), 0)
                    }
                    handleContextRestored() {
                        this.renderer.runners.contextChange.emit(this.gl)
                    }
                    destroy() {
                        const e = this.renderer.view;
                        this.renderer = null, void 0 !== e.removeEventListener && (e.removeEventListener("webglcontextlost", this.handleContextLost), e.removeEventListener("webglcontextrestored", this.handleContextRestored)), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext()
                    }
                    postrender() {
                        this.renderer.objectRenderer.renderingToScreen && this.gl.flush()
                    }
                    validateContext(e) {
                        const t = e.getContextAttributes(),
                            r = "WebGL2RenderingContext" in globalThis && e instanceof globalThis.WebGL2RenderingContext;
                        r && (this.webGLVersion = 2), t && !t.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
                        const i = r || !!e.getExtension("OES_element_index_uint");
                        this.supports.uint32Indices = i, i || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly")
                    }
                }
                a.defaultOptions = {
                    context: null,
                    antialias: !1,
                    premultipliedAlpha: !0,
                    preserveDrawingBuffer: !1,
                    powerPreference: "default"
                }, a.extension = {
                    type: s.ExtensionType.RendererSystem,
                    name: "context"
                }, s.extensions.add(a), t.ContextSystem = a
            },
            6153: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(7685),
                    n = r(510),
                    o = r(8303),
                    a = r(4112),
                    h = r(5093);
                const l = class extends n.Shader {
                    constructor(e, t, r) {
                        super(s.Program.from(e || l.defaultVertexSrc, t || l.defaultFragmentSrc), r), this.padding = 0, this.resolution = l.defaultResolution, this.multisample = l.defaultMultisample, this.enabled = !0, this.autoFit = !0, this.state = new o.State
                    }
                    apply(e, t, r, i, s) {
                        e.applyFilter(this, t, r, i)
                    }
                    get blendMode() {
                        return this.state.blendMode
                    }
                    set blendMode(e) {
                        this.state.blendMode = e
                    }
                    get resolution() {
                        return this._resolution
                    }
                    set resolution(e) {
                        this._resolution = e
                    }
                    static get defaultVertexSrc() {
                        return h.default
                    }
                    static get defaultFragmentSrc() {
                        return a.default
                    }
                };
                let u = l;
                u.defaultResolution = 1, u.defaultMultisample = i.MSAA_QUALITY.NONE, t.Filter = u
            },
            3422: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(8153);
                t.FilterState = class {
                    constructor() {
                        this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = i.MSAA_QUALITY.NONE, this.sourceFrame = new s.Rectangle, this.destinationFrame = new s.Rectangle, this.bindingSourceFrame = new s.Rectangle, this.bindingDestinationFrame = new s.Rectangle, this.filters = [], this.transform = null
                    }
                    clear() {
                        this.target = null, this.filters = null, this.renderTexture = null
                    }
                }
            },
            4659: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(7222),
                    n = r(8153),
                    o = r(8184),
                    a = r(4353),
                    h = r(1257),
                    l = r(8804),
                    u = r(3422);
                const c = [new n.Point, new n.Point, new n.Point, new n.Point],
                    d = new n.Matrix;
                class p {
                    constructor(e) {
                        this.renderer = e, this.defaultFilterStack = [{}], this.texturePool = new o.RenderTexturePool, this.statePool = [], this.quad = new h.Quad, this.quadUv = new l.QuadUv, this.tempRect = new n.Rectangle, this.activeState = {}, this.globalUniforms = new a.UniformGroup({
                            outputFrame: new n.Rectangle,
                            inputSize: new Float32Array(4),
                            inputPixel: new Float32Array(4),
                            inputClamp: new Float32Array(4),
                            resolution: 1,
                            filterArea: new Float32Array(4),
                            filterClamp: new Float32Array(4)
                        }, !0), this.forceClear = !1, this.useMaxPadding = !1
                    }
                    init() {
                        this.texturePool.setScreenSize(this.renderer.view)
                    }
                    push(e, t) {
                        const r = this.renderer,
                            i = this.defaultFilterStack,
                            s = this.statePool.pop() || new u.FilterState,
                            n = this.renderer.renderTexture;
                        let o = t[0].resolution,
                            a = t[0].multisample,
                            h = t[0].padding,
                            l = t[0].autoFit,
                            c = t[0].legacy ?? !0;
                        for (let e = 1; e < t.length; e++) {
                            const r = t[e];
                            o = Math.min(o, r.resolution), a = Math.min(a, r.multisample), h = this.useMaxPadding ? Math.max(h, r.padding) : h + r.padding, l = l && r.autoFit, c = c || (r.legacy ?? !0)
                        }
                        1 === i.length && (this.defaultFilterStack[0].renderTexture = n.current), i.push(s), s.resolution = o, s.multisample = a, s.legacy = c, s.target = e, s.sourceFrame.copyFrom(e.filterArea || e.getBounds(!0)), s.sourceFrame.pad(h);
                        const p = this.tempRect.copyFrom(n.sourceFrame);
                        r.projection.transform && this.transformAABB(d.copyFrom(r.projection.transform).invert(), p), l ? (s.sourceFrame.fit(p), (s.sourceFrame.width <= 0 || s.sourceFrame.height <= 0) && (s.sourceFrame.width = 0, s.sourceFrame.height = 0)) : s.sourceFrame.intersects(p) || (s.sourceFrame.width = 0, s.sourceFrame.height = 0), this.roundFrame(s.sourceFrame, n.current ? n.current.resolution : r.resolution, n.sourceFrame, n.destinationFrame, r.projection.transform), s.renderTexture = this.getOptimalFilterTexture(s.sourceFrame.width, s.sourceFrame.height, o, a), s.filters = t, s.destinationFrame.width = s.renderTexture.width, s.destinationFrame.height = s.renderTexture.height;
                        const f = this.tempRect;
                        f.x = 0, f.y = 0, f.width = s.sourceFrame.width, f.height = s.sourceFrame.height, s.renderTexture.filterFrame = s.sourceFrame, s.bindingSourceFrame.copyFrom(n.sourceFrame), s.bindingDestinationFrame.copyFrom(n.destinationFrame), s.transform = r.projection.transform, r.projection.transform = null, n.bind(s.renderTexture, s.sourceFrame, f), r.framebuffer.clear(0, 0, 0, 0)
                    }
                    pop() {
                        const e = this.defaultFilterStack,
                            t = e.pop(),
                            r = t.filters;
                        this.activeState = t;
                        const s = this.globalUniforms.uniforms;
                        s.outputFrame = t.sourceFrame, s.resolution = t.resolution;
                        const n = s.inputSize,
                            o = s.inputPixel,
                            a = s.inputClamp;
                        if (n[0] = t.destinationFrame.width, n[1] = t.destinationFrame.height, n[2] = 1 / n[0], n[3] = 1 / n[1], o[0] = Math.round(n[0] * t.resolution), o[1] = Math.round(n[1] * t.resolution), o[2] = 1 / o[0], o[3] = 1 / o[1], a[0] = .5 * o[2], a[1] = .5 * o[3], a[2] = t.sourceFrame.width * n[2] - .5 * o[2], a[3] = t.sourceFrame.height * n[3] - .5 * o[3], t.legacy) {
                            const e = s.filterArea;
                            e[0] = t.destinationFrame.width, e[1] = t.destinationFrame.height, e[2] = t.sourceFrame.x, e[3] = t.sourceFrame.y, s.filterClamp = s.inputClamp
                        }
                        this.globalUniforms.update();
                        const h = e[e.length - 1];
                        if (this.renderer.framebuffer.blit(), 1 === r.length) r[0].apply(this, t.renderTexture, h.renderTexture, i.CLEAR_MODES.BLEND, t), this.returnFilterTexture(t.renderTexture);
                        else {
                            let e = t.renderTexture,
                                s = this.getOptimalFilterTexture(e.width, e.height, t.resolution);
                            s.filterFrame = e.filterFrame;
                            let n = 0;
                            for (n = 0; n < r.length - 1; ++n) {
                                1 === n && t.multisample > 1 && (s = this.getOptimalFilterTexture(e.width, e.height, t.resolution), s.filterFrame = e.filterFrame), r[n].apply(this, e, s, i.CLEAR_MODES.CLEAR, t);
                                const o = e;
                                e = s, s = o
                            }
                            r[n].apply(this, e, h.renderTexture, i.CLEAR_MODES.BLEND, t), n > 1 && t.multisample > 1 && this.returnFilterTexture(t.renderTexture), this.returnFilterTexture(e), this.returnFilterTexture(s)
                        }
                        t.clear(), this.statePool.push(t)
                    }
                    bindAndClear(e, t = i.CLEAR_MODES.CLEAR) {
                        const {
                            renderTexture: r,
                            state: s
                        } = this.renderer;
                        if (e === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, e?.filterFrame) {
                            const t = this.tempRect;
                            t.x = 0, t.y = 0, t.width = e.filterFrame.width, t.height = e.filterFrame.height, r.bind(e, e.filterFrame, t)
                        } else e !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? r.bind(e) : this.renderer.renderTexture.bind(e, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
                        const n = 1 & s.stateId || this.forceClear;
                        (t === i.CLEAR_MODES.CLEAR || t === i.CLEAR_MODES.BLIT && n) && this.renderer.framebuffer.clear(0, 0, 0, 0)
                    }
                    applyFilter(e, t, r, s) {
                        const n = this.renderer;
                        n.state.set(e.state), this.bindAndClear(r, s), e.uniforms.uSampler = t, e.uniforms.filterGlobals = this.globalUniforms, n.shader.bind(e), e.legacy = !!e.program.attributeData.aTextureCoord, e.legacy ? (this.quadUv.map(t._frame, t.filterFrame), n.geometry.bind(this.quadUv), n.geometry.draw(i.DRAW_MODES.TRIANGLES)) : (n.geometry.bind(this.quad), n.geometry.draw(i.DRAW_MODES.TRIANGLE_STRIP))
                    }
                    calculateSpriteMatrix(e, t) {
                        const {
                            sourceFrame: r,
                            destinationFrame: i
                        } = this.activeState, {
                            orig: s
                        } = t._texture, o = e.set(i.width, 0, 0, i.height, r.x, r.y), a = t.worldTransform.copyTo(n.Matrix.TEMP_MATRIX);
                        return a.invert(), o.prepend(a), o.scale(1 / s.width, 1 / s.height), o.translate(t.anchor.x, t.anchor.y), o
                    }
                    destroy() {
                        this.renderer = null, this.texturePool.clear(!1)
                    }
                    getOptimalFilterTexture(e, t, r = 1, s = i.MSAA_QUALITY.NONE) {
                        return this.texturePool.getOptimalTexture(e, t, r, s)
                    }
                    getFilterTexture(e, t, r) {
                        if ("number" == typeof e) {
                            const r = e;
                            e = t, t = r
                        }
                        e = e || this.activeState.renderTexture;
                        const s = this.texturePool.getOptimalTexture(e.width, e.height, t || e.resolution, r || i.MSAA_QUALITY.NONE);
                        return s.filterFrame = e.filterFrame, s
                    }
                    returnFilterTexture(e) {
                        this.texturePool.returnTexture(e)
                    }
                    emptyPool() {
                        this.texturePool.clear(!0)
                    }
                    resize() {
                        this.texturePool.setScreenSize(this.renderer.view)
                    }
                    transformAABB(e, t) {
                        const r = c[0],
                            i = c[1],
                            s = c[2],
                            n = c[3];
                        r.set(t.left, t.top), i.set(t.left, t.bottom), s.set(t.right, t.top), n.set(t.right, t.bottom), e.apply(r, r), e.apply(i, i), e.apply(s, s), e.apply(n, n);
                        const o = Math.min(r.x, i.x, s.x, n.x),
                            a = Math.min(r.y, i.y, s.y, n.y),
                            h = Math.max(r.x, i.x, s.x, n.x),
                            l = Math.max(r.y, i.y, s.y, n.y);
                        t.x = o, t.y = a, t.width = h - o, t.height = l - a
                    }
                    roundFrame(e, t, r, i, s) {
                        if (!(e.width <= 0 || e.height <= 0 || r.width <= 0 || r.height <= 0)) {
                            if (s) {
                                const {
                                    a: e,
                                    b: t,
                                    c: r,
                                    d: i
                                } = s;
                                if ((Math.abs(t) > 1e-4 || Math.abs(r) > 1e-4) && (Math.abs(e) > 1e-4 || Math.abs(i) > 1e-4)) return
                            }(s = s ? d.copyFrom(s) : d.identity()).translate(-r.x, -r.y).scale(i.width / r.width, i.height / r.height).translate(i.x, i.y), this.transformAABB(s, e), e.ceil(t), this.transformAABB(s.invert(), e)
                        }
                    }
                }
                p.extension = {
                    type: s.ExtensionType.RendererSystem,
                    name: "filter"
                }, s.extensions.add(p), t.FilterSystem = p
            },
            8559: () => {},
            4112: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n"
            },
            5093: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n"
            },
            4007: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(8153),
                    s = r(1826),
                    n = r(6153),
                    o = r(5673),
                    a = r(9929);
                class h extends n.Filter {
                    constructor(e, t, r) {
                        let s = null;
                        "string" != typeof e && void 0 === t && void 0 === r && (s = e, e = void 0, t = void 0, r = void 0), super(e || a.default, t || o.default, r), this.maskSprite = s, this.maskMatrix = new i.Matrix
                    }
                    get maskSprite() {
                        return this._maskSprite
                    }
                    set maskSprite(e) {
                        this._maskSprite = e, this._maskSprite && (this._maskSprite.renderable = !1)
                    }
                    apply(e, t, r, i) {
                        const n = this._maskSprite,
                            o = n._texture;
                        o.valid && (o.uvMatrix || (o.uvMatrix = new s.TextureMatrix(o, 0)), o.uvMatrix.update(), this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o, this.uniforms.otherMatrix = e.calculateSpriteMatrix(this.maskMatrix, n).prepend(o.uvMatrix.mapCoord), this.uniforms.alpha = n.worldAlpha, this.uniforms.maskClamp = o.uvMatrix.uClampFrame, e.applyFilter(this, t, r, i))
                    }
                }
                t.SpriteMaskFilter = h
            },
            5673: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform sampler2D mask;\nuniform float alpha;\nuniform float npmAlpha;\nuniform vec4 maskClamp;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(maskClamp.x, vMaskCoord.x) +\n        step(maskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, maskClamp.z) +\n        step(vMaskCoord.y, maskClamp.w));\n\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * alpha * clip);\n\n    gl_FragColor = original;\n}\n"
            },
            9929: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n"
            },
            5349: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}"
            },
            9409: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n"
            },
            8970: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(5349),
                    s = r(9409);
                const n = i.default,
                    o = s.default;
                t.defaultFilterVertex = o, t.defaultVertex = n
            },
            8343: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(5802),
                    n = r(4291),
                    o = r(6200);
                t.Framebuffer = class {
                    constructor(e, t) {
                        this.width = Math.round(e || 100), this.height = Math.round(t || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new s.Runner("disposeFramebuffer"), this.multisample = i.MSAA_QUALITY.NONE
                    }
                    get colorTexture() {
                        return this.colorTextures[0]
                    }
                    addColorTexture(e = 0, t) {
                        return this.colorTextures[e] = t || new n.BaseTexture(null, {
                            scaleMode: i.SCALE_MODES.NEAREST,
                            resolution: 1,
                            mipmap: i.MIPMAP_MODES.OFF,
                            width: this.width,
                            height: this.height
                        }), this.dirtyId++, this.dirtyFormat++, this
                    }
                    addDepthTexture(e) {
                        return this.depthTexture = e || new n.BaseTexture(new o.DepthResource(null, {
                            width: this.width,
                            height: this.height
                        }), {
                            scaleMode: i.SCALE_MODES.NEAREST,
                            resolution: 1,
                            width: this.width,
                            height: this.height,
                            mipmap: i.MIPMAP_MODES.OFF,
                            format: i.FORMATS.DEPTH_COMPONENT,
                            type: i.TYPES.UNSIGNED_SHORT
                        }), this.dirtyId++, this.dirtyFormat++, this
                    }
                    enableDepth() {
                        return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this
                    }
                    enableStencil() {
                        return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this
                    }
                    resize(e, t) {
                        if (e = Math.round(e), t = Math.round(t), e !== this.width || t !== this.height) {
                            this.width = e, this.height = t, this.dirtyId++, this.dirtySize++;
                            for (let r = 0; r < this.colorTextures.length; r++) {
                                const i = this.colorTextures[r],
                                    s = i.resolution;
                                i.setSize(e / s, t / s)
                            }
                            if (this.depthTexture) {
                                const r = this.depthTexture.resolution;
                                this.depthTexture.setSize(e / r, t / r)
                            }
                        }
                    }
                    dispose() {
                        this.disposeRunner.emit(this, !1)
                    }
                    destroyDepthTexture() {
                        this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat)
                    }
                }
            },
            896: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(7222),
                    n = r(8153),
                    o = r(6667),
                    a = r(8343),
                    h = r(8541);
                const l = new n.Rectangle;
                class u {
                    constructor(e) {
                        this.renderer = e, this.managedFramebuffers = [], this.unknownFramebuffer = new a.Framebuffer(10, 10), this.msaaSamples = null
                    }
                    contextChange() {
                        this.disposeAll(!0);
                        const e = this.gl = this.renderer.gl;
                        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new n.Rectangle, this.hasMRT = !0, this.writeDepthTexture = !0, 1 === this.renderer.context.webGLVersion) {
                            let t = this.renderer.context.extensions.drawBuffers,
                                r = this.renderer.context.extensions.depthTexture;
                            o.settings.PREFER_ENV === i.ENV.WEBGL_LEGACY && (t = null, r = null), t ? e.drawBuffers = e => t.drawBuffersWEBGL(e) : (this.hasMRT = !1, e.drawBuffers = () => {}), r || (this.writeDepthTexture = !1)
                        } else this.msaaSamples = e.getInternalformatParameter(e.RENDERBUFFER, e.RGBA8, e.SAMPLES)
                    }
                    bind(e, t, r = 0) {
                        const {
                            gl: i
                        } = this;
                        if (e) {
                            const s = e.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(e);
                            this.current !== e && (this.current = e, i.bindFramebuffer(i.FRAMEBUFFER, s.framebuffer)), s.mipLevel !== r && (e.dirtyId++, e.dirtyFormat++, s.mipLevel = r), s.dirtyId !== e.dirtyId && (s.dirtyId = e.dirtyId, s.dirtyFormat !== e.dirtyFormat ? (s.dirtyFormat = e.dirtyFormat, s.dirtySize = e.dirtySize, this.updateFramebuffer(e, r)) : s.dirtySize !== e.dirtySize && (s.dirtySize = e.dirtySize, this.resizeFramebuffer(e)));
                            for (let t = 0; t < e.colorTextures.length; t++) {
                                const r = e.colorTextures[t];
                                this.renderer.texture.unbind(r.parentTextureArray || r)
                            }
                            if (e.depthTexture && this.renderer.texture.unbind(e.depthTexture), t) {
                                const e = t.width >> r,
                                    i = t.height >> r,
                                    s = e / t.width;
                                this.setViewport(t.x * s, t.y * s, e, i)
                            } else {
                                const t = e.width >> r,
                                    i = e.height >> r;
                                this.setViewport(0, 0, t, i)
                            }
                        } else this.current && (this.current = null, i.bindFramebuffer(i.FRAMEBUFFER, null)), t ? this.setViewport(t.x, t.y, t.width, t.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height)
                    }
                    setViewport(e, t, r, i) {
                        const s = this.viewport;
                        e = Math.round(e), t = Math.round(t), r = Math.round(r), i = Math.round(i), s.width === r && s.height === i && s.x === e && s.y === t || (s.x = e, s.y = t, s.width = r, s.height = i, this.gl.viewport(e, t, r, i))
                    }
                    get size() {
                        return this.current ? {
                            x: 0,
                            y: 0,
                            width: this.current.width,
                            height: this.current.height
                        } : {
                            x: 0,
                            y: 0,
                            width: this.renderer.width,
                            height: this.renderer.height
                        }
                    }
                    clear(e, t, r, s, n = i.BUFFER_BITS.COLOR | i.BUFFER_BITS.DEPTH) {
                        const {
                            gl: o
                        } = this;
                        o.clearColor(e, t, r, s), o.clear(n)
                    }
                    initFramebuffer(e) {
                        const {
                            gl: t
                        } = this, r = new h.GLFramebuffer(t.createFramebuffer());
                        return r.multisample = this.detectSamples(e.multisample), e.glFramebuffers[this.CONTEXT_UID] = r, this.managedFramebuffers.push(e), e.disposeRunner.add(this), r
                    }
                    resizeFramebuffer(e) {
                        const {
                            gl: t
                        } = this, r = e.glFramebuffers[this.CONTEXT_UID];
                        r.stencil && (t.bindRenderbuffer(t.RENDERBUFFER, r.stencil), r.msaaBuffer ? t.renderbufferStorageMultisample(t.RENDERBUFFER, r.multisample, t.DEPTH24_STENCIL8, e.width, e.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, e.width, e.height));
                        const i = e.colorTextures;
                        let s = i.length;
                        t.drawBuffers || (s = Math.min(s, 1));
                        for (let n = 0; n < s; n++) {
                            const s = i[n],
                                o = s.parentTextureArray || s;
                            this.renderer.texture.bind(o, 0), 0 === n && r.msaaBuffer && (t.bindRenderbuffer(t.RENDERBUFFER, r.msaaBuffer), t.renderbufferStorageMultisample(t.RENDERBUFFER, r.multisample, o._glTextures[this.CONTEXT_UID].internalFormat, e.width, e.height))
                        }
                        e.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(e.depthTexture, 0)
                    }
                    updateFramebuffer(e, t) {
                        const {
                            gl: r
                        } = this, i = e.glFramebuffers[this.CONTEXT_UID], s = e.colorTextures;
                        let n = s.length;
                        r.drawBuffers || (n = Math.min(n, 1)), i.multisample > 1 && this.canMultisampleFramebuffer(e) ? i.msaaBuffer = i.msaaBuffer || r.createRenderbuffer() : i.msaaBuffer && (r.deleteRenderbuffer(i.msaaBuffer), i.msaaBuffer = null, i.blitFramebuffer && (i.blitFramebuffer.dispose(), i.blitFramebuffer = null));
                        const o = [];
                        for (let a = 0; a < n; a++) {
                            const n = s[a],
                                h = n.parentTextureArray || n;
                            this.renderer.texture.bind(h, 0), 0 === a && i.msaaBuffer ? (r.bindRenderbuffer(r.RENDERBUFFER, i.msaaBuffer), r.renderbufferStorageMultisample(r.RENDERBUFFER, i.multisample, h._glTextures[this.CONTEXT_UID].internalFormat, e.width, e.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, i.msaaBuffer)) : (r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + a, n.target, h._glTextures[this.CONTEXT_UID].texture, t), o.push(r.COLOR_ATTACHMENT0 + a))
                        }
                        if (o.length > 1 && r.drawBuffers(o), e.depthTexture && this.writeDepthTexture) {
                            const i = e.depthTexture;
                            this.renderer.texture.bind(i, 0), r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, i._glTextures[this.CONTEXT_UID].texture, t)
                        }!e.stencil && !e.depth || e.depthTexture && this.writeDepthTexture ? i.stencil && (r.deleteRenderbuffer(i.stencil), i.stencil = null) : (i.stencil = i.stencil || r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, i.stencil), i.msaaBuffer ? r.renderbufferStorageMultisample(r.RENDERBUFFER, i.multisample, r.DEPTH24_STENCIL8, e.width, e.height) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, e.width, e.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, i.stencil))
                    }
                    canMultisampleFramebuffer(e) {
                        return 1 !== this.renderer.context.webGLVersion && e.colorTextures.length <= 1 && !e.depthTexture
                    }
                    detectSamples(e) {
                        const {
                            msaaSamples: t
                        } = this;
                        let r = i.MSAA_QUALITY.NONE;
                        if (e <= 1 || null === t) return r;
                        for (let i = 0; i < t.length; i++)
                            if (t[i] <= e) {
                                r = t[i];
                                break
                            } return 1 === r && (r = i.MSAA_QUALITY.NONE), r
                    }
                    blit(e, t, r) {
                        const {
                            current: i,
                            renderer: s,
                            gl: n,
                            CONTEXT_UID: o
                        } = this;
                        if (2 !== s.context.webGLVersion) return;
                        if (!i) return;
                        const h = i.glFramebuffers[o];
                        if (!h) return;
                        if (!e) {
                            if (!h.msaaBuffer) return;
                            const t = i.colorTextures[0];
                            if (!t) return;
                            h.blitFramebuffer || (h.blitFramebuffer = new a.Framebuffer(i.width, i.height), h.blitFramebuffer.addColorTexture(0, t)), (e = h.blitFramebuffer).colorTextures[0] !== t && (e.colorTextures[0] = t, e.dirtyId++, e.dirtyFormat++), e.width === i.width && e.height === i.height || (e.width = i.width, e.height = i.height, e.dirtyId++, e.dirtySize++)
                        }
                        t || ((t = l).width = i.width, t.height = i.height), r || (r = t);
                        const u = t.width === r.width && t.height === r.height;
                        this.bind(e), n.bindFramebuffer(n.READ_FRAMEBUFFER, h.framebuffer), n.blitFramebuffer(t.left, t.top, t.right, t.bottom, r.left, r.top, r.right, r.bottom, n.COLOR_BUFFER_BIT, u ? n.NEAREST : n.LINEAR)
                    }
                    disposeFramebuffer(e, t) {
                        const r = e.glFramebuffers[this.CONTEXT_UID],
                            i = this.gl;
                        if (!r) return;
                        delete e.glFramebuffers[this.CONTEXT_UID];
                        const s = this.managedFramebuffers.indexOf(e);
                        s >= 0 && this.managedFramebuffers.splice(s, 1), e.disposeRunner.remove(this), t || (i.deleteFramebuffer(r.framebuffer), r.msaaBuffer && i.deleteRenderbuffer(r.msaaBuffer), r.stencil && i.deleteRenderbuffer(r.stencil)), r.blitFramebuffer && this.disposeFramebuffer(r.blitFramebuffer, t)
                    }
                    disposeAll(e) {
                        const t = this.managedFramebuffers;
                        this.managedFramebuffers = [];
                        for (let r = 0; r < t.length; r++) this.disposeFramebuffer(t[r], e)
                    }
                    forceStencil() {
                        const e = this.current;
                        if (!e) return;
                        const t = e.glFramebuffers[this.CONTEXT_UID];
                        if (!t || t.stencil) return;
                        e.stencil = !0;
                        const r = e.width,
                            i = e.height,
                            s = this.gl,
                            n = s.createRenderbuffer();
                        s.bindRenderbuffer(s.RENDERBUFFER, n), t.msaaBuffer ? s.renderbufferStorageMultisample(s.RENDERBUFFER, t.multisample, s.DEPTH24_STENCIL8, r, i) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, r, i), t.stencil = n, s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, n)
                    }
                    reset() {
                        this.current = this.unknownFramebuffer, this.viewport = new n.Rectangle
                    }
                    destroy() {
                        this.renderer = null
                    }
                }
                u.extension = {
                    type: s.ExtensionType.RendererSystem,
                    name: "framebuffer"
                }, s.extensions.add(u), t.FramebufferSystem = u
            },
            8541: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386);
                t.GLFramebuffer = class {
                    constructor(e) {
                        this.framebuffer = e, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = i.MSAA_QUALITY.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0
                    }
                }
            },
            8957: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(7222);
                class n {
                    constructor(e) {
                        this.renderer = e
                    }
                    contextChange(e) {
                        let t;
                        if (1 === this.renderer.context.webGLVersion) {
                            const r = e.getParameter(e.FRAMEBUFFER_BINDING);
                            e.bindFramebuffer(e.FRAMEBUFFER, null), t = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.FRAMEBUFFER, r)
                        } else {
                            const r = e.getParameter(e.DRAW_FRAMEBUFFER_BINDING);
                            e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), t = e.getParameter(e.SAMPLES), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, r)
                        }
                        t >= i.MSAA_QUALITY.HIGH ? this.multisample = i.MSAA_QUALITY.HIGH : t >= i.MSAA_QUALITY.MEDIUM ? this.multisample = i.MSAA_QUALITY.MEDIUM : t >= i.MSAA_QUALITY.LOW ? this.multisample = i.MSAA_QUALITY.LOW : this.multisample = i.MSAA_QUALITY.NONE
                    }
                    destroy() {}
                }
                n.extension = {
                    type: s.ExtensionType.RendererSystem,
                    name: "_multisample"
                }, s.extensions.add(n), t.MultisampleSystem = n
            },
            6671: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386);
                class s {
                    constructor(e, t = 0, r = !1, s = i.TYPES.FLOAT, n, o, a, h = 1) {
                        this.buffer = e, this.size = t, this.normalized = r, this.type = s, this.stride = n, this.start = o, this.instance = a, this.divisor = h
                    }
                    destroy() {
                        this.buffer = null
                    }
                    static from(e, t, r, i, n) {
                        return new s(e, t, r, i, n)
                    }
                }
                t.Attribute = s
            },
            9202: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(5802);
                let n = 0;
                class o {
                    constructor(e, t = !0, r = !1) {
                        this.data = e || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = r, this.static = t, this.id = n++, this.disposeRunner = new s.Runner("disposeBuffer")
                    }
                    update(e) {
                        e instanceof Array && (e = new Float32Array(e)), this.data = e || this.data, this._updateID++
                    }
                    dispose() {
                        this.disposeRunner.emit(this, !1)
                    }
                    destroy() {
                        this.dispose(), this.data = null
                    }
                    set index(e) {
                        this.type = e ? i.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : i.BUFFER_TYPE.ARRAY_BUFFER
                    }
                    get index() {
                        return this.type === i.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER
                    }
                    static from(e) {
                        return e instanceof Array && (e = new Float32Array(e)), new o(e)
                    }
                }
                t.Buffer = o
            },
            6490: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7222),
                    s = r(5492);
                class n {
                    constructor(e) {
                        this.renderer = e, this.managedBuffers = {}, this.boundBufferBases = {}
                    }
                    destroy() {
                        this.renderer = null
                    }
                    contextChange() {
                        this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID
                    }
                    bind(e) {
                        const {
                            gl: t,
                            CONTEXT_UID: r
                        } = this, i = e._glBuffers[r] || this.createGLBuffer(e);
                        t.bindBuffer(e.type, i.buffer)
                    }
                    unbind(e) {
                        const {
                            gl: t
                        } = this;
                        t.bindBuffer(e, null)
                    }
                    bindBufferBase(e, t) {
                        const {
                            gl: r,
                            CONTEXT_UID: i
                        } = this;
                        if (this.boundBufferBases[t] !== e) {
                            const s = e._glBuffers[i] || this.createGLBuffer(e);
                            this.boundBufferBases[t] = e, r.bindBufferBase(r.UNIFORM_BUFFER, t, s.buffer)
                        }
                    }
                    bindBufferRange(e, t, r) {
                        const {
                            gl: i,
                            CONTEXT_UID: s
                        } = this;
                        r = r || 0;
                        const n = e._glBuffers[s] || this.createGLBuffer(e);
                        i.bindBufferRange(i.UNIFORM_BUFFER, t || 0, n.buffer, 256 * r, 256)
                    }
                    update(e) {
                        const {
                            gl: t,
                            CONTEXT_UID: r
                        } = this, i = e._glBuffers[r] || this.createGLBuffer(e);
                        if (e._updateID !== i.updateID)
                            if (i.updateID = e._updateID, t.bindBuffer(e.type, i.buffer), i.byteLength >= e.data.byteLength) t.bufferSubData(e.type, 0, e.data);
                            else {
                                const r = e.static ? t.STATIC_DRAW : t.DYNAMIC_DRAW;
                                i.byteLength = e.data.byteLength, t.bufferData(e.type, e.data, r)
                            }
                    }
                    dispose(e, t) {
                        if (!this.managedBuffers[e.id]) return;
                        delete this.managedBuffers[e.id];
                        const r = e._glBuffers[this.CONTEXT_UID],
                            i = this.gl;
                        e.disposeRunner.remove(this), r && (t || i.deleteBuffer(r.buffer), delete e._glBuffers[this.CONTEXT_UID])
                    }
                    disposeAll(e) {
                        const t = Object.keys(this.managedBuffers);
                        for (let r = 0; r < t.length; r++) this.dispose(this.managedBuffers[t[r]], e)
                    }
                    createGLBuffer(e) {
                        const {
                            CONTEXT_UID: t,
                            gl: r
                        } = this;
                        return e._glBuffers[t] = new s.GLBuffer(r.createBuffer()), this.managedBuffers[e.id] = e, e.disposeRunner.add(this), e._glBuffers[t]
                    }
                }
                n.extension = {
                    type: i.ExtensionType.RendererSystem,
                    name: "buffer"
                }, i.extensions.add(n), t.BufferSystem = n
            },
            5492: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.GLBuffer = class {
                    constructor(e) {
                        this.buffer = e || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0
                    }
                }
            },
            1990: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(5802),
                    n = r(6128),
                    o = r(6671),
                    a = r(9202),
                    h = r(6133);
                const l = {
                    5126: 4,
                    5123: 2,
                    5121: 1
                };
                let u = 0;
                const c = {
                    Float32Array,
                    Uint32Array,
                    Int32Array,
                    Uint8Array,
                    Uint16Array
                };
                class d {
                    constructor(e = [], t = {}) {
                        this.buffers = e, this.indexBuffer = null, this.attributes = t, this.glVertexArrayObjects = {}, this.id = u++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new s.Runner("disposeGeometry"), this.refCount = 0
                    }
                    addAttribute(e, t, r = 0, i = !1, s, n, h, l = !1) {
                        if (!t) throw new Error("You must pass a buffer when creating an attribute");
                        t instanceof a.Buffer || (t instanceof Array && (t = new Float32Array(t)), t = new a.Buffer(t));
                        const u = e.split("|");
                        if (u.length > 1) {
                            for (let e = 0; e < u.length; e++) this.addAttribute(u[e], t, r, i, s);
                            return this
                        }
                        let c = this.buffers.indexOf(t);
                        return -1 === c && (this.buffers.push(t), c = this.buffers.length - 1), this.attributes[e] = new o.Attribute(c, r, i, s, n, h, l), this.instanced = this.instanced || l, this
                    }
                    getAttribute(e) {
                        return this.attributes[e]
                    }
                    getBuffer(e) {
                        return this.buffers[this.getAttribute(e).buffer]
                    }
                    addIndex(e) {
                        return e instanceof a.Buffer || (e instanceof Array && (e = new Uint16Array(e)), e = new a.Buffer(e)), e.type = i.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER, this.indexBuffer = e, this.buffers.includes(e) || this.buffers.push(e), this
                    }
                    getIndex() {
                        return this.indexBuffer
                    }
                    interleave() {
                        if (1 === this.buffers.length || 2 === this.buffers.length && this.indexBuffer) return this;
                        const e = [],
                            t = [],
                            r = new a.Buffer;
                        let i;
                        for (i in this.attributes) {
                            const r = this.attributes[i],
                                s = this.buffers[r.buffer];
                            e.push(s.data), t.push(r.size * l[r.type] / 4), r.buffer = 0
                        }
                        for (r.data = h.interleaveTypedArrays(e, t), i = 0; i < this.buffers.length; i++) this.buffers[i] !== this.indexBuffer && this.buffers[i].destroy();
                        return this.buffers = [r], this.indexBuffer && this.buffers.push(this.indexBuffer), this
                    }
                    getSize() {
                        for (const e in this.attributes) {
                            const t = this.attributes[e];
                            return this.buffers[t.buffer].data.length / (t.stride / 4 || t.size)
                        }
                        return 0
                    }
                    dispose() {
                        this.disposeRunner.emit(this, !1)
                    }
                    destroy() {
                        this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null
                    }
                    clone() {
                        const e = new d;
                        for (let t = 0; t < this.buffers.length; t++) e.buffers[t] = new a.Buffer(this.buffers[t].data.slice(0));
                        for (const t in this.attributes) {
                            const r = this.attributes[t];
                            e.attributes[t] = new o.Attribute(r.buffer, r.size, r.normalized, r.type, r.stride, r.start, r.instance)
                        }
                        return this.indexBuffer && (e.indexBuffer = e.buffers[this.buffers.indexOf(this.indexBuffer)], e.indexBuffer.type = i.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER), e
                    }
                    static merge(e) {
                        const t = new d,
                            r = [],
                            s = [],
                            o = [];
                        let h;
                        for (let t = 0; t < e.length; t++) {
                            h = e[t];
                            for (let e = 0; e < h.buffers.length; e++) s[e] = s[e] || 0, s[e] += h.buffers[e].data.length, o[e] = 0
                        }
                        for (let e = 0; e < h.buffers.length; e++) r[e] = new(c[n.getBufferType(h.buffers[e].data)])(s[e]), t.buffers[e] = new a.Buffer(r[e]);
                        for (let t = 0; t < e.length; t++) {
                            h = e[t];
                            for (let e = 0; e < h.buffers.length; e++) r[e].set(h.buffers[e].data, o[e]), o[e] += h.buffers[e].data.length
                        }
                        if (t.attributes = h.attributes, h.indexBuffer) {
                            t.indexBuffer = t.buffers[h.buffers.indexOf(h.indexBuffer)], t.indexBuffer.type = i.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
                            let r = 0,
                                s = 0,
                                n = 0,
                                o = 0;
                            for (let e = 0; e < h.buffers.length; e++)
                                if (h.buffers[e] !== h.indexBuffer) {
                                    o = e;
                                    break
                                } for (const e in h.attributes) {
                                const t = h.attributes[e];
                                (0 | t.buffer) === o && (s += t.size * l[t.type] / 4)
                            }
                            for (let i = 0; i < e.length; i++) {
                                const a = e[i].indexBuffer.data;
                                for (let e = 0; e < a.length; e++) t.indexBuffer.data[e + n] += r;
                                r += e[i].buffers[o].data.length / s, n += a.length
                            }
                        }
                        return t
                    }
                }
                t.Geometry = d
            },
            1094: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(7222),
                    n = r(6667);
                const o = {
                    5126: 4,
                    5123: 2,
                    5121: 1
                };
                class a {
                    constructor(e) {
                        this.renderer = e, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {}
                    }
                    contextChange() {
                        this.disposeAll(!0);
                        const e = this.gl = this.renderer.gl,
                            t = this.renderer.context;
                        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, 2 !== t.webGLVersion) {
                            let t = this.renderer.context.extensions.vertexArrayObject;
                            n.settings.PREFER_ENV === i.ENV.WEBGL_LEGACY && (t = null), t ? (e.createVertexArray = () => t.createVertexArrayOES(), e.bindVertexArray = e => t.bindVertexArrayOES(e), e.deleteVertexArray = e => t.deleteVertexArrayOES(e)) : (this.hasVao = !1, e.createVertexArray = () => null, e.bindVertexArray = () => null, e.deleteVertexArray = () => null)
                        }
                        if (2 !== t.webGLVersion) {
                            const t = e.getExtension("ANGLE_instanced_arrays");
                            t ? (e.vertexAttribDivisor = (e, r) => t.vertexAttribDivisorANGLE(e, r), e.drawElementsInstanced = (e, r, i, s, n) => t.drawElementsInstancedANGLE(e, r, i, s, n), e.drawArraysInstanced = (e, r, i, s) => t.drawArraysInstancedANGLE(e, r, i, s)) : this.hasInstance = !1
                        }
                        this.canUseUInt32ElementIndex = 2 === t.webGLVersion || !!t.extensions.uint32ElementIndex
                    }
                    bind(e, t) {
                        t = t || this.renderer.shader.shader;
                        const {
                            gl: r
                        } = this;
                        let i = e.glVertexArrayObjects[this.CONTEXT_UID],
                            s = !1;
                        i || (this.managedGeometries[e.id] = e, e.disposeRunner.add(this), e.glVertexArrayObjects[this.CONTEXT_UID] = i = {}, s = !0);
                        const n = i[t.program.id] || this.initGeometryVao(e, t, s);
                        this._activeGeometry = e, this._activeVao !== n && (this._activeVao = n, this.hasVao ? r.bindVertexArray(n) : this.activateVao(e, t.program)), this.updateBuffers()
                    }
                    reset() {
                        this.unbind()
                    }
                    updateBuffers() {
                        const e = this._activeGeometry,
                            t = this.renderer.buffer;
                        for (let r = 0; r < e.buffers.length; r++) {
                            const i = e.buffers[r];
                            t.update(i)
                        }
                    }
                    checkCompatibility(e, t) {
                        const r = e.attributes,
                            i = t.attributeData;
                        for (const e in i)
                            if (!r[e]) throw new Error(`shader and geometry incompatible, geometry missing the "${e}" attribute`)
                    }
                    getSignature(e, t) {
                        const r = e.attributes,
                            i = t.attributeData,
                            s = ["g", e.id];
                        for (const e in r) i[e] && s.push(e, i[e].location);
                        return s.join("-")
                    }
                    initGeometryVao(e, t, r = !0) {
                        const s = this.gl,
                            n = this.CONTEXT_UID,
                            a = this.renderer.buffer,
                            h = t.program;
                        h.glPrograms[n] || this.renderer.shader.generateProgram(t), this.checkCompatibility(e, h);
                        const l = this.getSignature(e, h),
                            u = e.glVertexArrayObjects[this.CONTEXT_UID];
                        let c = u[l];
                        if (c) return u[h.id] = c, c;
                        const d = e.buffers,
                            p = e.attributes,
                            f = {},
                            m = {};
                        for (const e in d) f[e] = 0, m[e] = 0;
                        for (const e in p) !p[e].size && h.attributeData[e] ? p[e].size = h.attributeData[e].size : p[e].size || console.warn(`PIXI Geometry attribute '${e}' size cannot be determined (likely the bound shader does not have the attribute)`), f[p[e].buffer] += p[e].size * o[p[e].type];
                        for (const e in p) {
                            const t = p[e],
                                r = t.size;
                            void 0 === t.stride && (f[t.buffer] === r * o[t.type] ? t.stride = 0 : t.stride = f[t.buffer]), void 0 === t.start && (t.start = m[t.buffer], m[t.buffer] += r * o[t.type])
                        }
                        c = s.createVertexArray(), s.bindVertexArray(c);
                        for (let e = 0; e < d.length; e++) {
                            const t = d[e];
                            a.bind(t), r && t._glBuffers[n].refCount++
                        }
                        return this.activateVao(e, h), u[h.id] = c, u[l] = c, s.bindVertexArray(null), a.unbind(i.BUFFER_TYPE.ARRAY_BUFFER), c
                    }
                    disposeGeometry(e, t) {
                        if (!this.managedGeometries[e.id]) return;
                        delete this.managedGeometries[e.id];
                        const r = e.glVertexArrayObjects[this.CONTEXT_UID],
                            i = this.gl,
                            s = e.buffers,
                            n = this.renderer?.buffer;
                        if (e.disposeRunner.remove(this), r) {
                            if (n)
                                for (let e = 0; e < s.length; e++) {
                                    const r = s[e]._glBuffers[this.CONTEXT_UID];
                                    r && (r.refCount--, 0 !== r.refCount || t || n.dispose(s[e], t))
                                }
                            if (!t)
                                for (const e in r)
                                    if ("g" === e[0]) {
                                        const t = r[e];
                                        this._activeVao === t && this.unbind(), i.deleteVertexArray(t)
                                    } delete e.glVertexArrayObjects[this.CONTEXT_UID]
                        }
                    }
                    disposeAll(e) {
                        const t = Object.keys(this.managedGeometries);
                        for (let r = 0; r < t.length; r++) this.disposeGeometry(this.managedGeometries[t[r]], e)
                    }
                    activateVao(e, t) {
                        const r = this.gl,
                            i = this.CONTEXT_UID,
                            s = this.renderer.buffer,
                            n = e.buffers,
                            o = e.attributes;
                        e.indexBuffer && s.bind(e.indexBuffer);
                        let a = null;
                        for (const e in o) {
                            const h = o[e],
                                l = n[h.buffer],
                                u = l._glBuffers[i];
                            if (t.attributeData[e]) {
                                a !== u && (s.bind(l), a = u);
                                const i = t.attributeData[e].location;
                                if (r.enableVertexAttribArray(i), r.vertexAttribPointer(i, h.size, h.type || r.FLOAT, h.normalized, h.stride, h.start), h.instance) {
                                    if (!this.hasInstance) throw new Error("geometry error, GPU Instancing is not supported on this device");
                                    r.vertexAttribDivisor(i, h.divisor)
                                }
                            }
                        }
                    }
                    draw(e, t, r, i) {
                        const {
                            gl: s
                        } = this, n = this._activeGeometry;
                        if (n.indexBuffer) {
                            const o = n.indexBuffer.data.BYTES_PER_ELEMENT,
                                a = 2 === o ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;
                            2 === o || 4 === o && this.canUseUInt32ElementIndex ? n.instanced ? s.drawElementsInstanced(e, t || n.indexBuffer.data.length, a, (r || 0) * o, i || 1) : s.drawElements(e, t || n.indexBuffer.data.length, a, (r || 0) * o) : console.warn("unsupported index buffer type: uint32")
                        } else n.instanced ? s.drawArraysInstanced(e, r, t || n.getSize(), i || 1) : s.drawArrays(e, r, t || n.getSize());
                        return this
                    }
                    unbind() {
                        this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null
                    }
                    destroy() {
                        this.renderer = null
                    }
                }
                a.extension = {
                    type: s.ExtensionType.RendererSystem,
                    name: "geometry"
                }, s.extensions.add(a), t.GeometrySystem = a
            },
            5951: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.ViewableBuffer = class {
                    constructor(e) {
                        "number" == typeof e ? this.rawBinaryData = new ArrayBuffer(e) : e instanceof Uint8Array ? this.rawBinaryData = e.buffer : this.rawBinaryData = e, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData)
                    }
                    get int8View() {
                        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View
                    }
                    get uint8View() {
                        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View
                    }
                    get int16View() {
                        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View
                    }
                    get uint16View() {
                        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View
                    }
                    get int32View() {
                        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View
                    }
                    view(e) {
                        return this[`${e}View`]
                    }
                    destroy() {
                        this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null
                    }
                    static sizeOf(e) {
                        switch (e) {
                            case "int8":
                            case "uint8":
                                return 1;
                            case "int16":
                            case "uint16":
                                return 2;
                            case "int32":
                            case "uint32":
                            case "float32":
                                return 4;
                            default:
                                throw new Error(`${e} isn't a valid view type`)
                        }
                    }
                }
            },
            6133: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(6128);
                const s = {
                    Float32Array,
                    Uint32Array,
                    Int32Array,
                    Uint8Array
                };
                t.interleaveTypedArrays = function(e, t) {
                    let r = 0,
                        n = 0;
                    const o = {};
                    for (let i = 0; i < e.length; i++) n += t[i], r += e[i].length;
                    const a = new ArrayBuffer(4 * r);
                    let h = null,
                        l = 0;
                    for (let r = 0; r < e.length; r++) {
                        const u = t[r],
                            c = e[r],
                            d = i.getBufferType(c);
                        o[d] || (o[d] = new s[d](a)), h = o[d];
                        for (let e = 0; e < c.length; e++) h[(e / u | 0) * n + l + e % u] = c[e];
                        l += u
                    }
                    return new Float32Array(a)
                }
            },
            7163: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), r(4641);
                var i = r(2264),
                    s = r(2386),
                    n = r(7222),
                    o = r(8153),
                    a = r(5802),
                    h = r(6667),
                    l = r(6763),
                    u = r(6128),
                    c = r(2555),
                    d = r(3346),
                    p = r(8713),
                    f = r(1966),
                    m = r(7159),
                    g = r(3865),
                    y = r(9769),
                    _ = r(9120),
                    v = r(5886),
                    S = r(4866),
                    T = r(6153),
                    b = r(3422),
                    E = r(4659);
                r(8559);
                var x = r(4007),
                    w = r(8970),
                    O = r(8343),
                    A = r(896),
                    P = r(8541),
                    M = r(8957),
                    C = r(6671),
                    R = r(9202),
                    I = r(6490),
                    B = r(1990),
                    D = r(1094),
                    H = r(5951);
                r(178);
                var k = r(3820),
                    F = r(9871),
                    N = r(9204),
                    L = r(3884),
                    j = r(3039),
                    U = r(7278),
                    G = r(5926),
                    V = r(2564),
                    Y = r(9525),
                    z = r(5923),
                    W = r(5956),
                    X = r(8184),
                    K = r(4328),
                    $ = r(1949),
                    J = r(7685),
                    q = r(510),
                    Z = r(5879),
                    Q = r(4353),
                    ee = r(3576),
                    te = r(5084),
                    re = r(3601),
                    ie = r(6569),
                    se = r(9457),
                    ne = r(195),
                    oe = r(6608),
                    ae = r(8303),
                    he = r(1569);
                r(746), r(2138);
                var le = r(4291),
                    ue = r(4981);
                r(3582);
                var ce = r(733),
                    de = r(6037),
                    pe = r(1826),
                    fe = r(4584),
                    me = r(3144),
                    ge = r(9332),
                    ye = r(8200),
                    _e = r(1257),
                    ve = r(8804),
                    Se = r(153),
                    Te = r(4462),
                    be = r(2094),
                    Ee = r(3227),
                    xe = r(8566),
                    we = r(6869),
                    Oe = r(1857),
                    Ae = r(2297),
                    Pe = r(6946),
                    Me = r(1293),
                    Ce = r(6093),
                    Re = r(4211),
                    Ie = r(1346),
                    Be = r(7448);

                function De(e) {
                    if (e && e.__esModule) return e;
                    var t = Object.create(null);
                    return e && Object.keys(e).forEach((function(r) {
                        if ("default" !== r) {
                            var i = Object.getOwnPropertyDescriptor(e, r);
                            Object.defineProperty(t, r, i.get ? i : {
                                enumerable: !0,
                                get: function() {
                                    return e[r]
                                }
                            })
                        }
                    })), t.default = e, t
                }
                var He = De(u);
                t.utils = He, t.autoDetectRenderer = c.autoDetectRenderer, t.BackgroundSystem = d.BackgroundSystem, t.BatchDrawCall = p.BatchDrawCall, t.BatchGeometry = f.BatchGeometry, t.BatchRenderer = m.BatchRenderer, t.BatchShaderGenerator = g.BatchShaderGenerator, t.BatchSystem = y.BatchSystem, t.BatchTextureArray = _.BatchTextureArray, t.ObjectRenderer = v.ObjectRenderer, t.ContextSystem = S.ContextSystem, t.Filter = T.Filter, t.FilterState = b.FilterState, t.FilterSystem = E.FilterSystem, t.SpriteMaskFilter = x.SpriteMaskFilter, t.defaultFilterVertex = w.defaultFilterVertex, t.defaultVertex = w.defaultVertex, t.Framebuffer = O.Framebuffer, t.FramebufferSystem = A.FramebufferSystem, t.GLFramebuffer = P.GLFramebuffer, t.MultisampleSystem = M.MultisampleSystem, t.Attribute = C.Attribute, t.Buffer = R.Buffer, t.BufferSystem = I.BufferSystem, t.Geometry = B.Geometry, t.GeometrySystem = D.GeometrySystem, t.ViewableBuffer = H.ViewableBuffer, t.MaskData = k.MaskData, t.MaskSystem = F.MaskSystem, t.ScissorSystem = N.ScissorSystem, t.StencilSystem = L.StencilSystem, t.PluginSystem = j.PluginSystem, t.ProjectionSystem = U.ProjectionSystem, t.ObjectRendererSystem = G.ObjectRendererSystem, t.Renderer = V.Renderer, t.BaseRenderTexture = Y.BaseRenderTexture, t.GenerateTextureSystem = z.GenerateTextureSystem, t.RenderTexture = W.RenderTexture, t.RenderTexturePool = X.RenderTexturePool, t.RenderTextureSystem = K.RenderTextureSystem, t.GLProgram = $.GLProgram, t.IGLUniformData = $.IGLUniformData, t.Program = J.Program, t.Shader = q.Shader, t.ShaderSystem = Z.ShaderSystem, t.UniformGroup = Q.UniformGroup, t.checkMaxIfStatementsInShader = ee.checkMaxIfStatementsInShader, t.generateProgram = te.generateProgram, t.createUBOElements = re.createUBOElements, t.generateUniformBufferSync = re.generateUniformBufferSync, t.getUBOData = re.getUBOData, t.getTestContext = ie.getTestContext, t.uniformParsers = se.uniformParsers, t.unsafeEvalSupported = ne.unsafeEvalSupported, t.StartupSystem = oe.StartupSystem, t.State = ae.State, t.StateSystem = he.StateSystem, t.BaseTexture = le.BaseTexture, t.GLTexture = ue.GLTexture, t.Texture = ce.Texture, t.TextureGCSystem = de.TextureGCSystem, t.TextureMatrix = pe.TextureMatrix, t.TextureSystem = fe.TextureSystem, t.TextureUvs = me.TextureUvs, t.TransformFeedback = ge.TransformFeedback, t.TransformFeedbackSystem = ye.TransformFeedbackSystem, t.Quad = _e.Quad, t.QuadUv = ve.QuadUv, t.ViewSystem = Se.ViewSystem, t.SystemManager = Te.SystemManager, t.BaseImageResource = be.BaseImageResource, t.Resource = Ee.Resource, t.AbstractMultiResource = xe.AbstractMultiResource, t.ArrayResource = we.ArrayResource, t.INSTALLED = Oe.INSTALLED, t.autoDetectResource = Oe.autoDetectResource, t.BufferResource = Ae.BufferResource, t.CanvasResource = Pe.CanvasResource, t.CubeResource = Me.CubeResource, t.ImageBitmapResource = Ce.ImageBitmapResource, t.ImageResource = Re.ImageResource, t.SVGResource = Ie.SVGResource, t.VideoResource = Be.VideoResource, t.VERSION = "7.2.3", Object.keys(i).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return i[e]
                        }
                    })
                })), Object.keys(s).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return s[e]
                        }
                    })
                })), Object.keys(n).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return n[e]
                        }
                    })
                })), Object.keys(o).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return o[e]
                        }
                    })
                })), Object.keys(a).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return a[e]
                        }
                    })
                })), Object.keys(h).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return h[e]
                        }
                    })
                })), Object.keys(l).forEach((function(e) {
                    "default" === e || t.hasOwnProperty(e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: function() {
                            return l[e]
                        }
                    })
                }))
            },
            4971: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.AbstractMaskSystem = class {
                    constructor(e) {
                        this.renderer = e, this.maskStack = [], this.glConst = 0
                    }
                    getStackLength() {
                        return this.maskStack.length
                    }
                    setMaskStack(e) {
                        const {
                            gl: t
                        } = this.renderer, r = this.getStackLength();
                        this.maskStack = e;
                        const i = this.getStackLength();
                        i !== r && (0 === i ? t.disable(this.glConst) : (t.enable(this.glConst), this._useCurrent()))
                    }
                    _useCurrent() {}
                    destroy() {
                        this.renderer = null, this.maskStack = null
                    }
                }
            },
            3820: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(6153);
                t.MaskData = class {
                    constructor(e = null) {
                        this.type = i.MASK_TYPES.NONE, this.autoDetect = !0, this.maskObject = e || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = s.Filter.defaultMultisample, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null
                    }
                    get filter() {
                        return this._filters ? this._filters[0] : null
                    }
                    set filter(e) {
                        e ? this._filters ? this._filters[0] = e : this._filters = [e] : this._filters = null
                    }
                    reset() {
                        this.pooled && (this.maskObject = null, this.type = i.MASK_TYPES.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null
                    }
                    copyCountersOrReset(e) {
                        e ? (this._stencilCounter = e._stencilCounter, this._scissorCounter = e._scissorCounter, this._scissorRect = e._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null)
                    }
                }
            },
            9871: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(7222),
                    n = r(4007),
                    o = r(3820);
                class a {
                    constructor(e) {
                        this.renderer = e, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0
                    }
                    setMaskStack(e) {
                        this.maskStack = e, this.renderer.scissor.setMaskStack(e), this.renderer.stencil.setMaskStack(e)
                    }
                    push(e, t) {
                        let r = t;
                        if (!r.isMaskData) {
                            const e = this.maskDataPool.pop() || new o.MaskData;
                            e.pooled = !0, e.maskObject = t, r = e
                        }
                        const s = 0 !== this.maskStack.length ? this.maskStack[this.maskStack.length - 1] : null;
                        if (r.copyCountersOrReset(s), r._colorMask = s ? s._colorMask : 15, r.autoDetect && this.detect(r), r._target = e, r.type !== i.MASK_TYPES.SPRITE && this.maskStack.push(r), r.enabled) switch (r.type) {
                            case i.MASK_TYPES.SCISSOR:
                                this.renderer.scissor.push(r);
                                break;
                            case i.MASK_TYPES.STENCIL:
                                this.renderer.stencil.push(r);
                                break;
                            case i.MASK_TYPES.SPRITE:
                                r.copyCountersOrReset(null), this.pushSpriteMask(r);
                                break;
                            case i.MASK_TYPES.COLOR:
                                this.pushColorMask(r)
                        }
                        r.type === i.MASK_TYPES.SPRITE && this.maskStack.push(r)
                    }
                    pop(e) {
                        const t = this.maskStack.pop();
                        if (t && t._target === e) {
                            if (t.enabled) switch (t.type) {
                                case i.MASK_TYPES.SCISSOR:
                                    this.renderer.scissor.pop(t);
                                    break;
                                case i.MASK_TYPES.STENCIL:
                                    this.renderer.stencil.pop(t.maskObject);
                                    break;
                                case i.MASK_TYPES.SPRITE:
                                    this.popSpriteMask(t);
                                    break;
                                case i.MASK_TYPES.COLOR:
                                    this.popColorMask(t)
                            }
                            if (t.reset(), t.pooled && this.maskDataPool.push(t), 0 !== this.maskStack.length) {
                                const e = this.maskStack[this.maskStack.length - 1];
                                e.type === i.MASK_TYPES.SPRITE && e._filters && (e._filters[0].maskSprite = e.maskObject)
                            }
                        }
                    }
                    detect(e) {
                        const t = e.maskObject;
                        t ? t.isSprite ? e.type = i.MASK_TYPES.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(e) ? e.type = i.MASK_TYPES.SCISSOR : e.type = i.MASK_TYPES.STENCIL : e.type = i.MASK_TYPES.COLOR
                    }
                    pushSpriteMask(e) {
                        const {
                            maskObject: t
                        } = e, r = e._target;
                        let i = e._filters;
                        i || (i = this.alphaMaskPool[this.alphaMaskIndex], i || (i = this.alphaMaskPool[this.alphaMaskIndex] = [new n.SpriteMaskFilter]));
                        const s = this.renderer,
                            o = s.renderTexture;
                        let a, h;
                        if (o.current) {
                            const t = o.current;
                            a = e.resolution || t.resolution, h = e.multisample ?? t.multisample
                        } else a = e.resolution || s.resolution, h = e.multisample ?? s.multisample;
                        i[0].resolution = a, i[0].multisample = h, i[0].maskSprite = t;
                        const l = r.filterArea;
                        r.filterArea = t.getBounds(!0), s.filter.push(r, i), r.filterArea = l, e._filters || this.alphaMaskIndex++
                    }
                    popSpriteMask(e) {
                        this.renderer.filter.pop(), e._filters ? e._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null)
                    }
                    pushColorMask(e) {
                        const t = e._colorMask,
                            r = e._colorMask = t & e.colorMask;
                        r !== t && this.renderer.gl.colorMask(0 != (1 & r), 0 != (2 & r), 0 != (4 & r), 0 != (8 & r))
                    }
                    popColorMask(e) {
                        const t = e._colorMask,
                            r = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
                        r !== t && this.renderer.gl.colorMask(0 != (1 & r), 0 != (2 & r), 0 != (4 & r), 0 != (8 & r))
                    }
                    destroy() {
                        this.renderer = null
                    }
                }
                a.extension = {
                    type: s.ExtensionType.RendererSystem,
                    name: "mask"
                }, s.extensions.add(a), t.MaskSystem = a
            },
            9204: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7222),
                    s = r(8153),
                    n = r(6667),
                    o = r(4971);
                const a = new s.Matrix,
                    h = [],
                    l = class extends o.AbstractMaskSystem {
                        constructor(e) {
                            super(e), this.glConst = n.settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST
                        }
                        getStackLength() {
                            const e = this.maskStack[this.maskStack.length - 1];
                            return e ? e._scissorCounter : 0
                        }
                        calcScissorRect(e) {
                            if (e._scissorRectLocal) return;
                            const t = e._scissorRect,
                                {
                                    maskObject: r
                                } = e,
                                {
                                    renderer: i
                                } = this,
                                n = i.renderTexture,
                                o = r.getBounds(!0, h.pop() ?? new s.Rectangle);
                            this.roundFrameToPixels(o, n.current ? n.current.resolution : i.resolution, n.sourceFrame, n.destinationFrame, i.projection.transform), t && o.fit(t), e._scissorRectLocal = o
                        }
                        static isMatrixRotated(e) {
                            if (!e) return !1;
                            const {
                                a: t,
                                b: r,
                                c: i,
                                d: s
                            } = e;
                            return (Math.abs(r) > 1e-4 || Math.abs(i) > 1e-4) && (Math.abs(t) > 1e-4 || Math.abs(s) > 1e-4)
                        }
                        testScissor(e) {
                            const {
                                maskObject: t
                            } = e;
                            if (!t.isFastRect || !t.isFastRect()) return !1;
                            if (l.isMatrixRotated(t.worldTransform)) return !1;
                            if (l.isMatrixRotated(this.renderer.projection.transform)) return !1;
                            this.calcScissorRect(e);
                            const r = e._scissorRectLocal;
                            return r.width > 0 && r.height > 0
                        }
                        roundFrameToPixels(e, t, r, i, s) {
                            l.isMatrixRotated(s) || ((s = s ? a.copyFrom(s) : a.identity()).translate(-r.x, -r.y).scale(i.width / r.width, i.height / r.height).translate(i.x, i.y), this.renderer.filter.transformAABB(s, e), e.fit(i), e.x = Math.round(e.x * t), e.y = Math.round(e.y * t), e.width = Math.round(e.width * t), e.height = Math.round(e.height * t))
                        }
                        push(e) {
                            e._scissorRectLocal || this.calcScissorRect(e);
                            const {
                                gl: t
                            } = this.renderer;
                            e._scissorRect || t.enable(t.SCISSOR_TEST), e._scissorCounter++, e._scissorRect = e._scissorRectLocal, this._useCurrent()
                        }
                        pop(e) {
                            const {
                                gl: t
                            } = this.renderer;
                            e && h.push(e._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : t.disable(t.SCISSOR_TEST)
                        }
                        _useCurrent() {
                            const e = this.maskStack[this.maskStack.length - 1]._scissorRect;
                            let t;
                            t = this.renderer.renderTexture.current ? e.y : this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, t, e.width, e.height)
                        }
                    };
                let u = l;
                u.extension = {
                    type: i.ExtensionType.RendererSystem,
                    name: "scissor"
                }, i.extensions.add(u), t.ScissorSystem = u
            },
            3884: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7222),
                    s = r(6667),
                    n = r(4971);
                class o extends n.AbstractMaskSystem {
                    constructor(e) {
                        super(e), this.glConst = s.settings.ADAPTER.getWebGLRenderingContext().STENCIL_TEST
                    }
                    getStackLength() {
                        const e = this.maskStack[this.maskStack.length - 1];
                        return e ? e._stencilCounter : 0
                    }
                    push(e) {
                        const t = e.maskObject,
                            {
                                gl: r
                            } = this.renderer,
                            i = e._stencilCounter;
                        0 === i && (this.renderer.framebuffer.forceStencil(), r.clearStencil(0), r.clear(r.STENCIL_BUFFER_BIT), r.enable(r.STENCIL_TEST)), e._stencilCounter++;
                        const s = e._colorMask;
                        0 !== s && (e._colorMask = 0, r.colorMask(!1, !1, !1, !1)), r.stencilFunc(r.EQUAL, i, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.INCR), t.renderable = !0, t.render(this.renderer), this.renderer.batch.flush(), t.renderable = !1, 0 !== s && (e._colorMask = s, r.colorMask(0 != (1 & s), 0 != (2 & s), 0 != (4 & s), 0 != (8 & s))), this._useCurrent()
                    }
                    pop(e) {
                        const t = this.renderer.gl;
                        if (0 === this.getStackLength()) t.disable(t.STENCIL_TEST);
                        else {
                            const r = 0 !== this.maskStack.length ? this.maskStack[this.maskStack.length - 1] : null,
                                i = r ? r._colorMask : 15;
                            0 !== i && (r._colorMask = 0, t.colorMask(!1, !1, !1, !1)), t.stencilOp(t.KEEP, t.KEEP, t.DECR), e.renderable = !0, e.render(this.renderer), this.renderer.batch.flush(), e.renderable = !1, 0 !== i && (r._colorMask = i, t.colorMask(0 != (1 & i), 0 != (2 & i), 0 != (4 & i), 0 != (8 & i))), this._useCurrent()
                        }
                    }
                    _useCurrent() {
                        const e = this.renderer.gl;
                        e.stencilFunc(e.EQUAL, this.getStackLength(), 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP)
                    }
                }
                o.extension = {
                    type: i.ExtensionType.RendererSystem,
                    name: "stencil"
                }, i.extensions.add(o), t.StencilSystem = o
            },
            3039: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7222),
                    s = r(6128);
                class n {
                    constructor(e) {
                        this.renderer = e, this.plugins = {}, Object.defineProperties(this.plugins, {
                            extract: {
                                enumerable: !1,
                                get: () => (s.deprecation("7.0.0", "renderer.plugins.extract has moved to renderer.extract"), e.extract)
                            },
                            prepare: {
                                enumerable: !1,
                                get: () => (s.deprecation("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare"), e.prepare)
                            },
                            interaction: {
                                enumerable: !1,
                                get: () => (s.deprecation("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events"), e.events)
                            }
                        })
                    }
                    init() {
                        const e = this.rendererPlugins;
                        for (const t in e) this.plugins[t] = new e[t](this.renderer)
                    }
                    destroy() {
                        for (const e in this.plugins) this.plugins[e].destroy(), this.plugins[e] = null
                    }
                }
                n.extension = {
                    type: [i.ExtensionType.RendererSystem, i.ExtensionType.CanvasRendererSystem],
                    name: "_plugin"
                }, i.extensions.add(n), t.PluginSystem = n
            },
            7278: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7222),
                    s = r(8153);
                class n {
                    constructor(e) {
                        this.renderer = e, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new s.Matrix, this.transform = null
                    }
                    update(e, t, r, i) {
                        this.destinationFrame = e || this.destinationFrame || this.defaultFrame, this.sourceFrame = t || this.sourceFrame || e, this.calculateProjection(this.destinationFrame, this.sourceFrame, r, i), this.transform && this.projectionMatrix.append(this.transform);
                        const s = this.renderer;
                        s.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, s.globalUniforms.update(), s.shader.shader && s.shader.syncUniformGroup(s.shader.shader.uniforms.globals)
                    }
                    calculateProjection(e, t, r, i) {
                        const s = this.projectionMatrix,
                            n = i ? -1 : 1;
                        s.identity(), s.a = 1 / t.width * 2, s.d = n * (1 / t.height * 2), s.tx = -1 - t.x * s.a, s.ty = -n - t.y * s.d
                    }
                    setTransform(e) {}
                    destroy() {
                        this.renderer = null
                    }
                }
                n.extension = {
                    type: i.ExtensionType.RendererSystem,
                    name: "projection"
                }, i.extensions.add(n), t.ProjectionSystem = n
            },
            5926: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7222);
                class s {
                    constructor(e) {
                        this.renderer = e
                    }
                    render(e, t) {
                        const r = this.renderer;
                        let i, s, n, o;
                        if (t && (i = t.renderTexture, s = t.clear, n = t.transform, o = t.skipUpdateTransform), this.renderingToScreen = !i, r.runners.prerender.emit(), r.emit("prerender"), r.projection.transform = n, !r.context.isLost) {
                            if (i || (this.lastObjectRendered = e), !o) {
                                const t = e.enableTempParent();
                                e.updateTransform(), e.disableTempParent(t)
                            }
                            r.renderTexture.bind(i), r.batch.currentRenderer.start(), (s ?? r.background.clearBeforeRender) && r.renderTexture.clear(), e.render(r), r.batch.currentRenderer.flush(), i && (t.blit && r.framebuffer.blit(), i.baseTexture.update()), r.runners.postrender.emit(), r.projection.transform = null, r.emit("postrender")
                        }
                    }
                    destroy() {
                        this.renderer = null, this.lastObjectRendered = null
                    }
                }
                s.extension = {
                    type: i.ExtensionType.RendererSystem,
                    name: "objectRenderer"
                }, i.extensions.add(s), t.ObjectRendererSystem = s
            },
            9525: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2264),
                    s = r(2386),
                    n = r(8343),
                    o = r(4291);
                class a extends o.BaseTexture {
                    constructor(e = {}) {
                        "number" == typeof e && (e = {
                            width: arguments[0],
                            height: arguments[1],
                            scaleMode: arguments[2],
                            resolution: arguments[3]
                        }), e.width = e.width || 100, e.height = e.height || 100, e.multisample ?? (e.multisample = s.MSAA_QUALITY.NONE), super(null, e), this.mipmap = s.MIPMAP_MODES.OFF, this.valid = !0, this._clear = new i.Color([0, 0, 0, 0]), this.framebuffer = new n.Framebuffer(this.realWidth, this.realHeight).addColorTexture(0, this), this.framebuffer.multisample = e.multisample, this.maskStack = [], this.filterStack = [{}]
                    }
                    set clearColor(e) {
                        this._clear.setValue(e)
                    }
                    get clearColor() {
                        return this._clear.value
                    }
                    get clear() {
                        return this._clear
                    }
                    resize(e, t) {
                        this.framebuffer.resize(e * this.resolution, t * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height)
                    }
                    dispose() {
                        this.framebuffer.dispose(), super.dispose()
                    }
                    destroy() {
                        super.destroy(), this.framebuffer.destroyDepthTexture(), this.framebuffer = null
                    }
                }
                t.BaseRenderTexture = a
            },
            5923: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7222),
                    s = r(8153),
                    n = r(5956);
                const o = new s.Transform;
                class a {
                    constructor(e) {
                        this.renderer = e, this._tempMatrix = new s.Matrix
                    }
                    generateTexture(e, t) {
                        const {
                            region: r,
                            ...i
                        } = t || {}, s = r || e.getLocalBounds(null, !0);
                        0 === s.width && (s.width = 1), 0 === s.height && (s.height = 1);
                        const a = n.RenderTexture.create({
                            width: s.width,
                            height: s.height,
                            ...i
                        });
                        this._tempMatrix.tx = -s.x, this._tempMatrix.ty = -s.y;
                        const h = e.transform;
                        return e.transform = o, this.renderer.render(e, {
                            renderTexture: a,
                            transform: this._tempMatrix,
                            skipUpdateTransform: !!e.parent,
                            blit: !0
                        }), e.transform = h, a
                    }
                    destroy() {}
                }
                a.extension = {
                    type: [i.ExtensionType.RendererSystem, i.ExtensionType.CanvasRendererSystem],
                    name: "textureGenerator"
                }, i.extensions.add(a), t.GenerateTextureSystem = a
            },
            5956: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(733),
                    s = r(9525);
                class n extends i.Texture {
                    constructor(e, t) {
                        super(e, t), this.valid = !0, this.filterFrame = null, this.filterPoolKey = null, this.updateUvs()
                    }
                    get framebuffer() {
                        return this.baseTexture.framebuffer
                    }
                    get multisample() {
                        return this.framebuffer.multisample
                    }
                    set multisample(e) {
                        this.framebuffer.multisample = e
                    }
                    resize(e, t, r = !0) {
                        const i = this.baseTexture.resolution,
                            s = Math.round(e * i) / i,
                            n = Math.round(t * i) / i;
                        this.valid = s > 0 && n > 0, this._frame.width = this.orig.width = s, this._frame.height = this.orig.height = n, r && this.baseTexture.resize(s, n), this.updateUvs()
                    }
                    setResolution(e) {
                        const {
                            baseTexture: t
                        } = this;
                        t.resolution !== e && (t.setResolution(e), this.resize(t.width, t.height, !1))
                    }
                    static create(e) {
                        return new n(new s.BaseRenderTexture(e))
                    }
                }
                t.RenderTexture = n
            },
            8184: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(6128),
                    n = r(9525),
                    o = r(5956);
                class a {
                    constructor(e) {
                        this.texturePool = {}, this.textureOptions = e || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0
                    }
                    createTexture(e, t, r = i.MSAA_QUALITY.NONE) {
                        const s = new n.BaseRenderTexture(Object.assign({
                            width: e,
                            height: t,
                            resolution: 1,
                            multisample: r
                        }, this.textureOptions));
                        return new o.RenderTexture(s)
                    }
                    getOptimalTexture(e, t, r = 1, n = i.MSAA_QUALITY.NONE) {
                        let o;
                        e = Math.ceil(e * r - 1e-6), t = Math.ceil(t * r - 1e-6), this.enableFullScreen && e === this._pixelsWidth && t === this._pixelsHeight ? o = n > 1 ? -n : -1 : (o = ((65535 & (e = s.nextPow2(e))) << 16 | 65535 & (t = s.nextPow2(t))) >>> 0, n > 1 && (o += 4294967296 * n)), this.texturePool[o] || (this.texturePool[o] = []);
                        let a = this.texturePool[o].pop();
                        return a || (a = this.createTexture(e, t, n)), a.filterPoolKey = o, a.setResolution(r), a
                    }
                    getFilterTexture(e, t, r) {
                        const s = this.getOptimalTexture(e.width, e.height, t || e.resolution, r || i.MSAA_QUALITY.NONE);
                        return s.filterFrame = e.filterFrame, s
                    }
                    returnTexture(e) {
                        const t = e.filterPoolKey;
                        e.filterFrame = null, this.texturePool[t].push(e)
                    }
                    returnFilterTexture(e) {
                        this.returnTexture(e)
                    }
                    clear(e) {
                        if (e = !1 !== e)
                            for (const e in this.texturePool) {
                                const t = this.texturePool[e];
                                if (t)
                                    for (let e = 0; e < t.length; e++) t[e].destroy(!0)
                            }
                        this.texturePool = {}
                    }
                    setScreenSize(e) {
                        if (e.width !== this._pixelsWidth || e.height !== this._pixelsHeight) {
                            this.enableFullScreen = e.width > 0 && e.height > 0;
                            for (const e in this.texturePool) {
                                if (!(Number(e) < 0)) continue;
                                const t = this.texturePool[e];
                                if (t)
                                    for (let e = 0; e < t.length; e++) t[e].destroy(!0);
                                this.texturePool[e] = []
                            }
                            this._pixelsWidth = e.width, this._pixelsHeight = e.height
                        }
                    }
                }
                a.SCREEN_KEY = -1, t.RenderTexturePool = a
            },
            4328: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2264),
                    s = r(7222),
                    n = r(8153);
                const o = new n.Rectangle,
                    a = new n.Rectangle;
                class h {
                    constructor(e) {
                        this.renderer = e, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new n.Rectangle, this.destinationFrame = new n.Rectangle, this.viewportFrame = new n.Rectangle
                    }
                    bind(e = null, t, r) {
                        const i = this.renderer;
                        let s, n, h;
                        this.current = e, e ? (s = e.baseTexture, h = s.resolution, t || (o.width = e.frame.width, o.height = e.frame.height, t = o), r || (a.x = e.frame.x, a.y = e.frame.y, a.width = t.width, a.height = t.height, r = a), n = s.framebuffer) : (h = i.resolution, t || (o.width = i._view.screen.width, o.height = i._view.screen.height, t = o), r || ((r = o).width = t.width, r.height = t.height));
                        const l = this.viewportFrame;
                        l.x = r.x * h, l.y = r.y * h, l.width = r.width * h, l.height = r.height * h, e || (l.y = i.view.height - (l.y + l.height)), l.ceil(), this.renderer.framebuffer.bind(n, l), this.renderer.projection.update(r, t, h, !n), e ? this.renderer.mask.setMaskStack(s.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(t), this.destinationFrame.copyFrom(r)
                    }
                    clear(e, t) {
                        const r = this.current ? this.current.baseTexture.clear : this.renderer.background.backgroundColor,
                            s = e ? i.Color.shared.setValue(e) : r,
                            n = this.destinationFrame,
                            o = this.current ? this.current.baseTexture : this.renderer._view.screen,
                            a = n.width !== o.width || n.height !== o.height;
                        if (a) {
                            let {
                                x: e,
                                y: t,
                                width: r,
                                height: i
                            } = this.viewportFrame;
                            e = Math.round(e), t = Math.round(t), r = Math.round(r), i = Math.round(i), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(e, t, r, i)
                        }
                        this.renderer.framebuffer.clear(s.red, s.green, s.blue, s.alpha, t), a && this.renderer.scissor.pop()
                    }
                    resize() {
                        this.bind(null)
                    }
                    reset() {
                        this.bind(null)
                    }
                    destroy() {
                        this.renderer = null
                    }
                }
                h.extension = {
                    type: s.ExtensionType.RendererSystem,
                    name: "renderTexture"
                }, s.extensions.add(h), t.RenderTextureSystem = h
            },
            4641: (e, t, r) => {
                "use strict";
                var i = r(2386),
                    s = r(6667),
                    n = r(6128),
                    o = r(7159),
                    a = r(6153),
                    h = r(7685);
                r(2138);
                var l = r(4291),
                    u = r(4866),
                    c = r(3346),
                    d = r(153),
                    p = r(6608),
                    f = r(6037);
                s.settings.PREFER_ENV = i.ENV.WEBGL2, s.settings.STRICT_TEXTURE_CACHE = !1, s.settings.RENDER_OPTIONS = {
                    ...u.ContextSystem.defaultOptions,
                    ...c.BackgroundSystem.defaultOptions,
                    ...d.ViewSystem.defaultOptions,
                    ...p.StartupSystem.defaultOptions
                }, Object.defineProperties(s.settings, {
                    WRAP_MODE: {
                        get: () => l.BaseTexture.defaultOptions.wrapMode,
                        set(e) {
                            n.deprecation("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode"), l.BaseTexture.defaultOptions.wrapMode = e
                        }
                    },
                    SCALE_MODE: {
                        get: () => l.BaseTexture.defaultOptions.scaleMode,
                        set(e) {
                            n.deprecation("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode"), l.BaseTexture.defaultOptions.scaleMode = e
                        }
                    },
                    MIPMAP_TEXTURES: {
                        get: () => l.BaseTexture.defaultOptions.mipmap,
                        set(e) {
                            n.deprecation("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap"), l.BaseTexture.defaultOptions.mipmap = e
                        }
                    },
                    ANISOTROPIC_LEVEL: {
                        get: () => l.BaseTexture.defaultOptions.anisotropicLevel,
                        set(e) {
                            n.deprecation("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel"), l.BaseTexture.defaultOptions.anisotropicLevel = e
                        }
                    },
                    FILTER_RESOLUTION: {
                        get: () => (n.deprecation("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"), a.Filter.defaultResolution),
                        set(e) {
                            a.Filter.defaultResolution = e
                        }
                    },
                    FILTER_MULTISAMPLE: {
                        get: () => (n.deprecation("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"), a.Filter.defaultMultisample),
                        set(e) {
                            a.Filter.defaultMultisample = e
                        }
                    },
                    SPRITE_MAX_TEXTURES: {
                        get: () => o.BatchRenderer.defaultMaxTextures,
                        set(e) {
                            n.deprecation("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"), o.BatchRenderer.defaultMaxTextures = e
                        }
                    },
                    SPRITE_BATCH_SIZE: {
                        get: () => o.BatchRenderer.defaultBatchSize,
                        set(e) {
                            n.deprecation("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"), o.BatchRenderer.defaultBatchSize = e
                        }
                    },
                    CAN_UPLOAD_SAME_BUFFER: {
                        get: () => o.BatchRenderer.canUploadSameBuffer,
                        set(e) {
                            n.deprecation("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"), o.BatchRenderer.canUploadSameBuffer = e
                        }
                    },
                    GC_MODE: {
                        get: () => f.TextureGCSystem.defaultMode,
                        set(e) {
                            n.deprecation("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"), f.TextureGCSystem.defaultMode = e
                        }
                    },
                    GC_MAX_IDLE: {
                        get: () => f.TextureGCSystem.defaultMaxIdle,
                        set(e) {
                            n.deprecation("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"), f.TextureGCSystem.defaultMaxIdle = e
                        }
                    },
                    GC_MAX_CHECK_COUNT: {
                        get: () => f.TextureGCSystem.defaultCheckCountMax,
                        set(e) {
                            n.deprecation("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"), f.TextureGCSystem.defaultCheckCountMax = e
                        }
                    },
                    PRECISION_VERTEX: {
                        get: () => h.Program.defaultVertexPrecision,
                        set(e) {
                            n.deprecation("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"), h.Program.defaultVertexPrecision = e
                        }
                    },
                    PRECISION_FRAGMENT: {
                        get: () => h.Program.defaultFragmentPrecision,
                        set(e) {
                            n.deprecation("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"), h.Program.defaultFragmentPrecision = e
                        }
                    }
                })
            },
            1949: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.GLProgram = class {
                    constructor(e, t) {
                        this.program = e, this.uniformData = t, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {}
                    }
                    destroy() {
                        this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null
                    }
                }, t.IGLUniformData = class {}
            },
            7685: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(6128),
                    n = r(5453),
                    o = r(2935);
                r(361);
                var a = r(5707),
                    h = r(7080);
                let l = 0;
                const u = {},
                    c = class {
                        constructor(e, t, r = "pixi-shader", s = {}) {
                            this.extra = {}, this.id = l++, this.vertexSrc = e || c.defaultVertexSrc, this.fragmentSrc = t || c.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.extra = s, "#version" !== this.vertexSrc.substring(0, 8) && (r = r.replace(/\s+/g, "-"), u[r] ? (u[r]++, r += `-${u[r]}`) : u[r] = 1, this.vertexSrc = `#define SHADER_NAME ${r}\n${this.vertexSrc}`, this.fragmentSrc = `#define SHADER_NAME ${r}\n${this.fragmentSrc}`, this.vertexSrc = a.setPrecision(this.vertexSrc, c.defaultVertexPrecision, i.PRECISION.HIGH), this.fragmentSrc = a.setPrecision(this.fragmentSrc, c.defaultFragmentPrecision, h.getMaxFragmentPrecision())), this.glPrograms = {}, this.syncUniforms = null
                        }
                        static get defaultVertexSrc() {
                            return o.default
                        }
                        static get defaultFragmentSrc() {
                            return n.default
                        }
                        static from(e, t, r) {
                            const i = e + t;
                            let n = s.ProgramCache[i];
                            return n || (s.ProgramCache[i] = n = new c(e, t, r)), n
                        }
                    };
                let d = c;
                d.defaultVertexPrecision = i.PRECISION.HIGH, d.defaultFragmentPrecision = s.isMobile.apple.device ? i.PRECISION.HIGH : i.PRECISION.MEDIUM, t.Program = d
            },
            510: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(5802),
                    s = r(7685),
                    n = r(4353);
                class o {
                    constructor(e, t) {
                        this.uniformBindCount = 0, this.program = e, t ? t instanceof n.UniformGroup ? this.uniformGroup = t : this.uniformGroup = new n.UniformGroup(t) : this.uniformGroup = new n.UniformGroup({}), this.disposeRunner = new i.Runner("disposeShader")
                    }
                    checkUniformExists(e, t) {
                        if (t.uniforms[e]) return !0;
                        for (const r in t.uniforms) {
                            const i = t.uniforms[r];
                            if (i.group && this.checkUniformExists(e, i)) return !0
                        }
                        return !1
                    }
                    destroy() {
                        this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy()
                    }
                    get uniforms() {
                        return this.uniformGroup.uniforms
                    }
                    static from(e, t, r) {
                        const i = s.Program.from(e, t);
                        return new o(i, r)
                    }
                }
                t.Shader = o
            },
            5879: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7222);
                r(361);
                var s = r(5084),
                    n = r(3601),
                    o = r(195),
                    a = r(5767);
                let h = 0;
                const l = {
                    textureCount: 0,
                    uboCount: 0
                };
                class u {
                    constructor(e) {
                        this.destroyed = !1, this.renderer = e, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = h++
                    }
                    systemCheck() {
                        if (!o.unsafeEvalSupported()) throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")
                    }
                    contextChange(e) {
                        this.gl = e, this.reset()
                    }
                    bind(e, t) {
                        e.disposeRunner.add(this), e.uniforms.globals = this.renderer.globalUniforms;
                        const r = e.program,
                            i = r.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(e);
                        return this.shader = e, this.program !== r && (this.program = r, this.gl.useProgram(i.program)), t || (l.textureCount = 0, l.uboCount = 0, this.syncUniformGroup(e.uniformGroup, l)), i
                    }
                    setUniforms(e) {
                        const t = this.shader.program,
                            r = t.glPrograms[this.renderer.CONTEXT_UID];
                        t.syncUniforms(r.uniformData, e, this.renderer)
                    }
                    syncUniformGroup(e, t) {
                        const r = this.getGlProgram();
                        e.static && e.dirtyId === r.uniformDirtyGroups[e.id] || (r.uniformDirtyGroups[e.id] = e.dirtyId, this.syncUniforms(e, r, t))
                    }
                    syncUniforms(e, t, r) {
                        (e.syncUniforms[this.shader.program.id] || this.createSyncGroups(e))(t.uniformData, e.uniforms, this.renderer, r)
                    }
                    createSyncGroups(e) {
                        const t = this.getSignature(e, this.shader.program.uniformData, "u");
                        return this.cache[t] || (this.cache[t] = a.generateUniformsSync(e, this.shader.program.uniformData)), e.syncUniforms[this.shader.program.id] = this.cache[t], e.syncUniforms[this.shader.program.id]
                    }
                    syncUniformBufferGroup(e, t) {
                        const r = this.getGlProgram();
                        if (!e.static || 0 !== e.dirtyId || !r.uniformGroups[e.id]) {
                            e.dirtyId = 0;
                            const i = r.uniformGroups[e.id] || this.createSyncBufferGroup(e, r, t);
                            e.buffer.update(), i(r.uniformData, e.uniforms, this.renderer, l, e.buffer)
                        }
                        this.renderer.buffer.bindBufferBase(e.buffer, r.uniformBufferBindings[t])
                    }
                    createSyncBufferGroup(e, t, r) {
                        const {
                            gl: i
                        } = this.renderer;
                        this.renderer.buffer.bind(e.buffer);
                        const s = this.gl.getUniformBlockIndex(t.program, r);
                        t.uniformBufferBindings[r] = this.shader.uniformBindCount, i.uniformBlockBinding(t.program, s, this.shader.uniformBindCount), this.shader.uniformBindCount++;
                        const o = this.getSignature(e, this.shader.program.uniformData, "ubo");
                        let a = this._uboCache[o];
                        if (a || (a = this._uboCache[o] = n.generateUniformBufferSync(e, this.shader.program.uniformData)), e.autoManage) {
                            const t = new Float32Array(a.size / 4);
                            e.buffer.update(t)
                        }
                        return t.uniformGroups[e.id] = a.syncFunc, t.uniformGroups[e.id]
                    }
                    getSignature(e, t, r) {
                        const i = e.uniforms,
                            s = [`${r}-`];
                        for (const e in i) s.push(e), t[e] && s.push(t[e].type);
                        return s.join("-")
                    }
                    getGlProgram() {
                        return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null
                    }
                    generateProgram(e) {
                        const t = this.gl,
                            r = e.program,
                            i = s.generateProgram(t, r);
                        return r.glPrograms[this.renderer.CONTEXT_UID] = i, i
                    }
                    reset() {
                        this.program = null, this.shader = null
                    }
                    disposeShader(e) {
                        this.shader === e && (this.shader = null)
                    }
                    destroy() {
                        this.renderer = null, this.destroyed = !0
                    }
                }
                u.extension = {
                    type: i.ExtensionType.RendererSystem,
                    name: "shader"
                }, i.extensions.add(u), t.ShaderSystem = u
            },
            4353: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(9202);
                let n = 0;
                class o {
                    constructor(e, t, r) {
                        this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = n++, this.static = !!t, this.ubo = !!r, e instanceof s.Buffer ? (this.buffer = e, this.buffer.type = i.BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = e, this.ubo && (this.buffer = new s.Buffer(new Float32Array(1)), this.buffer.type = i.BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = !0))
                    }
                    update() {
                        this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update()
                    }
                    add(e, t, r) {
                        if (this.ubo) throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
                        this.uniforms[e] = new o(t, r)
                    }
                    static from(e, t, r) {
                        return new o(e, t, r)
                    }
                    static uboFrom(e, t) {
                        return new o(e, t ?? !0, !0)
                    }
                }
                t.UniformGroup = o
            },
            5453: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\n}"
            },
            2935: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void){\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vTextureCoord = aTextureCoord;\n}\n"
            },
            3576: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const r = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join("\n");

                function i(e) {
                    let t = "";
                    for (let r = 0; r < e; ++r) r > 0 && (t += "\nelse "), r < e - 1 && (t += `if(test == ${r}.0){}`);
                    return t
                }
                t.checkMaxIfStatementsInShader = function(e, t) {
                    if (0 === e) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
                    const s = t.createShader(t.FRAGMENT_SHADER);
                    for (;;) {
                        const n = r.replace(/%forloop%/gi, i(e));
                        if (t.shaderSource(s, n), t.compileShader(s), t.getShaderParameter(s, t.COMPILE_STATUS)) break;
                        e = e / 2 | 0
                    }
                    return e
                }
            },
            4563: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.compileShader = function(e, t, r) {
                    const i = e.createShader(t);
                    return e.shaderSource(i, r), e.compileShader(i), i
                }
            },
            9663: (e, t) => {
                "use strict";

                function r(e) {
                    const t = new Array(e);
                    for (let e = 0; e < t.length; e++) t[e] = !1;
                    return t
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.defaultValue = function(e, t) {
                    switch (e) {
                        case "float":
                        case "int":
                        case "uint":
                        case "sampler2D":
                        case "sampler2DArray":
                            return 0;
                        case "vec2":
                            return new Float32Array(2 * t);
                        case "vec3":
                            return new Float32Array(3 * t);
                        case "vec4":
                            return new Float32Array(4 * t);
                        case "ivec2":
                            return new Int32Array(2 * t);
                        case "ivec3":
                            return new Int32Array(3 * t);
                        case "ivec4":
                            return new Int32Array(4 * t);
                        case "uvec2":
                            return new Uint32Array(2 * t);
                        case "uvec3":
                            return new Uint32Array(3 * t);
                        case "uvec4":
                            return new Uint32Array(4 * t);
                        case "bool":
                            return !1;
                        case "bvec2":
                            return r(2 * t);
                        case "bvec3":
                            return r(3 * t);
                        case "bvec4":
                            return r(4 * t);
                        case "mat2":
                            return new Float32Array([1, 0, 0, 1]);
                        case "mat3":
                            return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                        case "mat4":
                            return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
                    }
                    return null
                }
            },
            5084: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(1949),
                    s = r(4563),
                    n = r(9663),
                    o = r(9016),
                    a = r(3410),
                    h = r(6922);
                t.generateProgram = function(e, t) {
                    const r = s.compileShader(e, e.VERTEX_SHADER, t.vertexSrc),
                        l = s.compileShader(e, e.FRAGMENT_SHADER, t.fragmentSrc),
                        u = e.createProgram();
                    e.attachShader(u, r), e.attachShader(u, l);
                    const c = t.extra?.transformFeedbackVaryings;
                    if (c && ("function" != typeof e.transformFeedbackVaryings ? console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : e.transformFeedbackVaryings(u, c.names, "separate" === c.bufferMode ? e.SEPARATE_ATTRIBS : e.INTERLEAVED_ATTRIBS)), e.linkProgram(u), e.getProgramParameter(u, e.LINK_STATUS) || h.logProgramError(e, u, r, l), t.attributeData = o.getAttributeData(u, e), t.uniformData = a.getUniformData(u, e), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertexSrc)) {
                        const r = Object.keys(t.attributeData);
                        r.sort(((e, t) => e > t ? 1 : -1));
                        for (let i = 0; i < r.length; i++) t.attributeData[r[i]].location = i, e.bindAttribLocation(u, i, r[i]);
                        e.linkProgram(u)
                    }
                    e.deleteShader(r), e.deleteShader(l);
                    const d = {};
                    for (const r in t.uniformData) {
                        const i = t.uniformData[r];
                        d[r] = {
                            location: e.getUniformLocation(u, r),
                            value: n.defaultValue(i.type, i.size)
                        }
                    }
                    return new i.GLProgram(u, d)
                }
            },
            3601: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), r(361);
                var i = r(9457),
                    s = r(3028);

                function n(e, t, r, i, s) {
                    r.buffer.update(s)
                }
                const o = {
                        float: "\n        data[offset] = v;\n    ",
                        vec2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n    ",
                        vec3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n    ",
                        vec4: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n        data[offset+3] = v[3];\n    ",
                        mat2: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n\n        data[offset+4] = v[2];\n        data[offset+5] = v[3];\n    ",
                        mat3: "\n        data[offset] = v[0];\n        data[offset+1] = v[1];\n        data[offset+2] = v[2];\n\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];\n    ",
                        mat4: "\n        for(var i = 0; i < 16; i++)\n        {\n            data[offset + i] = v[i];\n        }\n    "
                    },
                    a = {
                        float: 4,
                        vec2: 8,
                        vec3: 12,
                        vec4: 16,
                        int: 4,
                        ivec2: 8,
                        ivec3: 12,
                        ivec4: 16,
                        uint: 4,
                        uvec2: 8,
                        uvec3: 12,
                        uvec4: 16,
                        bool: 4,
                        bvec2: 8,
                        bvec3: 12,
                        bvec4: 16,
                        mat2: 32,
                        mat3: 48,
                        mat4: 64
                    };

                function h(e) {
                    const t = e.map((e => ({
                        data: e,
                        offset: 0,
                        dataLen: 0,
                        dirty: 0
                    })));
                    let r = 0,
                        i = 0,
                        s = 0;
                    for (let e = 0; e < t.length; e++) {
                        const n = t[e];
                        if (r = a[n.data.type], n.data.size > 1 && (r = Math.max(r, 16) * n.data.size), n.dataLen = r, i % r != 0 && i < 16) {
                            const e = i % r % 16;
                            i += e, s += e
                        }
                        i + r > 16 ? (s = 16 * Math.ceil(s / 16), n.offset = s, s += r, i = r) : (n.offset = s, i += r, s += r)
                    }
                    return s = 16 * Math.ceil(s / 16), {
                        uboElements: t,
                        size: s
                    }
                }

                function l(e, t) {
                    const r = [];
                    for (const i in e) t[i] && r.push(t[i]);
                    return r.sort(((e, t) => e.index - t.index)), r
                }
                t.createUBOElements = h, t.generateUniformBufferSync = function(e, t) {
                    if (!e.autoManage) return {
                        size: 0,
                        syncFunc: n
                    };
                    const r = l(e.uniforms, t),
                        {
                            uboElements: u,
                            size: c
                        } = h(r),
                        d = ["\n    var v = null;\n    var v2 = null;\n    var cv = null;\n    var t = 0;\n    var gl = renderer.gl\n    var index = 0;\n    var data = buffer.data;\n    "];
                    for (let t = 0; t < u.length; t++) {
                        const r = u[t],
                            n = e.uniforms[r.data.name],
                            h = r.data.name;
                        let l = !1;
                        for (let e = 0; e < i.uniformParsers.length; e++) {
                            const t = i.uniformParsers[e];
                            if (t.codeUbo && t.test(r.data, n)) {
                                d.push(`offset = ${r.offset/4};`, i.uniformParsers[e].codeUbo(r.data.name, n)), l = !0;
                                break
                            }
                        }
                        if (!l)
                            if (r.data.size > 1) {
                                const e = s.mapSize(r.data.type),
                                    t = Math.max(a[r.data.type] / 16, 1),
                                    i = e / t,
                                    n = (4 - i % 4) % 4;
                                d.push(`\n                cv = ud.${h}.value;\n                v = uv.${h};\n                offset = ${r.offset/4};\n\n                t = 0;\n\n                for(var i=0; i < ${r.data.size*t}; i++)\n                {\n                    for(var j = 0; j < ${i}; j++)\n                    {\n                        data[offset++] = v[t++];\n                    }\n                    offset += ${n};\n                }\n\n                `)
                            } else {
                                const e = o[r.data.type];
                                d.push(`\n                cv = ud.${h}.value;\n                v = uv.${h};\n                offset = ${r.offset/4};\n                ${e};\n                `)
                            }
                    }
                    return d.push("\n       renderer.buffer.update(buffer);\n    "), {
                        size: c,
                        syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", d.join("\n"))
                    }
                }, t.getUBOData = l
            },
            5767: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(9457);
                const s = {
                        float: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1f(location, v);\n    }",
                        vec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }",
                        vec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
                        vec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }",
                        int: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
                        ivec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
                        ivec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
                        ivec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
                        uint: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1ui(location, v);\n    }",
                        uvec2: "\n    if (cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }",
                        uvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }",
                        uvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }",
                        bool: "\n    if (cv !== v)\n    {\n        cu.value = v;\n        gl.uniform1i(location, v);\n    }",
                        bvec2: "\n    if (cv[0] != v[0] || cv[1] != v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }",
                        bvec3: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }",
                        bvec4: "\n    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n        cv[3] = v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }",
                        mat2: "gl.uniformMatrix2fv(location, false, v)",
                        mat3: "gl.uniformMatrix3fv(location, false, v)",
                        mat4: "gl.uniformMatrix4fv(location, false, v)",
                        sampler2D: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
                        samplerCube: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }",
                        sampler2DArray: "\n    if (cv !== v)\n    {\n        cu.value = v;\n\n        gl.uniform1i(location, v);\n    }"
                    },
                    n = {
                        float: "gl.uniform1fv(location, v)",
                        vec2: "gl.uniform2fv(location, v)",
                        vec3: "gl.uniform3fv(location, v)",
                        vec4: "gl.uniform4fv(location, v)",
                        mat4: "gl.uniformMatrix4fv(location, false, v)",
                        mat3: "gl.uniformMatrix3fv(location, false, v)",
                        mat2: "gl.uniformMatrix2fv(location, false, v)",
                        int: "gl.uniform1iv(location, v)",
                        ivec2: "gl.uniform2iv(location, v)",
                        ivec3: "gl.uniform3iv(location, v)",
                        ivec4: "gl.uniform4iv(location, v)",
                        uint: "gl.uniform1uiv(location, v)",
                        uvec2: "gl.uniform2uiv(location, v)",
                        uvec3: "gl.uniform3uiv(location, v)",
                        uvec4: "gl.uniform4uiv(location, v)",
                        bool: "gl.uniform1iv(location, v)",
                        bvec2: "gl.uniform2iv(location, v)",
                        bvec3: "gl.uniform3iv(location, v)",
                        bvec4: "gl.uniform4iv(location, v)",
                        sampler2D: "gl.uniform1iv(location, v)",
                        samplerCube: "gl.uniform1iv(location, v)",
                        sampler2DArray: "gl.uniform1iv(location, v)"
                    };
                t.generateUniformsSync = function(e, t) {
                    const r = ["\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n    "];
                    for (const o in e.uniforms) {
                        const a = t[o];
                        if (!a) {
                            e.uniforms[o]?.group && (e.uniforms[o].ubo ? r.push(`\n                        renderer.shader.syncUniformBufferGroup(uv.${o}, '${o}');\n                    `) : r.push(`\n                        renderer.shader.syncUniformGroup(uv.${o}, syncData);\n                    `));
                            continue
                        }
                        const h = e.uniforms[o];
                        let l = !1;
                        for (let e = 0; e < i.uniformParsers.length; e++)
                            if (i.uniformParsers[e].test(a, h)) {
                                r.push(i.uniformParsers[e].code(o, h)), l = !0;
                                break
                            } if (!l) {
                            const e = (1 !== a.size || a.isArray ? n : s)[a.type].replace("location", `ud["${o}"].location`);
                            r.push(`\n            cu = ud["${o}"];\n            cv = cu.value;\n            v = uv["${o}"];\n            ${e};`)
                        }
                    }
                    return new Function("ud", "uv", "renderer", "syncData", r.join("\n"))
                }
            },
            9016: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(3028),
                    s = r(610);
                t.getAttributeData = function(e, t) {
                    const r = {},
                        n = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
                    for (let o = 0; o < n; o++) {
                        const n = t.getActiveAttrib(e, o);
                        if (n.name.startsWith("gl_")) continue;
                        const a = s.mapType(t, n.type),
                            h = {
                                type: a,
                                name: n.name,
                                size: i.mapSize(a),
                                location: t.getAttribLocation(e, n.name)
                            };
                        r[n.name] = h
                    }
                    return r
                }
            },
            7080: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(6569);
                let n;
                t.getMaxFragmentPrecision = function() {
                    if (!n) {
                        n = i.PRECISION.MEDIUM;
                        const e = s.getTestContext();
                        if (e && e.getShaderPrecisionFormat) {
                            const t = e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT);
                            n = t.precision ? i.PRECISION.HIGH : i.PRECISION.MEDIUM
                        }
                    }
                    return n
                }
            },
            6569: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(6667);
                const n = {};
                let o = n;
                t.getTestContext = function() {
                    if (o === n || o?.isContextLost()) {
                        const e = s.settings.ADAPTER.createCanvas();
                        let t;
                        s.settings.PREFER_ENV >= i.ENV.WEBGL2 && (t = e.getContext("webgl2", {})), t || (t = e.getContext("webgl", {}) || e.getContext("experimental-webgl", {}), t ? t.getExtension("WEBGL_draw_buffers") : t = null), o = t
                    }
                    return o
                }
            },
            3410: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(9663),
                    s = r(610);
                t.getUniformData = function(e, t) {
                    const r = {},
                        n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
                    for (let o = 0; o < n; o++) {
                        const n = t.getActiveUniform(e, o),
                            a = n.name.replace(/\[.*?\]$/, ""),
                            h = !!n.name.match(/\[.*?\]$/),
                            l = s.mapType(t, n.type);
                        r[a] = {
                            name: a,
                            index: o,
                            type: l,
                            size: n.size,
                            isArray: h,
                            value: i.defaultValue(l, n.size)
                        }
                    }
                    return r
                }
            },
            361: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(3576),
                    s = r(4563),
                    n = r(9663),
                    o = r(5767),
                    a = r(7080),
                    h = r(6569),
                    l = r(6922),
                    u = r(3028),
                    c = r(610),
                    d = r(5707),
                    p = r(9457),
                    f = r(195);
                t.checkMaxIfStatementsInShader = i.checkMaxIfStatementsInShader, t.compileShader = s.compileShader, t.defaultValue = n.defaultValue, t.generateUniformsSync = o.generateUniformsSync, t.getMaxFragmentPrecision = a.getMaxFragmentPrecision, t.getTestContext = h.getTestContext, t.logProgramError = l.logProgramError, t.mapSize = u.mapSize, t.mapType = c.mapType, t.setPrecision = d.setPrecision, t.uniformParsers = p.uniformParsers, t.unsafeEvalSupported = f.unsafeEvalSupported
            },
            6922: (e, t) => {
                "use strict";

                function r(e, t) {
                    const r = e.getShaderSource(t).split("\n").map(((e, t) => `${t}: ${e}`)),
                        i = e.getShaderInfoLog(t),
                        s = i.split("\n"),
                        n = {},
                        o = s.map((e => parseFloat(e.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1")))).filter((e => !(!e || n[e] || (n[e] = !0, 0)))),
                        a = [""];
                    o.forEach((e => {
                        r[e - 1] = `%c${r[e-1]}%c`, a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px")
                    }));
                    const h = r.join("\n");
                    a[0] = h, console.error(i), console.groupCollapsed("click to view full shader code"), console.warn(...a), console.groupEnd()
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.logProgramError = function(e, t, i, s) {
                    e.getProgramParameter(t, e.LINK_STATUS) || (e.getShaderParameter(i, e.COMPILE_STATUS) || r(e, i), e.getShaderParameter(s, e.COMPILE_STATUS) || r(e, s), console.error("PixiJS Error: Could not initialize shader."), "" !== e.getProgramInfoLog(t) && console.warn("PixiJS Warning: gl.getProgramInfoLog()", e.getProgramInfoLog(t)))
                }
            },
            3028: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const r = {
                    float: 1,
                    vec2: 2,
                    vec3: 3,
                    vec4: 4,
                    int: 1,
                    ivec2: 2,
                    ivec3: 3,
                    ivec4: 4,
                    uint: 1,
                    uvec2: 2,
                    uvec3: 3,
                    uvec4: 4,
                    bool: 1,
                    bvec2: 2,
                    bvec3: 3,
                    bvec4: 4,
                    mat2: 4,
                    mat3: 9,
                    mat4: 16,
                    sampler2D: 1
                };
                t.mapSize = function(e) {
                    return r[e]
                }
            },
            610: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                let r = null;
                const i = {
                    FLOAT: "float",
                    FLOAT_VEC2: "vec2",
                    FLOAT_VEC3: "vec3",
                    FLOAT_VEC4: "vec4",
                    INT: "int",
                    INT_VEC2: "ivec2",
                    INT_VEC3: "ivec3",
                    INT_VEC4: "ivec4",
                    UNSIGNED_INT: "uint",
                    UNSIGNED_INT_VEC2: "uvec2",
                    UNSIGNED_INT_VEC3: "uvec3",
                    UNSIGNED_INT_VEC4: "uvec4",
                    BOOL: "bool",
                    BOOL_VEC2: "bvec2",
                    BOOL_VEC3: "bvec3",
                    BOOL_VEC4: "bvec4",
                    FLOAT_MAT2: "mat2",
                    FLOAT_MAT3: "mat3",
                    FLOAT_MAT4: "mat4",
                    SAMPLER_2D: "sampler2D",
                    INT_SAMPLER_2D: "sampler2D",
                    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
                    SAMPLER_CUBE: "samplerCube",
                    INT_SAMPLER_CUBE: "samplerCube",
                    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
                    SAMPLER_2D_ARRAY: "sampler2DArray",
                    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
                    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
                };
                t.mapType = function(e, t) {
                    if (!r) {
                        const t = Object.keys(i);
                        r = {};
                        for (let s = 0; s < t.length; ++s) {
                            const n = t[s];
                            r[e[n]] = i[n]
                        }
                    }
                    return r[t]
                }
            },
            5707: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386);
                t.setPrecision = function(e, t, r) {
                    if ("precision" !== e.substring(0, 9)) {
                        let s = t;
                        return t === i.PRECISION.HIGH && r !== i.PRECISION.HIGH && (s = i.PRECISION.MEDIUM), `precision ${s} float;\n${e}`
                    }
                    return r !== i.PRECISION.HIGH && "precision highp" === e.substring(0, 15) ? e.replace("precision highp", "precision mediump") : e
                }
            },
            9457: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.uniformParsers = [{
                    test: e => "float" === e.type && 1 === e.size && !e.isArray,
                    code: e => `\n            if(uv["${e}"] !== ud["${e}"].value)\n            {\n                ud["${e}"].value = uv["${e}"]\n                gl.uniform1f(ud["${e}"].location, uv["${e}"])\n            }\n            `
                }, {
                    test: (e, t) => !("sampler2D" !== e.type && "samplerCube" !== e.type && "sampler2DArray" !== e.type || 1 !== e.size || e.isArray || null != t && void 0 === t.castToBaseTexture),
                    code: e => `t = syncData.textureCount++;\n\n            renderer.texture.bind(uv["${e}"], t);\n\n            if(ud["${e}"].value !== t)\n            {\n                ud["${e}"].value = t;\n                gl.uniform1i(ud["${e}"].location, t);\n; // eslint-disable-line max-len\n            }`
                }, {
                    test: (e, t) => "mat3" === e.type && 1 === e.size && !e.isArray && void 0 !== t.a,
                    code: e => `\n            gl.uniformMatrix3fv(ud["${e}"].location, false, uv["${e}"].toArray(true));\n            `,
                    codeUbo: e => `\n                var ${e}_matrix = uv.${e}.toArray(true);\n\n                data[offset] = ${e}_matrix[0];\n                data[offset+1] = ${e}_matrix[1];\n                data[offset+2] = ${e}_matrix[2];\n        \n                data[offset + 4] = ${e}_matrix[3];\n                data[offset + 5] = ${e}_matrix[4];\n                data[offset + 6] = ${e}_matrix[5];\n        \n                data[offset + 8] = ${e}_matrix[6];\n                data[offset + 9] = ${e}_matrix[7];\n                data[offset + 10] = ${e}_matrix[8];\n            `
                }, {
                    test: (e, t) => "vec2" === e.type && 1 === e.size && !e.isArray && void 0 !== t.x,
                    code: e => `\n                cv = ud["${e}"].value;\n                v = uv["${e}"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud["${e}"].location, v.x, v.y);\n                }`,
                    codeUbo: e => `\n                v = uv.${e};\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            `
                }, {
                    test: e => "vec2" === e.type && 1 === e.size && !e.isArray,
                    code: e => `\n                cv = ud["${e}"].value;\n                v = uv["${e}"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud["${e}"].location, v[0], v[1]);\n                }\n            `
                }, {
                    test: (e, t) => "vec4" === e.type && 1 === e.size && !e.isArray && void 0 !== t.width,
                    code: e => `\n                cv = ud["${e}"].value;\n                v = uv["${e}"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud["${e}"].location, v.x, v.y, v.width, v.height)\n                }`,
                    codeUbo: e => `\n                    v = uv.${e};\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                `
                }, {
                    test: (e, t) => "vec4" === e.type && 1 === e.size && !e.isArray && void 0 !== t.red,
                    code: e => `\n                cv = ud["${e}"].value;\n                v = uv["${e}"];\n\n                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)\n                {\n                    cv[0] = v.red;\n                    cv[1] = v.green;\n                    cv[2] = v.blue;\n                    cv[3] = v.alpha;\n                    gl.uniform4f(ud["${e}"].location, v.red, v.green, v.blue, v.alpha)\n                }`,
                    codeUbo: e => `\n                    v = uv.${e};\n\n                    data[offset] = v.red;\n                    data[offset+1] = v.green;\n                    data[offset+2] = v.blue;\n                    data[offset+3] = v.alpha;\n                `
                }, {
                    test: (e, t) => "vec3" === e.type && 1 === e.size && !e.isArray && void 0 !== t.red,
                    code: e => `\n                cv = ud["${e}"].value;\n                v = uv["${e}"];\n\n                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)\n                {\n                    cv[0] = v.red;\n                    cv[1] = v.green;\n                    cv[2] = v.blue;\n    \n                    gl.uniform3f(ud["${e}"].location, v.red, v.green, v.blue)\n                }`,
                    codeUbo: e => `\n                    v = uv.${e};\n\n                    data[offset] = v.red;\n                    data[offset+1] = v.green;\n                    data[offset+2] = v.blue;\n                `
                }, {
                    test: e => "vec4" === e.type && 1 === e.size && !e.isArray,
                    code: e => `\n                cv = ud["${e}"].value;\n                v = uv["${e}"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud["${e}"].location, v[0], v[1], v[2], v[3])\n                }`
                }]
            },
            195: (e, t) => {
                "use strict";
                let r;
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.unsafeEvalSupported = function() {
                    if ("boolean" == typeof r) return r;
                    try {
                        const e = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
                        r = !0 === e({
                            a: "b"
                        }, "a", "b")
                    } catch (e) {
                        r = !1
                    }
                    return r
                }
            },
            6608: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7222);
                class s {
                    constructor(e) {
                        this.renderer = e
                    }
                    run(e) {
                        const {
                            renderer: t
                        } = this;
                        t.runners.init.emit(t.options), e.hello && console.log(`PixiJS 7.2.3 - ${t.rendererLogId} - https://pixijs.com`), t.resize(t.screen.width, t.screen.height)
                    }
                    destroy() {}
                }
                s.defaultOptions = {
                    hello: !1
                }, s.extension = {
                    type: [i.ExtensionType.RendererSystem, i.ExtensionType.CanvasRendererSystem],
                    name: "startup"
                }, i.extensions.add(s), t.StartupSystem = s
            },
            8303: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386);
                class s {
                    constructor() {
                        this.data = 0, this.blendMode = i.BLEND_MODES.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0
                    }
                    get blend() {
                        return !!(1 & this.data)
                    }
                    set blend(e) {
                        !!(1 & this.data) !== e && (this.data ^= 1)
                    }
                    get offsets() {
                        return !!(2 & this.data)
                    }
                    set offsets(e) {
                        !!(2 & this.data) !== e && (this.data ^= 2)
                    }
                    get culling() {
                        return !!(4 & this.data)
                    }
                    set culling(e) {
                        !!(4 & this.data) !== e && (this.data ^= 4)
                    }
                    get depthTest() {
                        return !!(8 & this.data)
                    }
                    set depthTest(e) {
                        !!(8 & this.data) !== e && (this.data ^= 8)
                    }
                    get depthMask() {
                        return !!(32 & this.data)
                    }
                    set depthMask(e) {
                        !!(32 & this.data) !== e && (this.data ^= 32)
                    }
                    get clockwiseFrontFace() {
                        return !!(16 & this.data)
                    }
                    set clockwiseFrontFace(e) {
                        !!(16 & this.data) !== e && (this.data ^= 16)
                    }
                    get blendMode() {
                        return this._blendMode
                    }
                    set blendMode(e) {
                        this.blend = e !== i.BLEND_MODES.NONE, this._blendMode = e
                    }
                    get polygonOffset() {
                        return this._polygonOffset
                    }
                    set polygonOffset(e) {
                        this.offsets = !!e, this._polygonOffset = e
                    }
                    toString() {
                        return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`
                    }
                    static for2d() {
                        const e = new s;
                        return e.depthTest = !1, e.blend = !0, e
                    }
                }
                t.State = s
            },
            1569: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(7222),
                    n = r(8303),
                    o = r(2721);
                const a = class {
                    constructor() {
                        this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = i.BLEND_MODES.NONE, this._blendEq = !1, this.map = [], this.map[0] = this.setBlend, this.map[1] = this.setOffset, this.map[2] = this.setCullFace, this.map[3] = this.setDepthTest, this.map[4] = this.setFrontFace, this.map[5] = this.setDepthMask, this.checks = [], this.defaultState = new n.State, this.defaultState.blend = !0
                    }
                    contextChange(e) {
                        this.gl = e, this.blendModes = o.mapWebGLBlendModesToPixi(e), this.set(this.defaultState), this.reset()
                    }
                    set(e) {
                        if (e = e || this.defaultState, this.stateId !== e.data) {
                            let t = this.stateId ^ e.data,
                                r = 0;
                            for (; t;) 1 & t && this.map[r].call(this, !!(e.data & 1 << r)), t >>= 1, r++;
                            this.stateId = e.data
                        }
                        for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e)
                    }
                    forceState(e) {
                        e = e || this.defaultState;
                        for (let t = 0; t < this.map.length; t++) this.map[t].call(this, !!(e.data & 1 << t));
                        for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e);
                        this.stateId = e.data
                    }
                    setBlend(e) {
                        this.updateCheck(a.checkBlendMode, e), this.gl[e ? "enable" : "disable"](this.gl.BLEND)
                    }
                    setOffset(e) {
                        this.updateCheck(a.checkPolygonOffset, e), this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
                    }
                    setDepthTest(e) {
                        this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST)
                    }
                    setDepthMask(e) {
                        this.gl.depthMask(e)
                    }
                    setCullFace(e) {
                        this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE)
                    }
                    setFrontFace(e) {
                        this.gl.frontFace(this.gl[e ? "CW" : "CCW"])
                    }
                    setBlendMode(e) {
                        if (e === this.blendMode) return;
                        this.blendMode = e;
                        const t = this.blendModes[e],
                            r = this.gl;
                        2 === t.length ? r.blendFunc(t[0], t[1]) : r.blendFuncSeparate(t[0], t[1], t[2], t[3]), 6 === t.length ? (this._blendEq = !0, r.blendEquationSeparate(t[4], t[5])) : this._blendEq && (this._blendEq = !1, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD))
                    }
                    setPolygonOffset(e, t) {
                        this.gl.polygonOffset(e, t)
                    }
                    reset() {
                        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0)
                    }
                    updateCheck(e, t) {
                        const r = this.checks.indexOf(e);
                        t && -1 === r ? this.checks.push(e) : t || -1 === r || this.checks.splice(r, 1)
                    }
                    static checkBlendMode(e, t) {
                        e.setBlendMode(t.blendMode)
                    }
                    static checkPolygonOffset(e, t) {
                        e.setPolygonOffset(1, t.polygonOffset)
                    }
                    destroy() {
                        this.gl = null
                    }
                };
                let h = a;
                h.extension = {
                    type: s.ExtensionType.RendererSystem,
                    name: "state"
                }, s.extensions.add(h), t.StateSystem = h
            },
            2721: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386);
                t.mapWebGLBlendModesToPixi = function(e, t = []) {
                    return t[i.BLEND_MODES.NORMAL] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.ADD] = [e.ONE, e.ONE], t[i.BLEND_MODES.MULTIPLY] = [e.DST_COLOR, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.SCREEN] = [e.ONE, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.OVERLAY] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.DARKEN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.LIGHTEN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.COLOR_DODGE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.COLOR_BURN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.HARD_LIGHT] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.SOFT_LIGHT] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.DIFFERENCE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.EXCLUSION] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.HUE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.SATURATION] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.COLOR] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.LUMINOSITY] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.NONE] = [0, 0], t[i.BLEND_MODES.NORMAL_NPM] = [e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.ADD_NPM] = [e.SRC_ALPHA, e.ONE, e.ONE, e.ONE], t[i.BLEND_MODES.SCREEN_NPM] = [e.SRC_ALPHA, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.SRC_IN] = [e.DST_ALPHA, e.ZERO], t[i.BLEND_MODES.SRC_OUT] = [e.ONE_MINUS_DST_ALPHA, e.ZERO], t[i.BLEND_MODES.SRC_ATOP] = [e.DST_ALPHA, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.DST_OVER] = [e.ONE_MINUS_DST_ALPHA, e.ONE], t[i.BLEND_MODES.DST_IN] = [e.ZERO, e.SRC_ALPHA], t[i.BLEND_MODES.DST_OUT] = [e.ZERO, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.DST_ATOP] = [e.ONE_MINUS_DST_ALPHA, e.SRC_ALPHA], t[i.BLEND_MODES.XOR] = [e.ONE_MINUS_DST_ALPHA, e.ONE_MINUS_SRC_ALPHA], t[i.BLEND_MODES.SUBTRACT] = [e.ONE, e.ONE, e.ONE, e.ONE, e.FUNC_REVERSE_SUBTRACT, e.FUNC_ADD], t
                }
            },
            746: () => {},
            4462: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(5802),
                    s = r(6128);
                class n extends s.EventEmitter {
                    constructor() {
                        super(...arguments), this.runners = {}, this._systemsHash = {}
                    }
                    setup(e) {
                        this.addRunners(...e.runners);
                        const t = (e.priority ?? []).filter((t => e.systems[t])),
                            r = [...t, ...Object.keys(e.systems).filter((e => !t.includes(e)))];
                        for (const t of r) this.addSystem(e.systems[t], t)
                    }
                    addRunners(...e) {
                        e.forEach((e => {
                            this.runners[e] = new i.Runner(e)
                        }))
                    }
                    addSystem(e, t) {
                        const r = new e(this);
                        if (this[t]) throw new Error(`Whoops! The name "${t}" is already in use`);
                        this[t] = r, this._systemsHash[t] = r;
                        for (const e in this.runners) this.runners[e].add(r);
                        return this
                    }
                    emitWithCustomOptions(e, t) {
                        const r = Object.keys(this._systemsHash);
                        e.items.forEach((i => {
                            const s = r.find((e => this._systemsHash[e] === i));
                            i[e.name](t[s])
                        }))
                    }
                    destroy() {
                        Object.values(this.runners).forEach((e => {
                            e.destroy()
                        })), this._systemsHash = {}
                    }
                }
                t.SystemManager = n
            },
            2138: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(3346),
                    s = r(9769),
                    n = r(4866),
                    o = r(4659),
                    a = r(896),
                    h = r(1094),
                    l = r(9871),
                    u = r(9204),
                    c = r(3884),
                    d = r(3039),
                    p = r(7278),
                    f = r(5923),
                    m = r(4328),
                    g = r(5879),
                    y = r(6608),
                    _ = r(1569),
                    v = r(4462),
                    S = r(6037),
                    T = r(4584),
                    b = r(8200),
                    E = r(153);
                t.BackgroundSystem = i.BackgroundSystem, t.BatchSystem = s.BatchSystem, t.ContextSystem = n.ContextSystem, t.FilterSystem = o.FilterSystem, t.FramebufferSystem = a.FramebufferSystem, t.GeometrySystem = h.GeometrySystem, t.MaskSystem = l.MaskSystem, t.ScissorSystem = u.ScissorSystem, t.StencilSystem = c.StencilSystem, t.PluginSystem = d.PluginSystem, t.ProjectionSystem = p.ProjectionSystem, t.GenerateTextureSystem = f.GenerateTextureSystem, t.RenderTextureSystem = m.RenderTextureSystem, t.ShaderSystem = g.ShaderSystem, t.StartupSystem = y.StartupSystem, t.StateSystem = _.StateSystem, t.SystemManager = v.SystemManager, t.TextureGCSystem = S.TextureGCSystem, t.TextureSystem = T.TextureSystem, t.TransformFeedbackSystem = b.TransformFeedbackSystem, t.ViewSystem = E.ViewSystem
            },
            4291: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(6667),
                    n = r(6128),
                    o = r(1857),
                    a = r(2297),
                    h = r(3227);
                const l = {
                        scaleMode: i.SCALE_MODES.NEAREST,
                        format: i.FORMATS.RGBA,
                        alphaMode: i.ALPHA_MODES.NPM
                    },
                    u = class extends n.EventEmitter {
                        constructor(e = null, t = null) {
                            super(), t = Object.assign({}, u.defaultOptions, t);
                            const {
                                alphaMode: r,
                                mipmap: i,
                                anisotropicLevel: a,
                                scaleMode: l,
                                width: c,
                                height: d,
                                wrapMode: p,
                                format: f,
                                type: m,
                                target: g,
                                resolution: y,
                                resourceOptions: _
                            } = t;
                            !e || e instanceof h.Resource || ((e = o.autoDetectResource(e, _)).internal = !0), this.resolution = y || s.settings.RESOLUTION, this.width = Math.round((c || 0) * this.resolution) / this.resolution, this.height = Math.round((d || 0) * this.resolution) / this.resolution, this._mipmap = i, this.anisotropicLevel = a, this._wrapMode = p, this._scaleMode = l, this.format = f, this.type = m, this.target = g, this.alphaMode = r, this.uid = n.uid(), this.touched = 0, this.isPowerOfTwo = !1, this._refreshPOT(), this._glTextures = {}, this.dirtyId = 0, this.dirtyStyleId = 0, this.cacheId = null, this.valid = c > 0 && d > 0, this.textureCacheIds = [], this.destroyed = !1, this.resource = null, this._batchEnabled = 0, this._batchLocation = 0, this.parentTextureArray = null, this.setResource(e)
                        }
                        get realWidth() {
                            return Math.round(this.width * this.resolution)
                        }
                        get realHeight() {
                            return Math.round(this.height * this.resolution)
                        }
                        get mipmap() {
                            return this._mipmap
                        }
                        set mipmap(e) {
                            this._mipmap !== e && (this._mipmap = e, this.dirtyStyleId++)
                        }
                        get scaleMode() {
                            return this._scaleMode
                        }
                        set scaleMode(e) {
                            this._scaleMode !== e && (this._scaleMode = e, this.dirtyStyleId++)
                        }
                        get wrapMode() {
                            return this._wrapMode
                        }
                        set wrapMode(e) {
                            this._wrapMode !== e && (this._wrapMode = e, this.dirtyStyleId++)
                        }
                        setStyle(e, t) {
                            let r;
                            return void 0 !== e && e !== this.scaleMode && (this.scaleMode = e, r = !0), void 0 !== t && t !== this.mipmap && (this.mipmap = t, r = !0), r && this.dirtyStyleId++, this
                        }
                        setSize(e, t, r) {
                            return r = r || this.resolution, this.setRealSize(e * r, t * r, r)
                        }
                        setRealSize(e, t, r) {
                            return this.resolution = r || this.resolution, this.width = Math.round(e) / this.resolution, this.height = Math.round(t) / this.resolution, this._refreshPOT(), this.update(), this
                        }
                        _refreshPOT() {
                            this.isPowerOfTwo = n.isPow2(this.realWidth) && n.isPow2(this.realHeight)
                        }
                        setResolution(e) {
                            const t = this.resolution;
                            return t === e || (this.resolution = e, this.valid && (this.width = Math.round(this.width * t) / e, this.height = Math.round(this.height * t) / e, this.emit("update", this)), this._refreshPOT()), this
                        }
                        setResource(e) {
                            if (this.resource === e) return this;
                            if (this.resource) throw new Error("Resource can be set only once");
                            return e.bind(this), this.resource = e, this
                        }
                        update() {
                            this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this))
                        }
                        onError(e) {
                            this.emit("error", this, e)
                        }
                        destroy() {
                            this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete n.BaseTextureCache[this.cacheId], delete n.TextureCache[this.cacheId], this.cacheId = null), this.dispose(), u.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0
                        }
                        dispose() {
                            this.emit("dispose", this)
                        }
                        castToBaseTexture() {
                            return this
                        }
                        static from(e, t, r = s.settings.STRICT_TEXTURE_CACHE) {
                            const i = "string" == typeof e;
                            let o = null;
                            if (i) o = e;
                            else {
                                if (!e._pixiId) {
                                    const r = t?.pixiIdPrefix || "pixiid";
                                    e._pixiId = `${r}_${n.uid()}`
                                }
                                o = e._pixiId
                            }
                            let a = n.BaseTextureCache[o];
                            if (i && r && !a) throw new Error(`The cacheId "${o}" does not exist in BaseTextureCache.`);
                            return a || (a = new u(e, t), a.cacheId = o, u.addToCache(a, o)), a
                        }
                        static fromBuffer(e, t, r, s) {
                            e = e || new Float32Array(t * r * 4);
                            const n = new a.BufferResource(e, {
                                    width: t,
                                    height: r
                                }),
                                o = e instanceof Float32Array ? i.TYPES.FLOAT : i.TYPES.UNSIGNED_BYTE;
                            return new u(n, Object.assign({}, l, s || {
                                width: t,
                                height: r,
                                type: o
                            }))
                        }
                        static addToCache(e, t) {
                            t && (e.textureCacheIds.includes(t) || e.textureCacheIds.push(t), n.BaseTextureCache[t] && n.BaseTextureCache[t] !== e && console.warn(`BaseTexture added to the cache with an id [${t}] that already had an entry`), n.BaseTextureCache[t] = e)
                        }
                        static removeFromCache(e) {
                            if ("string" == typeof e) {
                                const t = n.BaseTextureCache[e];
                                if (t) {
                                    const r = t.textureCacheIds.indexOf(e);
                                    return r > -1 && t.textureCacheIds.splice(r, 1), delete n.BaseTextureCache[e], t
                                }
                            } else if (e?.textureCacheIds) {
                                for (let t = 0; t < e.textureCacheIds.length; ++t) delete n.BaseTextureCache[e.textureCacheIds[t]];
                                return e.textureCacheIds.length = 0, e
                            }
                            return null
                        }
                    };
                let c = u;
                c.defaultOptions = {
                    mipmap: i.MIPMAP_MODES.POW2,
                    anisotropicLevel: 0,
                    scaleMode: i.SCALE_MODES.LINEAR,
                    wrapMode: i.WRAP_MODES.CLAMP,
                    alphaMode: i.ALPHA_MODES.UNPACK,
                    target: i.TARGETS.TEXTURE_2D,
                    format: i.FORMATS.RGBA,
                    type: i.TYPES.UNSIGNED_BYTE
                }, c._globalBatch = 0, t.BaseTexture = c
            },
            4981: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386);
                t.GLTexture = class {
                    constructor(e) {
                        this.texture = e, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = i.TYPES.UNSIGNED_BYTE, this.internalFormat = i.FORMATS.RGBA, this.samplerType = 0
                    }
                }
            },
            733: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(8153),
                    s = r(6667),
                    n = r(6128),
                    o = r(4291),
                    a = r(4211),
                    h = r(3144);
                const l = new h.TextureUvs;

                function u(e) {
                    e.destroy = function() {}, e.on = function() {}, e.once = function() {}, e.emit = function() {}
                }
                class c extends n.EventEmitter {
                    constructor(e, t, r, s, n, o, a) {
                        if (super(), this.noFrame = !1, t || (this.noFrame = !0, t = new i.Rectangle(0, 0, 1, 1)), e instanceof c && (e = e.baseTexture), this.baseTexture = e, this._frame = t, this.trim = s, this.valid = !1, this._uvs = l, this.uvMatrix = null, this.orig = r || t, this._rotate = Number(n || 0), !0 === n) this._rotate = 2;
                        else if (this._rotate % 2 != 0) throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
                        this.defaultAnchor = o ? new i.Point(o.x, o.y) : new i.Point(0, 0), this.defaultBorders = a, this._updateID = 0, this.textureCacheIds = [], e.valid ? this.noFrame ? e.valid && this.onBaseTextureUpdated(e) : this.frame = t : e.once("loaded", this.onBaseTextureUpdated, this), this.noFrame && e.on("update", this.onBaseTextureUpdated, this)
                    }
                    update() {
                        this.baseTexture.resource && this.baseTexture.resource.update()
                    }
                    onBaseTextureUpdated(e) {
                        if (this.noFrame) {
                            if (!this.baseTexture.valid) return;
                            this._frame.width = e.width, this._frame.height = e.height, this.valid = !0, this.updateUvs()
                        } else this.frame = this._frame;
                        this.emit("update", this)
                    }
                    destroy(e) {
                        if (this.baseTexture) {
                            if (e) {
                                const {
                                    resource: e
                                } = this.baseTexture;
                                e?.url && n.TextureCache[e.url] && c.removeFromCache(e.url), this.baseTexture.destroy()
                            }
                            this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null
                        }
                        this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, c.removeFromCache(this), this.textureCacheIds = null
                    }
                    clone() {
                        const e = this._frame.clone(),
                            t = this._frame === this.orig ? e : this.orig.clone(),
                            r = new c(this.baseTexture, !this.noFrame && e, t, this.trim?.clone(), this.rotate, this.defaultAnchor, this.defaultBorders);
                        return this.noFrame && (r._frame = e), r
                    }
                    updateUvs() {
                        this._uvs === l && (this._uvs = new h.TextureUvs), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++
                    }
                    static from(e, t = {}, r = s.settings.STRICT_TEXTURE_CACHE) {
                        const i = "string" == typeof e;
                        let a = null;
                        if (i) a = e;
                        else if (e instanceof o.BaseTexture) {
                            if (!e.cacheId) {
                                const r = t?.pixiIdPrefix || "pixiid";
                                e.cacheId = `${r}-${n.uid()}`, o.BaseTexture.addToCache(e, e.cacheId)
                            }
                            a = e.cacheId
                        } else {
                            if (!e._pixiId) {
                                const r = t?.pixiIdPrefix || "pixiid";
                                e._pixiId = `${r}_${n.uid()}`
                            }
                            a = e._pixiId
                        }
                        let h = n.TextureCache[a];
                        if (i && r && !h) throw new Error(`The cacheId "${a}" does not exist in TextureCache.`);
                        return h || e instanceof o.BaseTexture ? !h && e instanceof o.BaseTexture && (h = new c(e), c.addToCache(h, a)) : (t.resolution || (t.resolution = n.getResolutionOfUrl(e)), h = new c(new o.BaseTexture(e, t)), h.baseTexture.cacheId = a, o.BaseTexture.addToCache(h.baseTexture, a), c.addToCache(h, a)), h
                    }
                    static fromURL(e, t) {
                        const r = Object.assign({
                                autoLoad: !1
                            }, t?.resourceOptions),
                            i = c.from(e, Object.assign({
                                resourceOptions: r
                            }, t), !1),
                            s = i.baseTexture.resource;
                        return i.baseTexture.valid ? Promise.resolve(i) : s.load().then((() => Promise.resolve(i)))
                    }
                    static fromBuffer(e, t, r, i) {
                        return new c(o.BaseTexture.fromBuffer(e, t, r, i))
                    }
                    static fromLoader(e, t, r, i) {
                        const s = new o.BaseTexture(e, Object.assign({
                                scaleMode: o.BaseTexture.defaultOptions.scaleMode,
                                resolution: n.getResolutionOfUrl(t)
                            }, i)),
                            {
                                resource: h
                            } = s;
                        h instanceof a.ImageResource && (h.url = t);
                        const l = new c(s);
                        return r || (r = t), o.BaseTexture.addToCache(l.baseTexture, r), c.addToCache(l, r), r !== t && (o.BaseTexture.addToCache(l.baseTexture, t), c.addToCache(l, t)), l.baseTexture.valid ? Promise.resolve(l) : new Promise((e => {
                            l.baseTexture.once("loaded", (() => e(l)))
                        }))
                    }
                    static addToCache(e, t) {
                        t && (e.textureCacheIds.includes(t) || e.textureCacheIds.push(t), n.TextureCache[t] && n.TextureCache[t] !== e && console.warn(`Texture added to the cache with an id [${t}] that already had an entry`), n.TextureCache[t] = e)
                    }
                    static removeFromCache(e) {
                        if ("string" == typeof e) {
                            const t = n.TextureCache[e];
                            if (t) {
                                const r = t.textureCacheIds.indexOf(e);
                                return r > -1 && t.textureCacheIds.splice(r, 1), delete n.TextureCache[e], t
                            }
                        } else if (e?.textureCacheIds) {
                            for (let t = 0; t < e.textureCacheIds.length; ++t) n.TextureCache[e.textureCacheIds[t]] === e && delete n.TextureCache[e.textureCacheIds[t]];
                            return e.textureCacheIds.length = 0, e
                        }
                        return null
                    }
                    get resolution() {
                        return this.baseTexture.resolution
                    }
                    get frame() {
                        return this._frame
                    }
                    set frame(e) {
                        this._frame = e, this.noFrame = !1;
                        const {
                            x: t,
                            y: r,
                            width: i,
                            height: s
                        } = e, n = t + i > this.baseTexture.width, o = r + s > this.baseTexture.height;
                        if (n || o) {
                            const e = n && o ? "and" : "or",
                                a = `X: ${t} + ${i} = ${t+i} > ${this.baseTexture.width}`,
                                h = `Y: ${r} + ${s} = ${r+s} > ${this.baseTexture.height}`;
                            throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${a} ${e} ${h}`)
                        }
                        this.valid = i && s && this.baseTexture.valid, this.trim || this.rotate || (this.orig = e), this.valid && this.updateUvs()
                    }
                    get rotate() {
                        return this._rotate
                    }
                    set rotate(e) {
                        this._rotate = e, this.valid && this.updateUvs()
                    }
                    get width() {
                        return this.orig.width
                    }
                    get height() {
                        return this.orig.height
                    }
                    castToBaseTexture() {
                        return this.baseTexture
                    }
                    static get EMPTY() {
                        return c._EMPTY || (c._EMPTY = new c(new o.BaseTexture), u(c._EMPTY), u(c._EMPTY.baseTexture)), c._EMPTY
                    }
                    static get WHITE() {
                        if (!c._WHITE) {
                            const e = s.settings.ADAPTER.createCanvas(16, 16),
                                t = e.getContext("2d");
                            e.width = 16, e.height = 16, t.fillStyle = "white", t.fillRect(0, 0, 16, 16), c._WHITE = new c(o.BaseTexture.from(e)), u(c._WHITE), u(c._WHITE.baseTexture)
                        }
                        return c._WHITE
                    }
                }
                t.Texture = c
            },
            6037: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(7222);
                const n = class {
                    constructor(e) {
                        this.renderer = e, this.count = 0, this.checkCount = 0, this.maxIdle = n.defaultMaxIdle, this.checkCountMax = n.defaultCheckCountMax, this.mode = n.defaultMode
                    }
                    postrender() {
                        this.renderer.objectRenderer.renderingToScreen && (this.count++, this.mode !== i.GC_MODES.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())))
                    }
                    run() {
                        const e = this.renderer.texture,
                            t = e.managedTextures;
                        let r = !1;
                        for (let i = 0; i < t.length; i++) {
                            const s = t[i];
                            !s.framebuffer && this.count - s.touched > this.maxIdle && (e.destroyTexture(s, !0), t[i] = null, r = !0)
                        }
                        if (r) {
                            let e = 0;
                            for (let r = 0; r < t.length; r++) null !== t[r] && (t[e++] = t[r]);
                            t.length = e
                        }
                    }
                    unload(e) {
                        const t = this.renderer.texture,
                            r = e._texture;
                        r && !r.framebuffer && t.destroyTexture(r);
                        for (let t = e.children.length - 1; t >= 0; t--) this.unload(e.children[t])
                    }
                    destroy() {
                        this.renderer = null
                    }
                };
                let o = n;
                o.defaultMode = i.GC_MODES.AUTO, o.defaultMaxIdle = 3600, o.defaultCheckCountMax = 600, o.extension = {
                    type: s.ExtensionType.RendererSystem,
                    name: "textureGC"
                }, s.extensions.add(o), t.TextureGCSystem = o
            },
            1826: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(8153);
                const s = new i.Matrix;
                t.TextureMatrix = class {
                    constructor(e, t) {
                        this._texture = e, this.mapCoord = new i.Matrix, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = void 0 === t ? .5 : t, this.isSimple = !1
                    }
                    get texture() {
                        return this._texture
                    }
                    set texture(e) {
                        this._texture = e, this._textureID = -1
                    }
                    multiplyUvs(e, t) {
                        void 0 === t && (t = e);
                        const r = this.mapCoord;
                        for (let i = 0; i < e.length; i += 2) {
                            const s = e[i],
                                n = e[i + 1];
                            t[i] = s * r.a + n * r.c + r.tx, t[i + 1] = s * r.b + n * r.d + r.ty
                        }
                        return t
                    }
                    update(e) {
                        const t = this._texture;
                        if (!t || !t.valid) return !1;
                        if (!e && this._textureID === t._updateID) return !1;
                        this._textureID = t._updateID, this._updateID++;
                        const r = t._uvs;
                        this.mapCoord.set(r.x1 - r.x0, r.y1 - r.y0, r.x3 - r.x0, r.y3 - r.y0, r.x0, r.y0);
                        const i = t.orig,
                            n = t.trim;
                        n && (s.set(i.width / n.width, 0, 0, i.height / n.height, -n.x / n.width, -n.y / n.height), this.mapCoord.append(s));
                        const o = t.baseTexture,
                            a = this.uClampFrame,
                            h = this.clampMargin / o.resolution,
                            l = this.clampOffset;
                        return a[0] = (t._frame.x + h + l) / o.width, a[1] = (t._frame.y + h + l) / o.height, a[2] = (t._frame.x + t._frame.width - h + l) / o.width, a[3] = (t._frame.y + t._frame.height - h + l) / o.height, this.uClampOffset[0] = l / o.realWidth, this.uClampOffset[1] = l / o.realHeight, this.isSimple = t._frame.width === o.width && t._frame.height === o.height && 0 === t.rotate, !0
                    }
                }
            },
            4584: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(7222),
                    n = r(6128),
                    o = r(4291),
                    a = r(4981),
                    h = r(6921);
                class l {
                    constructor(e) {
                        this.renderer = e, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new o.BaseTexture, this.hasIntegerTextures = !1
                    }
                    contextChange() {
                        const e = this.gl = this.renderer.gl;
                        this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = h.mapTypeAndFormatToInternalFormat(e);
                        const t = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);
                        this.boundTextures.length = t;
                        for (let e = 0; e < t; e++) this.boundTextures[e] = null;
                        this.emptyTextures = {};
                        const r = new a.GLTexture(e.createTexture());
                        e.bindTexture(e.TEXTURE_2D, r.texture), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[e.TEXTURE_2D] = r, this.emptyTextures[e.TEXTURE_CUBE_MAP] = new a.GLTexture(e.createTexture()), e.bindTexture(e.TEXTURE_CUBE_MAP, this.emptyTextures[e.TEXTURE_CUBE_MAP].texture);
                        for (let t = 0; t < 6; t++) e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, null);
                        e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_MIN_FILTER, e.LINEAR);
                        for (let e = 0; e < this.boundTextures.length; e++) this.bind(null, e)
                    }
                    bind(e, t = 0) {
                        const {
                            gl: r
                        } = this;
                        if (e = e?.castToBaseTexture(), e?.valid && !e.parentTextureArray) {
                            e.touched = this.renderer.textureGC.count;
                            const i = e._glTextures[this.CONTEXT_UID] || this.initTexture(e);
                            this.boundTextures[t] !== e && (this.currentLocation !== t && (this.currentLocation = t, r.activeTexture(r.TEXTURE0 + t)), r.bindTexture(e.target, i.texture)), i.dirtyId !== e.dirtyId ? (this.currentLocation !== t && (this.currentLocation = t, r.activeTexture(r.TEXTURE0 + t)), this.updateTexture(e)) : i.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(e), this.boundTextures[t] = e
                        } else this.currentLocation !== t && (this.currentLocation = t, r.activeTexture(r.TEXTURE0 + t)), r.bindTexture(r.TEXTURE_2D, this.emptyTextures[r.TEXTURE_2D].texture), this.boundTextures[t] = null
                    }
                    reset() {
                        this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;
                        for (let e = 0; e < this.boundTextures.length; e++) this.boundTextures[e] = this.unknownTexture
                    }
                    unbind(e) {
                        const {
                            gl: t,
                            boundTextures: r
                        } = this;
                        if (this._unknownBoundTextures) {
                            this._unknownBoundTextures = !1;
                            for (let e = 0; e < r.length; e++) r[e] === this.unknownTexture && this.bind(null, e)
                        }
                        for (let i = 0; i < r.length; i++) r[i] === e && (this.currentLocation !== i && (t.activeTexture(t.TEXTURE0 + i), this.currentLocation = i), t.bindTexture(e.target, this.emptyTextures[e.target].texture), r[i] = null)
                    }
                    ensureSamplerType(e) {
                        const {
                            boundTextures: t,
                            hasIntegerTextures: r,
                            CONTEXT_UID: s
                        } = this;
                        if (r)
                            for (let r = e - 1; r >= 0; --r) {
                                const e = t[r];
                                e && e._glTextures[s].samplerType !== i.SAMPLER_TYPES.FLOAT && this.renderer.texture.unbind(e)
                            }
                    }
                    initTexture(e) {
                        const t = new a.GLTexture(this.gl.createTexture());
                        return t.dirtyId = -1, e._glTextures[this.CONTEXT_UID] = t, this.managedTextures.push(e), e.on("dispose", this.destroyTexture, this), t
                    }
                    initTextureType(e, t) {
                        t.internalFormat = this.internalFormats[e.type]?.[e.format] ?? e.format, 2 === this.webGLVersion && e.type === i.TYPES.HALF_FLOAT ? t.type = this.gl.HALF_FLOAT : t.type = e.type
                    }
                    updateTexture(e) {
                        const t = e._glTextures[this.CONTEXT_UID];
                        if (!t) return;
                        const r = this.renderer;
                        if (this.initTextureType(e, t), e.resource?.upload(r, e, t)) t.samplerType !== i.SAMPLER_TYPES.FLOAT && (this.hasIntegerTextures = !0);
                        else {
                            const i = e.realWidth,
                                s = e.realHeight,
                                n = r.gl;
                            (t.width !== i || t.height !== s || t.dirtyId < 0) && (t.width = i, t.height = s, n.texImage2D(e.target, 0, t.internalFormat, i, s, 0, e.format, t.type, null))
                        }
                        e.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(e), t.dirtyId = e.dirtyId
                    }
                    destroyTexture(e, t) {
                        const {
                            gl: r
                        } = this;
                        if ((e = e.castToBaseTexture())._glTextures[this.CONTEXT_UID] && (this.unbind(e), r.deleteTexture(e._glTextures[this.CONTEXT_UID].texture), e.off("dispose", this.destroyTexture, this), delete e._glTextures[this.CONTEXT_UID], !t)) {
                            const t = this.managedTextures.indexOf(e); - 1 !== t && n.removeItems(this.managedTextures, t, 1)
                        }
                    }
                    updateTextureStyle(e) {
                        const t = e._glTextures[this.CONTEXT_UID];
                        t && (e.mipmap !== i.MIPMAP_MODES.POW2 && 2 === this.webGLVersion || e.isPowerOfTwo ? t.mipmap = e.mipmap >= 1 : t.mipmap = !1, 2 === this.webGLVersion || e.isPowerOfTwo ? t.wrapMode = e.wrapMode : t.wrapMode = i.WRAP_MODES.CLAMP, e.resource?.style(this.renderer, e, t) || this.setStyle(e, t), t.dirtyStyleId = e.dirtyStyleId)
                    }
                    setStyle(e, t) {
                        const r = this.gl;
                        if (t.mipmap && e.mipmap !== i.MIPMAP_MODES.ON_MANUAL && r.generateMipmap(e.target), r.texParameteri(e.target, r.TEXTURE_WRAP_S, t.wrapMode), r.texParameteri(e.target, r.TEXTURE_WRAP_T, t.wrapMode), t.mipmap) {
                            r.texParameteri(e.target, r.TEXTURE_MIN_FILTER, e.scaleMode === i.SCALE_MODES.LINEAR ? r.LINEAR_MIPMAP_LINEAR : r.NEAREST_MIPMAP_NEAREST);
                            const t = this.renderer.context.extensions.anisotropicFiltering;
                            if (t && e.anisotropicLevel > 0 && e.scaleMode === i.SCALE_MODES.LINEAR) {
                                const i = Math.min(e.anisotropicLevel, r.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
                                r.texParameterf(e.target, t.TEXTURE_MAX_ANISOTROPY_EXT, i)
                            }
                        } else r.texParameteri(e.target, r.TEXTURE_MIN_FILTER, e.scaleMode === i.SCALE_MODES.LINEAR ? r.LINEAR : r.NEAREST);
                        r.texParameteri(e.target, r.TEXTURE_MAG_FILTER, e.scaleMode === i.SCALE_MODES.LINEAR ? r.LINEAR : r.NEAREST)
                    }
                    destroy() {
                        this.renderer = null
                    }
                }
                l.extension = {
                    type: s.ExtensionType.RendererSystem,
                    name: "texture"
                }, s.extensions.add(l), t.TextureSystem = l
            },
            3144: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(8153);
                t.TextureUvs = class {
                    constructor() {
                        this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8)
                    }
                    set(e, t, r) {
                        const s = t.width,
                            n = t.height;
                        if (r) {
                            const t = e.width / 2 / s,
                                o = e.height / 2 / n,
                                a = e.x / s + t,
                                h = e.y / n + o;
                            r = i.groupD8.add(r, i.groupD8.NW), this.x0 = a + t * i.groupD8.uX(r), this.y0 = h + o * i.groupD8.uY(r), r = i.groupD8.add(r, 2), this.x1 = a + t * i.groupD8.uX(r), this.y1 = h + o * i.groupD8.uY(r), r = i.groupD8.add(r, 2), this.x2 = a + t * i.groupD8.uX(r), this.y2 = h + o * i.groupD8.uY(r), r = i.groupD8.add(r, 2), this.x3 = a + t * i.groupD8.uX(r), this.y3 = h + o * i.groupD8.uY(r)
                        } else this.x0 = e.x / s, this.y0 = e.y / n, this.x1 = (e.x + e.width) / s, this.y1 = e.y / n, this.x2 = (e.x + e.width) / s, this.y2 = (e.y + e.height) / n, this.x3 = e.x / s, this.y3 = (e.y + e.height) / n;
                        this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3
                    }
                    toString() {
                        return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`
                    }
                }
            },
            8566: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(4291),
                    s = r(1857),
                    n = r(3227);
                class o extends n.Resource {
                    constructor(e, t) {
                        const {
                            width: r,
                            height: s
                        } = t || {};
                        super(r, s), this.items = [], this.itemDirtyIds = [];
                        for (let t = 0; t < e; t++) {
                            const e = new i.BaseTexture;
                            this.items.push(e), this.itemDirtyIds.push(-2)
                        }
                        this.length = e, this._load = null, this.baseTexture = null
                    }
                    initFromArray(e, t) {
                        for (let r = 0; r < this.length; r++) e[r] && (e[r].castToBaseTexture ? this.addBaseTextureAt(e[r].castToBaseTexture(), r) : e[r] instanceof n.Resource ? this.addResourceAt(e[r], r) : this.addResourceAt(s.autoDetectResource(e[r], t), r))
                    }
                    dispose() {
                        for (let e = 0, t = this.length; e < t; e++) this.items[e].destroy();
                        this.items = null, this.itemDirtyIds = null, this._load = null
                    }
                    addResourceAt(e, t) {
                        if (!this.items[t]) throw new Error(`Index ${t} is out of bounds`);
                        return e.valid && !this.valid && this.resize(e.width, e.height), this.items[t].setResource(e), this
                    }
                    bind(e) {
                        if (null !== this.baseTexture) throw new Error("Only one base texture per TextureArray is allowed");
                        super.bind(e);
                        for (let t = 0; t < this.length; t++) this.items[t].parentTextureArray = e, this.items[t].on("update", e.update, e)
                    }
                    unbind(e) {
                        super.unbind(e);
                        for (let t = 0; t < this.length; t++) this.items[t].parentTextureArray = null, this.items[t].off("update", e.update, e)
                    }
                    load() {
                        if (this._load) return this._load;
                        const e = this.items.map((e => e.resource)).filter((e => e)).map((e => e.load()));
                        return this._load = Promise.all(e).then((() => {
                            const {
                                realWidth: e,
                                realHeight: t
                            } = this.items[0];
                            return this.resize(e, t), Promise.resolve(this)
                        })), this._load
                    }
                }
                t.AbstractMultiResource = o
            },
            6869: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(8566);
                class n extends s.AbstractMultiResource {
                    constructor(e, t) {
                        const {
                            width: r,
                            height: i
                        } = t || {};
                        let s, n;
                        Array.isArray(e) ? (s = e, n = e.length) : n = e, super(n, {
                            width: r,
                            height: i
                        }), s && this.initFromArray(s, t)
                    }
                    addBaseTextureAt(e, t) {
                        if (!e.resource) throw new Error("ArrayResource does not support RenderTexture");
                        return this.addResourceAt(e.resource, t), this
                    }
                    bind(e) {
                        super.bind(e), e.target = i.TARGETS.TEXTURE_2D_ARRAY
                    }
                    upload(e, t, r) {
                        const {
                            length: i,
                            itemDirtyIds: s,
                            items: n
                        } = this, {
                            gl: o
                        } = e;
                        r.dirtyId < 0 && o.texImage3D(o.TEXTURE_2D_ARRAY, 0, r.internalFormat, this._width, this._height, i, 0, t.format, r.type, null);
                        for (let e = 0; e < i; e++) {
                            const i = n[e];
                            s[e] < i.dirtyId && (s[e] = i.dirtyId, i.valid && o.texSubImage3D(o.TEXTURE_2D_ARRAY, 0, 0, 0, e, i.resource.width, i.resource.height, 1, t.format, r.type, i.resource.source))
                        }
                        return !0
                    }
                }
                t.ArrayResource = n
            },
            2094: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(6128),
                    n = r(3227);
                class o extends n.Resource {
                    constructor(e) {
                        const t = e;
                        super(t.naturalWidth || t.videoWidth || t.width, t.naturalHeight || t.videoHeight || t.height), this.source = e, this.noSubImage = !1
                    }
                    static crossOrigin(e, t, r) {
                        void 0 !== r || t.startsWith("data:") ? !1 !== r && (e.crossOrigin = "string" == typeof r ? r : "anonymous") : e.crossOrigin = s.determineCrossOrigin(t)
                    }
                    upload(e, t, r, s) {
                        const n = e.gl,
                            o = t.realWidth,
                            a = t.realHeight;
                        if (s = s || this.source, "undefined" != typeof HTMLImageElement && s instanceof HTMLImageElement) {
                            if (!s.complete || 0 === s.naturalWidth) return !1
                        } else if ("undefined" != typeof HTMLVideoElement && s instanceof HTMLVideoElement && s.readyState <= 1 && 0 === s.buffered.length) return !1;
                        return n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.alphaMode === i.ALPHA_MODES.UNPACK), this.noSubImage || t.target !== n.TEXTURE_2D || r.width !== o || r.height !== a ? (r.width = o, r.height = a, n.texImage2D(t.target, 0, r.internalFormat, t.format, r.type, s)) : n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, t.format, r.type, s), !0
                    }
                    update() {
                        if (this.destroyed) return;
                        const e = this.source,
                            t = e.naturalWidth || e.videoWidth || e.width,
                            r = e.naturalHeight || e.videoHeight || e.height;
                        this.resize(t, r), super.update()
                    }
                    dispose() {
                        this.source = null
                    }
                }
                t.BaseImageResource = o
            },
            2297: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(3227);
                class n extends s.Resource {
                    constructor(e, t) {
                        const {
                            width: r,
                            height: i
                        } = t || {};
                        if (!r || !i) throw new Error("BufferResource width or height invalid");
                        super(r, i), this.data = e
                    }
                    upload(e, t, r) {
                        const s = e.gl;
                        s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.alphaMode === i.ALPHA_MODES.UNPACK);
                        const n = t.realWidth,
                            o = t.realHeight;
                        return r.width === n && r.height === o ? s.texSubImage2D(t.target, 0, 0, 0, n, o, t.format, r.type, this.data) : (r.width = n, r.height = o, s.texImage2D(t.target, 0, r.internalFormat, n, o, 0, t.format, r.type, this.data)), !0
                    }
                    dispose() {
                        this.data = null
                    }
                    static test(e) {
                        return e instanceof Float32Array || e instanceof Uint8Array || e instanceof Uint32Array
                    }
                }
                t.BufferResource = n
            },
            6946: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2094);
                class s extends i.BaseImageResource {
                    constructor(e) {
                        super(e)
                    }
                    static test(e) {
                        const {
                            OffscreenCanvas: t
                        } = globalThis;
                        return !!(t && e instanceof t) || globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement
                    }
                }
                t.CanvasResource = s
            },
            1293: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(8566);
                const n = class extends s.AbstractMultiResource {
                    constructor(e, t) {
                        const {
                            width: r,
                            height: s,
                            autoLoad: o,
                            linkBaseTexture: a
                        } = t || {};
                        if (e && e.length !== n.SIDES) throw new Error(`Invalid length. Got ${e.length}, expected 6`);
                        super(6, {
                            width: r,
                            height: s
                        });
                        for (let e = 0; e < n.SIDES; e++) this.items[e].target = i.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + e;
                        this.linkBaseTexture = !1 !== a, e && this.initFromArray(e, t), !1 !== o && this.load()
                    }
                    bind(e) {
                        super.bind(e), e.target = i.TARGETS.TEXTURE_CUBE_MAP
                    }
                    addBaseTextureAt(e, t, r) {
                        if (void 0 === r && (r = this.linkBaseTexture), !this.items[t]) throw new Error(`Index ${t} is out of bounds`);
                        if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0) {
                            if (!e.resource) throw new Error("CubeResource does not support copying of renderTexture.");
                            this.addResourceAt(e.resource, t)
                        } else e.target = i.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + t, e.parentTextureArray = this.baseTexture, this.items[t] = e;
                        return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight), this.items[t] = e, this
                    }
                    upload(e, t, r) {
                        const i = this.itemDirtyIds;
                        for (let s = 0; s < n.SIDES; s++) {
                            const n = this.items[s];
                            (i[s] < n.dirtyId || r.dirtyId < t.dirtyId) && (n.valid && n.resource ? (n.resource.upload(e, n, r), i[s] = n.dirtyId) : i[s] < -1 && (e.gl.texImage2D(n.target, 0, r.internalFormat, t.realWidth, t.realHeight, 0, t.format, r.type, null), i[s] = -1))
                        }
                        return !0
                    }
                    static test(e) {
                        return Array.isArray(e) && e.length === n.SIDES
                    }
                };
                let o = n;
                o.SIDES = 6, t.CubeResource = o
            },
            6200: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(2297);
                class n extends s.BufferResource {
                    upload(e, t, r) {
                        const s = e.gl;
                        s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.alphaMode === i.ALPHA_MODES.UNPACK);
                        const n = t.realWidth,
                            o = t.realHeight;
                        return r.width === n && r.height === o ? s.texSubImage2D(t.target, 0, 0, 0, n, o, t.format, r.type, this.data) : (r.width = n, r.height = o, s.texImage2D(t.target, 0, r.internalFormat, n, o, 0, t.format, r.type, this.data)), !0
                    }
                }
                t.DepthResource = n
            },
            6093: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(6667),
                    n = r(2094);
                class o extends n.BaseImageResource {
                    constructor(e, t) {
                        let r, i;
                        t = t || {}, "string" == typeof e ? (r = o.EMPTY, i = e) : (r = e, i = null), super(r), this.url = i, this.crossOrigin = t.crossOrigin ?? !0, this.alphaMode = "number" == typeof t.alphaMode ? t.alphaMode : null, this._load = null, !1 !== t.autoLoad && this.load()
                    }
                    load() {
                        return this._load || (this._load = new Promise((async (e, t) => {
                            if (null !== this.url) try {
                                const t = await s.settings.ADAPTER.fetch(this.url, {
                                    mode: this.crossOrigin ? "cors" : "no-cors"
                                });
                                if (this.destroyed) return;
                                const r = await t.blob();
                                if (this.destroyed) return;
                                const n = await createImageBitmap(r, {
                                    premultiplyAlpha: null === this.alphaMode || this.alphaMode === i.ALPHA_MODES.UNPACK ? "premultiply" : "none"
                                });
                                if (this.destroyed) return;
                                this.source = n, this.update(), e(this)
                            } catch (e) {
                                if (this.destroyed) return;
                                t(e), this.onError.emit(e)
                            } else e(this)
                        }))), this._load
                    }
                    upload(e, t, r) {
                        return this.source instanceof ImageBitmap ? ("number" == typeof this.alphaMode && (t.alphaMode = this.alphaMode), super.upload(e, t, r)) : (this.load(), !1)
                    }
                    dispose() {
                        this.source instanceof ImageBitmap && this.source.close(), super.dispose(), this._load = null
                    }
                    static test(e) {
                        return !!globalThis.createImageBitmap && "undefined" != typeof ImageBitmap && ("string" == typeof e || e instanceof ImageBitmap)
                    }
                    static get EMPTY() {
                        return o._EMPTY = o._EMPTY ?? s.settings.ADAPTER.createCanvas(0, 0), o._EMPTY
                    }
                }
                t.ImageBitmapResource = o
            },
            4211: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386),
                    s = r(6667),
                    n = r(2094);
                class o extends n.BaseImageResource {
                    constructor(e, t) {
                        if (t = t || {}, "string" == typeof e) {
                            const r = new Image;
                            n.BaseImageResource.crossOrigin(r, e, t.crossorigin), r.src = e, e = r
                        }
                        super(e), !e.complete && this._width && this._height && (this._width = 0, this._height = 0), this.url = e.src, this._process = null, this.preserveBitmap = !1, this.createBitmap = (t.createBitmap ?? s.settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, this.alphaMode = "number" == typeof t.alphaMode ? t.alphaMode : null, this.bitmap = null, this._load = null, !1 !== t.autoLoad && this.load()
                    }
                    load(e) {
                        return this._load || (void 0 !== e && (this.createBitmap = e), this._load = new Promise(((e, t) => {
                            const r = this.source;
                            this.url = r.src;
                            const i = () => {
                                this.destroyed || (r.onload = null, r.onerror = null, this.resize(r.width, r.height), this._load = null, this.createBitmap ? e(this.process()) : e(this))
                            };
                            r.complete && r.src ? i() : (r.onload = i, r.onerror = e => {
                                t(e), this.onError.emit(e)
                            })
                        }))), this._load
                    }
                    process() {
                        const e = this.source;
                        if (null !== this._process) return this._process;
                        if (null !== this.bitmap || !globalThis.createImageBitmap) return Promise.resolve(this);
                        const t = globalThis.createImageBitmap,
                            r = !e.crossOrigin || "anonymous" === e.crossOrigin;
                        return this._process = fetch(e.src, {
                            mode: r ? "cors" : "no-cors"
                        }).then((e => e.blob())).then((r => t(r, 0, 0, e.width, e.height, {
                            premultiplyAlpha: null === this.alphaMode || this.alphaMode === i.ALPHA_MODES.UNPACK ? "premultiply" : "none"
                        }))).then((e => this.destroyed ? Promise.reject() : (this.bitmap = e, this.update(), this._process = null, Promise.resolve(this)))), this._process
                    }
                    upload(e, t, r) {
                        if ("number" == typeof this.alphaMode && (t.alphaMode = this.alphaMode), !this.createBitmap) return super.upload(e, t, r);
                        if (!this.bitmap && (this.process(), !this.bitmap)) return !1;
                        if (super.upload(e, t, r, this.bitmap), !this.preserveBitmap) {
                            let e = !0;
                            const i = t._glTextures;
                            for (const s in i) {
                                const n = i[s];
                                if (n !== r && n.dirtyId !== t.dirtyId) {
                                    e = !1;
                                    break
                                }
                            }
                            e && (this.bitmap.close && this.bitmap.close(), this.bitmap = null)
                        }
                        return !0
                    }
                    dispose() {
                        this.source.onload = null, this.source.onerror = null, super.dispose(), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null
                    }
                    static test(e) {
                        return "undefined" != typeof HTMLImageElement && ("string" == typeof e || e instanceof HTMLImageElement)
                    }
                }
                t.ImageResource = o
            },
            3227: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(5802);
                t.Resource = class {
                    constructor(e = 0, t = 0) {
                        this._width = e, this._height = t, this.destroyed = !1, this.internal = !1, this.onResize = new i.Runner("setRealSize"), this.onUpdate = new i.Runner("update"), this.onError = new i.Runner("onError")
                    }
                    bind(e) {
                        this.onResize.add(e), this.onUpdate.add(e), this.onError.add(e), (this._width || this._height) && this.onResize.emit(this._width, this._height)
                    }
                    unbind(e) {
                        this.onResize.remove(e), this.onUpdate.remove(e), this.onError.remove(e)
                    }
                    resize(e, t) {
                        e === this._width && t === this._height || (this._width = e, this._height = t, this.onResize.emit(e, t))
                    }
                    get valid() {
                        return !!this._width && !!this._height
                    }
                    update() {
                        this.destroyed || this.onUpdate.emit()
                    }
                    load() {
                        return Promise.resolve(this)
                    }
                    get width() {
                        return this._width
                    }
                    get height() {
                        return this._height
                    }
                    style(e, t, r) {
                        return !1
                    }
                    dispose() {}
                    destroy() {
                        this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null)
                    }
                    static test(e, t) {
                        return !1
                    }
                }
            },
            1346: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(6667),
                    s = r(6128),
                    n = r(2094);
                const o = class extends n.BaseImageResource {
                    constructor(e, t) {
                        t = t || {}, super(i.settings.ADAPTER.createCanvas()), this._width = 0, this._height = 0, this.svg = e, this.scale = t.scale || 1, this._overrideWidth = t.width, this._overrideHeight = t.height, this._resolve = null, this._crossorigin = t.crossorigin, this._load = null, !1 !== t.autoLoad && this.load()
                    }
                    load() {
                        return this._load || (this._load = new Promise((e => {
                            if (this._resolve = () => {
                                    this.resize(this.source.width, this.source.height), e(this)
                                }, o.SVG_XML.test(this.svg.trim())) {
                                if (!btoa) throw new Error("Your browser doesn't support base64 conversions.");
                                this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`
                            }
                            this._loadSvg()
                        }))), this._load
                    }
                    _loadSvg() {
                        const e = new Image;
                        n.BaseImageResource.crossOrigin(e, this.svg, this._crossorigin), e.src = this.svg, e.onerror = t => {
                            this._resolve && (e.onerror = null, this.onError.emit(t))
                        }, e.onload = () => {
                            if (!this._resolve) return;
                            const t = e.width,
                                r = e.height;
                            if (!t || !r) throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
                            let i = t * this.scale,
                                n = r * this.scale;
                            (this._overrideWidth || this._overrideHeight) && (i = this._overrideWidth || this._overrideHeight / r * t, n = this._overrideHeight || this._overrideWidth / t * r), i = Math.round(i), n = Math.round(n);
                            const o = this.source;
                            o.width = i, o.height = n, o._pixiId = `canvas_${s.uid()}`, o.getContext("2d").drawImage(e, 0, 0, t, r, 0, 0, i, n), this._resolve(), this._resolve = null
                        }
                    }
                    static getSize(e) {
                        const t = o.SVG_SIZE.exec(e),
                            r = {};
                        return t && (r[t[1]] = Math.round(parseFloat(t[3])), r[t[5]] = Math.round(parseFloat(t[7]))), r
                    }
                    dispose() {
                        super.dispose(), this._resolve = null, this._crossorigin = null
                    }
                    static test(e, t) {
                        return "svg" === t || "string" == typeof e && e.startsWith("data:image/svg+xml") || "string" == typeof e && o.SVG_XML.test(e)
                    }
                };
                let a = o;
                a.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, a.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, t.SVGResource = a
            },
            7448: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(6763),
                    s = r(2094);
                const n = class extends s.BaseImageResource {
                    constructor(e, t) {
                        if (t = t || {}, !(e instanceof HTMLVideoElement)) {
                            const r = document.createElement("video");
                            r.setAttribute("preload", "auto"), r.setAttribute("webkit-playsinline", ""), r.setAttribute("playsinline", ""), "string" == typeof e && (e = [e]);
                            const i = e[0].src || e[0];
                            s.BaseImageResource.crossOrigin(r, i, t.crossorigin);
                            for (let t = 0; t < e.length; ++t) {
                                const i = document.createElement("source");
                                let {
                                    src: s,
                                    mime: o
                                } = e[t];
                                s = s || e[t];
                                const a = s.split("?").shift().toLowerCase(),
                                    h = a.slice(a.lastIndexOf(".") + 1);
                                o = o || n.MIME_TYPES[h] || `video/${h}`, i.src = s, i.type = o, r.appendChild(i)
                            }
                            e = r
                        }
                        super(e), this.noSubImage = !0, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = t.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = !1 !== t.autoPlay, this._load = null, this._resolve = null, this._onCanPlay = this._onCanPlay.bind(this), this._onError = this._onError.bind(this), !1 !== t.autoLoad && this.load()
                    }
                    update(e = 0) {
                        if (!this.destroyed) {
                            const e = i.Ticker.shared.elapsedMS * this.source.playbackRate;
                            this._msToNextUpdate = Math.floor(this._msToNextUpdate - e), (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0)
                        }
                    }
                    load() {
                        if (this._load) return this._load;
                        const e = this.source;
                        return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0), e.addEventListener("play", this._onPlayStart.bind(this)), e.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlay), e.addEventListener("error", this._onError, !0)), this._load = new Promise((t => {
                            this.valid ? t(this) : (this._resolve = t, e.load())
                        })), this._load
                    }
                    _onError(e) {
                        this.source.removeEventListener("error", this._onError, !0), this.onError.emit(e)
                    }
                    _isSourcePlaying() {
                        const e = this.source;
                        return !e.paused && !e.ended && this._isSourceReady()
                    }
                    _isSourceReady() {
                        return this.source.readyState > 2
                    }
                    _onPlayStart() {
                        this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (i.Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0)
                    }
                    _onPlayStop() {
                        this._isConnectedToTicker && (i.Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1)
                    }
                    _onCanPlay() {
                        const e = this.source;
                        e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlay);
                        const t = this.valid;
                        this.resize(e.videoWidth, e.videoHeight), !t && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play()
                    }
                    dispose() {
                        this._isConnectedToTicker && (i.Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1);
                        const e = this.source;
                        e && (e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), super.dispose()
                    }
                    get autoUpdate() {
                        return this._autoUpdate
                    }
                    set autoUpdate(e) {
                        e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (i.Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (i.Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0))
                    }
                    get updateFPS() {
                        return this._updateFPS
                    }
                    set updateFPS(e) {
                        e !== this._updateFPS && (this._updateFPS = e)
                    }
                    static test(e, t) {
                        return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement || n.TYPES.includes(t)
                    }
                };
                let o = n;
                o.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], o.MIME_TYPES = {
                    ogv: "video/ogg",
                    mov: "video/quicktime",
                    m4v: "video/mp4"
                }, t.VideoResource = o
            },
            1857: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const r = [];
                t.INSTALLED = r, t.autoDetectResource = function(e, t) {
                    if (!e) return null;
                    let i = "";
                    if ("string" == typeof e) {
                        const t = /\.(\w{3,4})(?:$|\?|#)/i.exec(e);
                        t && (i = t[1].toLowerCase())
                    }
                    for (let s = r.length - 1; s >= 0; --s) {
                        const n = r[s];
                        if (n.test && n.test(e, i)) return new n(e, t)
                    }
                    throw new Error("Unrecognized source type to auto-detect Resource")
                }
            },
            3582: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(6869),
                    s = r(1857),
                    n = r(2297),
                    o = r(6946),
                    a = r(1293),
                    h = r(6093),
                    l = r(4211),
                    u = r(1346),
                    c = r(7448),
                    d = r(2094),
                    p = r(3227),
                    f = r(8566);
                s.INSTALLED.push(h.ImageBitmapResource, l.ImageResource, o.CanvasResource, c.VideoResource, u.SVGResource, n.BufferResource, a.CubeResource, i.ArrayResource), t.ArrayResource = i.ArrayResource, t.INSTALLED = s.INSTALLED, t.autoDetectResource = s.autoDetectResource, t.BufferResource = n.BufferResource, t.CanvasResource = o.CanvasResource, t.CubeResource = a.CubeResource, t.ImageBitmapResource = h.ImageBitmapResource, t.ImageResource = l.ImageResource, t.SVGResource = u.SVGResource, t.VideoResource = c.VideoResource, t.BaseImageResource = d.BaseImageResource, t.Resource = p.Resource, t.AbstractMultiResource = f.AbstractMultiResource
            },
            6921: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2386);
                t.mapTypeAndFormatToInternalFormat = function(e) {
                    let t;
                    return t = "WebGL2RenderingContext" in globalThis && e instanceof globalThis.WebGL2RenderingContext ? {
                        [i.TYPES.UNSIGNED_BYTE]: {
                            [i.FORMATS.RGBA]: e.RGBA8,
                            [i.FORMATS.RGB]: e.RGB8,
                            [i.FORMATS.RG]: e.RG8,
                            [i.FORMATS.RED]: e.R8,
                            [i.FORMATS.RGBA_INTEGER]: e.RGBA8UI,
                            [i.FORMATS.RGB_INTEGER]: e.RGB8UI,
                            [i.FORMATS.RG_INTEGER]: e.RG8UI,
                            [i.FORMATS.RED_INTEGER]: e.R8UI,
                            [i.FORMATS.ALPHA]: e.ALPHA,
                            [i.FORMATS.LUMINANCE]: e.LUMINANCE,
                            [i.FORMATS.LUMINANCE_ALPHA]: e.LUMINANCE_ALPHA
                        },
                        [i.TYPES.BYTE]: {
                            [i.FORMATS.RGBA]: e.RGBA8_SNORM,
                            [i.FORMATS.RGB]: e.RGB8_SNORM,
                            [i.FORMATS.RG]: e.RG8_SNORM,
                            [i.FORMATS.RED]: e.R8_SNORM,
                            [i.FORMATS.RGBA_INTEGER]: e.RGBA8I,
                            [i.FORMATS.RGB_INTEGER]: e.RGB8I,
                            [i.FORMATS.RG_INTEGER]: e.RG8I,
                            [i.FORMATS.RED_INTEGER]: e.R8I
                        },
                        [i.TYPES.UNSIGNED_SHORT]: {
                            [i.FORMATS.RGBA_INTEGER]: e.RGBA16UI,
                            [i.FORMATS.RGB_INTEGER]: e.RGB16UI,
                            [i.FORMATS.RG_INTEGER]: e.RG16UI,
                            [i.FORMATS.RED_INTEGER]: e.R16UI,
                            [i.FORMATS.DEPTH_COMPONENT]: e.DEPTH_COMPONENT16
                        },
                        [i.TYPES.SHORT]: {
                            [i.FORMATS.RGBA_INTEGER]: e.RGBA16I,
                            [i.FORMATS.RGB_INTEGER]: e.RGB16I,
                            [i.FORMATS.RG_INTEGER]: e.RG16I,
                            [i.FORMATS.RED_INTEGER]: e.R16I
                        },
                        [i.TYPES.UNSIGNED_INT]: {
                            [i.FORMATS.RGBA_INTEGER]: e.RGBA32UI,
                            [i.FORMATS.RGB_INTEGER]: e.RGB32UI,
                            [i.FORMATS.RG_INTEGER]: e.RG32UI,
                            [i.FORMATS.RED_INTEGER]: e.R32UI,
                            [i.FORMATS.DEPTH_COMPONENT]: e.DEPTH_COMPONENT24
                        },
                        [i.TYPES.INT]: {
                            [i.FORMATS.RGBA_INTEGER]: e.RGBA32I,
                            [i.FORMATS.RGB_INTEGER]: e.RGB32I,
                            [i.FORMATS.RG_INTEGER]: e.RG32I,
                            [i.FORMATS.RED_INTEGER]: e.R32I
                        },
                        [i.TYPES.FLOAT]: {
                            [i.FORMATS.RGBA]: e.RGBA32F,
                            [i.FORMATS.RGB]: e.RGB32F,
                            [i.FORMATS.RG]: e.RG32F,
                            [i.FORMATS.RED]: e.R32F,
                            [i.FORMATS.DEPTH_COMPONENT]: e.DEPTH_COMPONENT32F
                        },
                        [i.TYPES.HALF_FLOAT]: {
                            [i.FORMATS.RGBA]: e.RGBA16F,
                            [i.FORMATS.RGB]: e.RGB16F,
                            [i.FORMATS.RG]: e.RG16F,
                            [i.FORMATS.RED]: e.R16F
                        },
                        [i.TYPES.UNSIGNED_SHORT_5_6_5]: {
                            [i.FORMATS.RGB]: e.RGB565
                        },
                        [i.TYPES.UNSIGNED_SHORT_4_4_4_4]: {
                            [i.FORMATS.RGBA]: e.RGBA4
                        },
                        [i.TYPES.UNSIGNED_SHORT_5_5_5_1]: {
                            [i.FORMATS.RGBA]: e.RGB5_A1
                        },
                        [i.TYPES.UNSIGNED_INT_2_10_10_10_REV]: {
                            [i.FORMATS.RGBA]: e.RGB10_A2,
                            [i.FORMATS.RGBA_INTEGER]: e.RGB10_A2UI
                        },
                        [i.TYPES.UNSIGNED_INT_10F_11F_11F_REV]: {
                            [i.FORMATS.RGB]: e.R11F_G11F_B10F
                        },
                        [i.TYPES.UNSIGNED_INT_5_9_9_9_REV]: {
                            [i.FORMATS.RGB]: e.RGB9_E5
                        },
                        [i.TYPES.UNSIGNED_INT_24_8]: {
                            [i.FORMATS.DEPTH_STENCIL]: e.DEPTH24_STENCIL8
                        },
                        [i.TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
                            [i.FORMATS.DEPTH_STENCIL]: e.DEPTH32F_STENCIL8
                        }
                    } : {
                        [i.TYPES.UNSIGNED_BYTE]: {
                            [i.FORMATS.RGBA]: e.RGBA,
                            [i.FORMATS.RGB]: e.RGB,
                            [i.FORMATS.ALPHA]: e.ALPHA,
                            [i.FORMATS.LUMINANCE]: e.LUMINANCE,
                            [i.FORMATS.LUMINANCE_ALPHA]: e.LUMINANCE_ALPHA
                        },
                        [i.TYPES.UNSIGNED_SHORT_5_6_5]: {
                            [i.FORMATS.RGB]: e.RGB
                        },
                        [i.TYPES.UNSIGNED_SHORT_4_4_4_4]: {
                            [i.FORMATS.RGBA]: e.RGBA
                        },
                        [i.TYPES.UNSIGNED_SHORT_5_5_5_1]: {
                            [i.FORMATS.RGBA]: e.RGBA
                        }
                    }, t
                }
            },
            9332: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(5802);
                t.TransformFeedback = class {
                    constructor() {
                        this._glTransformFeedbacks = {}, this.buffers = [], this.disposeRunner = new i.Runner("disposeTransformFeedback")
                    }
                    bindBuffer(e, t) {
                        this.buffers[e] = t
                    }
                    destroy() {
                        this.disposeRunner.emit(this, !1)
                    }
                }
            },
            8200: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7222);
                class s {
                    constructor(e) {
                        this.renderer = e
                    }
                    contextChange() {
                        this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID
                    }
                    bind(e) {
                        const {
                            gl: t,
                            CONTEXT_UID: r
                        } = this, i = e._glTransformFeedbacks[r] || this.createGLTransformFeedback(e);
                        t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, i)
                    }
                    unbind() {
                        const {
                            gl: e
                        } = this;
                        e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, null)
                    }
                    beginTransformFeedback(e, t) {
                        const {
                            gl: r,
                            renderer: i
                        } = this;
                        t && i.shader.bind(t), r.beginTransformFeedback(e)
                    }
                    endTransformFeedback() {
                        const {
                            gl: e
                        } = this;
                        e.endTransformFeedback()
                    }
                    createGLTransformFeedback(e) {
                        const {
                            gl: t,
                            renderer: r,
                            CONTEXT_UID: i
                        } = this, s = t.createTransformFeedback();
                        e._glTransformFeedbacks[i] = s, t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, s);
                        for (let s = 0; s < e.buffers.length; s++) {
                            const n = e.buffers[s];
                            n && (r.buffer.update(n), n._glBuffers[i].refCount++, t.bindBufferBase(t.TRANSFORM_FEEDBACK_BUFFER, s, n._glBuffers[i].buffer || null))
                        }
                        return t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, null), e.disposeRunner.add(this), s
                    }
                    disposeTransformFeedback(e, t) {
                        const r = e._glTransformFeedbacks[this.CONTEXT_UID],
                            i = this.gl;
                        e.disposeRunner.remove(this);
                        const s = this.renderer.buffer;
                        if (s)
                            for (let r = 0; r < e.buffers.length; r++) {
                                const i = e.buffers[r];
                                if (!i) continue;
                                const n = i._glBuffers[this.CONTEXT_UID];
                                n && (n.refCount--, 0 !== n.refCount || t || s.dispose(i, t))
                            }
                        r && (t || i.deleteTransformFeedback(r), delete e._glTransformFeedbacks[this.CONTEXT_UID])
                    }
                    destroy() {
                        this.renderer = null
                    }
                }
                s.extension = {
                    type: i.ExtensionType.RendererSystem,
                    name: "transformFeedback"
                }, i.extensions.add(s), t.TransformFeedbackSystem = s
            },
            1257: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(1990);
                class s extends i.Geometry {
                    constructor() {
                        super(), this.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2])
                    }
                }
                t.Quad = s
            },
            8804: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(9202),
                    s = r(1990);
                class n extends s.Geometry {
                    constructor() {
                        super(), this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), this.vertexBuffer = new i.Buffer(this.vertices), this.uvBuffer = new i.Buffer(this.uvs), this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3])
                    }
                    map(e, t) {
                        let r = 0,
                            i = 0;
                        return this.uvs[0] = r, this.uvs[1] = i, this.uvs[2] = r + t.width / e.width, this.uvs[3] = i, this.uvs[4] = r + t.width / e.width, this.uvs[5] = i + t.height / e.height, this.uvs[6] = r, this.uvs[7] = i + t.height / e.height, r = t.x, i = t.y, this.vertices[0] = r, this.vertices[1] = i, this.vertices[2] = r + t.width, this.vertices[3] = i, this.vertices[4] = r + t.width, this.vertices[5] = i + t.height, this.vertices[6] = r, this.vertices[7] = i + t.height, this.invalidate(), this
                    }
                    invalidate() {
                        return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this
                    }
                }
                t.QuadUv = n
            },
            153: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7222),
                    s = r(8153),
                    n = r(6667);
                class o {
                    constructor(e) {
                        this.renderer = e
                    }
                    init(e) {
                        this.screen = new s.Rectangle(0, 0, e.width, e.height), this.element = e.view || n.settings.ADAPTER.createCanvas(), this.resolution = e.resolution || n.settings.RESOLUTION, this.autoDensity = !!e.autoDensity
                    }
                    resizeView(e, t) {
                        this.element.width = Math.round(e * this.resolution), this.element.height = Math.round(t * this.resolution);
                        const r = this.element.width / this.resolution,
                            i = this.element.height / this.resolution;
                        this.screen.width = r, this.screen.height = i, this.autoDensity && (this.element.style.width = `${r}px`, this.element.style.height = `${i}px`), this.renderer.emit("resize", r, i), this.renderer.runners.resize.emit(this.screen.width, this.screen.height)
                    }
                    destroy(e) {
                        e && this.element.parentNode?.removeChild(this.element), this.renderer = null, this.element = null, this.screen = null
                    }
                }
                o.defaultOptions = {
                    width: 800,
                    height: 600,
                    resolution: n.settings.RESOLUTION,
                    autoDensity: !1
                }, o.extension = {
                    type: [i.ExtensionType.RendererSystem, i.ExtensionType.CanvasRendererSystem],
                    name: "_view"
                }, i.extensions.add(o), t.ViewSystem = o
            },
            685: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                t.Bounds = class {
                    constructor() {
                        this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1
                    }
                    isEmpty() {
                        return this.minX > this.maxX || this.minY > this.maxY
                    }
                    clear() {
                        this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0
                    }
                    getRectangle(e) {
                        return this.minX > this.maxX || this.minY > this.maxY ? i.Rectangle.EMPTY : ((e = e || new i.Rectangle(0, 0, 1, 1)).x = this.minX, e.y = this.minY, e.width = this.maxX - this.minX, e.height = this.maxY - this.minY, e)
                    }
                    addPoint(e) {
                        this.minX = Math.min(this.minX, e.x), this.maxX = Math.max(this.maxX, e.x), this.minY = Math.min(this.minY, e.y), this.maxY = Math.max(this.maxY, e.y)
                    }
                    addPointMatrix(e, t) {
                        const {
                            a: r,
                            b: i,
                            c: s,
                            d: n,
                            tx: o,
                            ty: a
                        } = e, h = r * t.x + s * t.y + o, l = i * t.x + n * t.y + a;
                        this.minX = Math.min(this.minX, h), this.maxX = Math.max(this.maxX, h), this.minY = Math.min(this.minY, l), this.maxY = Math.max(this.maxY, l)
                    }
                    addQuad(e) {
                        let t = this.minX,
                            r = this.minY,
                            i = this.maxX,
                            s = this.maxY,
                            n = e[0],
                            o = e[1];
                        t = n < t ? n : t, r = o < r ? o : r, i = n > i ? n : i, s = o > s ? o : s, n = e[2], o = e[3], t = n < t ? n : t, r = o < r ? o : r, i = n > i ? n : i, s = o > s ? o : s, n = e[4], o = e[5], t = n < t ? n : t, r = o < r ? o : r, i = n > i ? n : i, s = o > s ? o : s, n = e[6], o = e[7], t = n < t ? n : t, r = o < r ? o : r, i = n > i ? n : i, s = o > s ? o : s, this.minX = t, this.minY = r, this.maxX = i, this.maxY = s
                    }
                    addFrame(e, t, r, i, s) {
                        this.addFrameMatrix(e.worldTransform, t, r, i, s)
                    }
                    addFrameMatrix(e, t, r, i, s) {
                        const n = e.a,
                            o = e.b,
                            a = e.c,
                            h = e.d,
                            l = e.tx,
                            u = e.ty;
                        let c = this.minX,
                            d = this.minY,
                            p = this.maxX,
                            f = this.maxY,
                            m = n * t + a * r + l,
                            g = o * t + h * r + u;
                        c = m < c ? m : c, d = g < d ? g : d, p = m > p ? m : p, f = g > f ? g : f, m = n * i + a * r + l, g = o * i + h * r + u, c = m < c ? m : c, d = g < d ? g : d, p = m > p ? m : p, f = g > f ? g : f, m = n * t + a * s + l, g = o * t + h * s + u, c = m < c ? m : c, d = g < d ? g : d, p = m > p ? m : p, f = g > f ? g : f, m = n * i + a * s + l, g = o * i + h * s + u, c = m < c ? m : c, d = g < d ? g : d, p = m > p ? m : p, f = g > f ? g : f, this.minX = c, this.minY = d, this.maxX = p, this.maxY = f
                    }
                    addVertexData(e, t, r) {
                        let i = this.minX,
                            s = this.minY,
                            n = this.maxX,
                            o = this.maxY;
                        for (let a = t; a < r; a += 2) {
                            const t = e[a],
                                r = e[a + 1];
                            i = t < i ? t : i, s = r < s ? r : s, n = t > n ? t : n, o = r > o ? r : o
                        }
                        this.minX = i, this.minY = s, this.maxX = n, this.maxY = o
                    }
                    addVertices(e, t, r, i) {
                        this.addVerticesMatrix(e.worldTransform, t, r, i)
                    }
                    addVerticesMatrix(e, t, r, i, s = 0, n = s) {
                        const o = e.a,
                            a = e.b,
                            h = e.c,
                            l = e.d,
                            u = e.tx,
                            c = e.ty;
                        let d = this.minX,
                            p = this.minY,
                            f = this.maxX,
                            m = this.maxY;
                        for (let e = r; e < i; e += 2) {
                            const r = t[e],
                                i = t[e + 1],
                                g = o * r + h * i + u,
                                y = l * i + a * r + c;
                            d = Math.min(d, g - s), f = Math.max(f, g + s), p = Math.min(p, y - n), m = Math.max(m, y + n)
                        }
                        this.minX = d, this.minY = p, this.maxX = f, this.maxY = m
                    }
                    addBounds(e) {
                        const t = this.minX,
                            r = this.minY,
                            i = this.maxX,
                            s = this.maxY;
                        this.minX = e.minX < t ? e.minX : t, this.minY = e.minY < r ? e.minY : r, this.maxX = e.maxX > i ? e.maxX : i, this.maxY = e.maxY > s ? e.maxY : s
                    }
                    addBoundsMask(e, t) {
                        const r = e.minX > t.minX ? e.minX : t.minX,
                            i = e.minY > t.minY ? e.minY : t.minY,
                            s = e.maxX < t.maxX ? e.maxX : t.maxX,
                            n = e.maxY < t.maxY ? e.maxY : t.maxY;
                        if (r <= s && i <= n) {
                            const e = this.minX,
                                t = this.minY,
                                o = this.maxX,
                                a = this.maxY;
                            this.minX = r < e ? r : e, this.minY = i < t ? i : t, this.maxX = s > o ? s : o, this.maxY = n > a ? n : a
                        }
                    }
                    addBoundsMatrix(e, t) {
                        this.addFrameMatrix(t, e.minX, e.minY, e.maxX, e.maxY)
                    }
                    addBoundsArea(e, t) {
                        const r = e.minX > t.x ? e.minX : t.x,
                            i = e.minY > t.y ? e.minY : t.y,
                            s = e.maxX < t.x + t.width ? e.maxX : t.x + t.width,
                            n = e.maxY < t.y + t.height ? e.maxY : t.y + t.height;
                        if (r <= s && i <= n) {
                            const e = this.minX,
                                t = this.minY,
                                o = this.maxX,
                                a = this.maxY;
                            this.minX = r < e ? r : e, this.minY = i < t ? i : t, this.maxX = s > o ? s : o, this.maxY = n > a ? n : a
                        }
                    }
                    pad(e = 0, t = e) {
                        this.isEmpty() || (this.minX -= e, this.maxX += e, this.minY -= t, this.maxY += t)
                    }
                    addFramePad(e, t, r, i, s, n) {
                        e -= s, t -= n, r += s, i += n, this.minX = this.minX < e ? this.minX : e, this.maxX = this.maxX > r ? this.maxX : r, this.minY = this.minY < t ? this.minY : t, this.maxY = this.maxY > i ? this.maxY : i
                    }
                }
            },
            815: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(5045);
                const n = new i.Matrix;

                function o(e, t) {
                    return e.zIndex === t.zIndex ? e._lastSortedIndex - t._lastSortedIndex : e.zIndex - t.zIndex
                }
                const a = class extends s.DisplayObject {
                    constructor() {
                        super(), this.children = [], this.sortableChildren = a.defaultSortableChildren, this.sortDirty = !1
                    }
                    onChildrenChange(e) {}
                    addChild(...e) {
                        if (e.length > 1)
                            for (let t = 0; t < e.length; t++) this.addChild(e[t]);
                        else {
                            const t = e[0];
                            t.parent && t.parent.removeChild(t), t.parent = this, this.sortDirty = !0, t.transform._parentID = -1, this.children.push(t), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", t, this, this.children.length - 1), t.emit("added", this)
                        }
                        return e[0]
                    }
                    addChildAt(e, t) {
                        if (t < 0 || t > this.children.length) throw new Error(`${e}addChildAt: The index ${t} supplied is out of bounds ${this.children.length}`);
                        return e.parent && e.parent.removeChild(e), e.parent = this, this.sortDirty = !0, e.transform._parentID = -1, this.children.splice(t, 0, e), this._boundsID++, this.onChildrenChange(t), e.emit("added", this), this.emit("childAdded", e, this, t), e
                    }
                    swapChildren(e, t) {
                        if (e === t) return;
                        const r = this.getChildIndex(e),
                            i = this.getChildIndex(t);
                        this.children[r] = t, this.children[i] = e, this.onChildrenChange(r < i ? r : i)
                    }
                    getChildIndex(e) {
                        const t = this.children.indexOf(e);
                        if (-1 === t) throw new Error("The supplied DisplayObject must be a child of the caller");
                        return t
                    }
                    setChildIndex(e, t) {
                        if (t < 0 || t >= this.children.length) throw new Error(`The index ${t} supplied is out of bounds ${this.children.length}`);
                        const r = this.getChildIndex(e);
                        i.utils.removeItems(this.children, r, 1), this.children.splice(t, 0, e), this.onChildrenChange(t)
                    }
                    getChildAt(e) {
                        if (e < 0 || e >= this.children.length) throw new Error(`getChildAt: Index (${e}) does not exist.`);
                        return this.children[e]
                    }
                    removeChild(...e) {
                        if (e.length > 1)
                            for (let t = 0; t < e.length; t++) this.removeChild(e[t]);
                        else {
                            const t = e[0],
                                r = this.children.indexOf(t);
                            if (-1 === r) return null;
                            t.parent = null, t.transform._parentID = -1, i.utils.removeItems(this.children, r, 1), this._boundsID++, this.onChildrenChange(r), t.emit("removed", this), this.emit("childRemoved", t, this, r)
                        }
                        return e[0]
                    }
                    removeChildAt(e) {
                        const t = this.getChildAt(e);
                        return t.parent = null, t.transform._parentID = -1, i.utils.removeItems(this.children, e, 1), this._boundsID++, this.onChildrenChange(e), t.emit("removed", this), this.emit("childRemoved", t, this, e), t
                    }
                    removeChildren(e = 0, t = this.children.length) {
                        const r = e,
                            i = t - r;
                        let s;
                        if (i > 0 && i <= t) {
                            s = this.children.splice(r, i);
                            for (let e = 0; e < s.length; ++e) s[e].parent = null, s[e].transform && (s[e].transform._parentID = -1);
                            this._boundsID++, this.onChildrenChange(e);
                            for (let e = 0; e < s.length; ++e) s[e].emit("removed", this), this.emit("childRemoved", s[e], this, e);
                            return s
                        }
                        if (0 === i && 0 === this.children.length) return [];
                        throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
                    }
                    sortChildren() {
                        let e = !1;
                        for (let t = 0, r = this.children.length; t < r; ++t) {
                            const r = this.children[t];
                            r._lastSortedIndex = t, e || 0 === r.zIndex || (e = !0)
                        }
                        e && this.children.length > 1 && this.children.sort(o), this.sortDirty = !1
                    }
                    updateTransform() {
                        this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
                        for (let e = 0, t = this.children.length; e < t; ++e) {
                            const t = this.children[e];
                            t.visible && t.updateTransform()
                        }
                    }
                    calculateBounds() {
                        this._bounds.clear(), this._calculateBounds();
                        for (let e = 0; e < this.children.length; e++) {
                            const t = this.children[e];
                            if (t.visible && t.renderable)
                                if (t.calculateBounds(), t._mask) {
                                    const e = t._mask.isMaskData ? t._mask.maskObject : t._mask;
                                    e ? (e.calculateBounds(), this._bounds.addBoundsMask(t._bounds, e._bounds)) : this._bounds.addBounds(t._bounds)
                                } else t.filterArea ? this._bounds.addBoundsArea(t._bounds, t.filterArea) : this._bounds.addBounds(t._bounds)
                        }
                        this._bounds.updateID = this._boundsID
                    }
                    getLocalBounds(e, t = !1) {
                        const r = super.getLocalBounds(e);
                        if (!t)
                            for (let e = 0, t = this.children.length; e < t; ++e) {
                                const t = this.children[e];
                                t.visible && t.updateTransform()
                            }
                        return r
                    }
                    _calculateBounds() {}
                    _renderWithCulling(e) {
                        const t = e.renderTexture.sourceFrame;
                        if (!(t.width > 0 && t.height > 0)) return;
                        let r, i;
                        this.cullArea ? (r = this.cullArea, i = this.worldTransform) : this._render !== a.prototype._render && (r = this.getBounds(!0));
                        const s = e.projection.transform;
                        if (s && (i ? (i = n.copyFrom(i), i.prepend(s)) : i = s), r && t.intersects(r, i)) this._render(e);
                        else if (this.cullArea) return;
                        for (let t = 0, r = this.children.length; t < r; ++t) {
                            const r = this.children[t],
                                i = r.cullable;
                            r.cullable = i || !this.cullArea, r.render(e), r.cullable = i
                        }
                    }
                    render(e) {
                        if (this.visible && !(this.worldAlpha <= 0) && this.renderable)
                            if (this._mask || this.filters?.length) this.renderAdvanced(e);
                            else if (this.cullable) this._renderWithCulling(e);
                        else {
                            this._render(e);
                            for (let t = 0, r = this.children.length; t < r; ++t) this.children[t].render(e)
                        }
                    }
                    renderAdvanced(e) {
                        const t = this.filters,
                            r = this._mask;
                        if (t) {
                            this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
                            for (let e = 0; e < t.length; e++) t[e].enabled && this._enabledFilters.push(t[e])
                        }
                        const s = t && this._enabledFilters?.length || r && (!r.isMaskData || r.enabled && (r.autoDetect || r.type !== i.MASK_TYPES.NONE));
                        if (s && e.batch.flush(), t && this._enabledFilters?.length && e.filter.push(this, this._enabledFilters), r && e.mask.push(this, this._mask), this.cullable) this._renderWithCulling(e);
                        else {
                            this._render(e);
                            for (let t = 0, r = this.children.length; t < r; ++t) this.children[t].render(e)
                        }
                        s && e.batch.flush(), r && e.mask.pop(this), t && this._enabledFilters?.length && e.filter.pop()
                    }
                    _render(e) {}
                    destroy(e) {
                        super.destroy(), this.sortDirty = !1;
                        const t = "boolean" == typeof e ? e : e?.children,
                            r = this.removeChildren(0, this.children.length);
                        if (t)
                            for (let t = 0; t < r.length; ++t) r[t].destroy(e)
                    }
                    get width() {
                        return this.scale.x * this.getLocalBounds().width
                    }
                    set width(e) {
                        const t = this.getLocalBounds().width;
                        this.scale.x = 0 !== t ? e / t : 1, this._width = e
                    }
                    get height() {
                        return this.scale.y * this.getLocalBounds().height
                    }
                    set height(e) {
                        const t = this.getLocalBounds().height;
                        this.scale.y = 0 !== t ? e / t : 1, this._height = e
                    }
                };
                let h = a;
                h.defaultSortableChildren = !1, h.prototype.containerUpdateTransform = h.prototype.updateTransform, t.Container = h
            },
            5045: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(685);
                class n extends i.utils.EventEmitter {
                    constructor() {
                        super(), this.tempDisplayObjectParent = null, this.transform = new i.Transform, this.alpha = 1, this.visible = !0, this.renderable = !0, this.cullable = !1, this.cullArea = null, this.parent = null, this.worldAlpha = 1, this._lastSortedIndex = 0, this._zIndex = 0, this.filterArea = null, this.filters = null, this._enabledFilters = null, this._bounds = new s.Bounds, this._localBounds = null, this._boundsID = 0, this._boundsRect = null, this._localBoundsRect = null, this._mask = null, this._maskRefCount = 0, this._destroyed = !1, this.isSprite = !1, this.isMask = !1
                    }
                    static mixin(e) {
                        const t = Object.keys(e);
                        for (let r = 0; r < t.length; ++r) {
                            const i = t[r];
                            Object.defineProperty(n.prototype, i, Object.getOwnPropertyDescriptor(e, i))
                        }
                    }
                    get destroyed() {
                        return this._destroyed
                    }
                    _recursivePostUpdateTransform() {
                        this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform)
                    }
                    updateTransform() {
                        this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha
                    }
                    getBounds(e, t) {
                        return e || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), t || (this._boundsRect || (this._boundsRect = new i.Rectangle), t = this._boundsRect), this._bounds.getRectangle(t)
                    }
                    getLocalBounds(e) {
                        e || (this._localBoundsRect || (this._localBoundsRect = new i.Rectangle), e = this._localBoundsRect), this._localBounds || (this._localBounds = new s.Bounds);
                        const t = this.transform,
                            r = this.parent;
                        this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
                        const n = this._bounds,
                            o = this._boundsID;
                        this._bounds = this._localBounds;
                        const a = this.getBounds(!1, e);
                        return this.parent = r, this.transform = t, this._bounds = n, this._bounds.updateID += this._boundsID - o, a
                    }
                    toGlobal(e, t, r = !1) {
                        return r || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(e, t)
                    }
                    toLocal(e, t, r, i) {
                        return t && (e = t.toGlobal(e, r, i)), i || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(e, r)
                    }
                    setParent(e) {
                        if (!e || !e.addChild) throw new Error("setParent: Argument must be a Container");
                        return e.addChild(this), e
                    }
                    removeFromParent() {
                        this.parent?.removeChild(this)
                    }
                    setTransform(e = 0, t = 0, r = 1, i = 1, s = 0, n = 0, o = 0, a = 0, h = 0) {
                        return this.position.x = e, this.position.y = t, this.scale.x = r || 1, this.scale.y = i || 1, this.rotation = s, this.skew.x = n, this.skew.y = o, this.pivot.x = a, this.pivot.y = h, this
                    }
                    destroy(e) {
                        this.removeFromParent(), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.eventMode = "auto", this.interactiveChildren = !1, this.emit("destroyed"), this.removeAllListeners()
                    }
                    get _tempDisplayObjectParent() {
                        return null === this.tempDisplayObjectParent && (this.tempDisplayObjectParent = new o), this.tempDisplayObjectParent
                    }
                    enableTempParent() {
                        const e = this.parent;
                        return this.parent = this._tempDisplayObjectParent, e
                    }
                    disableTempParent(e) {
                        this.parent = e
                    }
                    get x() {
                        return this.position.x
                    }
                    set x(e) {
                        this.transform.position.x = e
                    }
                    get y() {
                        return this.position.y
                    }
                    set y(e) {
                        this.transform.position.y = e
                    }
                    get worldTransform() {
                        return this.transform.worldTransform
                    }
                    get localTransform() {
                        return this.transform.localTransform
                    }
                    get position() {
                        return this.transform.position
                    }
                    set position(e) {
                        this.transform.position.copyFrom(e)
                    }
                    get scale() {
                        return this.transform.scale
                    }
                    set scale(e) {
                        this.transform.scale.copyFrom(e)
                    }
                    get pivot() {
                        return this.transform.pivot
                    }
                    set pivot(e) {
                        this.transform.pivot.copyFrom(e)
                    }
                    get skew() {
                        return this.transform.skew
                    }
                    set skew(e) {
                        this.transform.skew.copyFrom(e)
                    }
                    get rotation() {
                        return this.transform.rotation
                    }
                    set rotation(e) {
                        this.transform.rotation = e
                    }
                    get angle() {
                        return this.transform.rotation * i.RAD_TO_DEG
                    }
                    set angle(e) {
                        this.transform.rotation = e * i.DEG_TO_RAD
                    }
                    get zIndex() {
                        return this._zIndex
                    }
                    set zIndex(e) {
                        this._zIndex = e, this.parent && (this.parent.sortDirty = !0)
                    }
                    get worldVisible() {
                        let e = this;
                        do {
                            if (!e.visible) return !1;
                            e = e.parent
                        } while (e);
                        return !0
                    }
                    get mask() {
                        return this._mask
                    }
                    set mask(e) {
                        if (this._mask !== e) {
                            if (this._mask) {
                                const e = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                                e && (e._maskRefCount--, 0 === e._maskRefCount && (e.renderable = !0, e.isMask = !1))
                            }
                            if (this._mask = e, this._mask) {
                                const e = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                                e && (0 === e._maskRefCount && (e.renderable = !1, e.isMask = !0), e._maskRefCount++)
                            }
                        }
                    }
                }
                class o extends n {
                    constructor() {
                        super(...arguments), this.sortDirty = null
                    }
                }
                n.prototype.displayObjectUpdateTransform = n.prototype.updateTransform, t.DisplayObject = n, t.TemporaryDisplayObject = o
            },
            2781: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), r(6120);
                var i = r(685),
                    s = r(815),
                    n = r(5045);
                t.Bounds = i.Bounds, t.Container = s.Container, t.DisplayObject = n.DisplayObject, t.TemporaryDisplayObject = n.TemporaryDisplayObject
            },
            6120: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(815);
                Object.defineProperties(i.settings, {
                    SORTABLE_CHILDREN: {
                        get: () => s.Container.defaultSortableChildren,
                        set(e) {
                            i.utils.deprecation("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"), s.Container.defaultSortableChildren = e
                        }
                    }
                }), Object.defineProperty(t, "settings", {
                    enumerable: !0,
                    get: function() {
                        return i.settings
                    }
                })
            },
            3240: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(9106),
                    n = r(7747),
                    o = r(3438),
                    a = r(6911);
                const h = new i.Point,
                    l = new i.Point;
                t.EventBoundary = class {
                    constructor(e) {
                        this.dispatch = new i.utils.EventEmitter, this.moveOnAll = !1, this.enableGlobalMoveEvents = !0, this.mappingState = {
                            trackingData: {}
                        }, this.eventPool = new Map, this._allInteractiveElements = [], this._hitElements = [], this._isPointerMoveEvent = !1, this.rootTarget = e, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel)
                    }
                    addEventMapping(e, t) {
                        this.mappingTable[e] || (this.mappingTable[e] = []), this.mappingTable[e].push({
                            fn: t,
                            priority: 0
                        }), this.mappingTable[e].sort(((e, t) => e.priority - t.priority))
                    }
                    dispatchEvent(e, t) {
                        e.propagationStopped = !1, e.propagationImmediatelyStopped = !1, this.propagate(e, t), this.dispatch.emit(t || e.type, e)
                    }
                    mapEvent(e) {
                        if (!this.rootTarget) return;
                        const t = this.mappingTable[e.type];
                        if (t)
                            for (let r = 0, i = t.length; r < i; r++) t[r].fn(e);
                        else console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`)
                    }
                    hitTest(e, t) {
                        s.EventsTicker.pauseUpdate = !0;
                        const r = this[this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive"](this.rootTarget, this.rootTarget.eventMode, h.set(e, t), this.hitTestFn, this.hitPruneFn);
                        return r && r[0]
                    }
                    propagate(e, t) {
                        if (!e.target) return;
                        const r = e.composedPath();
                        e.eventPhase = e.CAPTURING_PHASE;
                        for (let i = 0, s = r.length - 1; i < s; i++)
                            if (e.currentTarget = r[i], this.notifyTarget(e, t), e.propagationStopped || e.propagationImmediatelyStopped) return;
                        if (e.eventPhase = e.AT_TARGET, e.currentTarget = e.target, this.notifyTarget(e, t), !e.propagationStopped && !e.propagationImmediatelyStopped) {
                            e.eventPhase = e.BUBBLING_PHASE;
                            for (let i = r.length - 2; i >= 0; i--)
                                if (e.currentTarget = r[i], this.notifyTarget(e, t), e.propagationStopped || e.propagationImmediatelyStopped) return
                        }
                    }
                    all(e, t, r = this._allInteractiveElements) {
                        if (0 === r.length) return;
                        e.eventPhase = e.BUBBLING_PHASE;
                        const i = Array.isArray(t) ? t : [t];
                        for (let t = r.length - 1; t >= 0; t--) i.forEach((i => {
                            e.currentTarget = r[t], this.notifyTarget(e, i)
                        }))
                    }
                    propagationPath(e) {
                        const t = [e];
                        for (let r = 0; r < 2048 && e !== this.rootTarget; r++) {
                            if (!e.parent) throw new Error("Cannot find propagation path to disconnected target");
                            t.push(e.parent), e = e.parent
                        }
                        return t.reverse(), t
                    }
                    hitTestMoveRecursive(e, t, r, i, n, o = !1) {
                        if (this._interactivePrune(e)) return null;
                        if ("dynamic" !== e.eventMode && "dynamic" !== t || (s.EventsTicker.pauseUpdate = !1), e.interactiveChildren && e.children) {
                            const s = e.children;
                            for (let o = s.length - 1; o >= 0; o--) {
                                const a = s[o],
                                    h = this.hitTestMoveRecursive(a, this._isInteractive(t) ? t : a.eventMode, r, i, n, n(e, r));
                                if (h) {
                                    if (h.length > 0 && !h[h.length - 1].parent) continue;
                                    const t = e.isInteractive();
                                    (h.length > 0 || t) && (t && this._allInteractiveElements.push(e), h.push(e)), 0 === this._hitElements.length && (this._hitElements = h)
                                }
                            }
                        }
                        const a = this._isInteractive(t),
                            h = e.isInteractive();
                        return h && h && this._allInteractiveElements.push(e), o || this._hitElements.length > 0 ? null : a && !n(e, r) && i(e, r) ? h ? [e] : [] : null
                    }
                    hitTestRecursive(e, t, r, i, n) {
                        if (this._interactivePrune(e) || n(e, r)) return null;
                        if ("dynamic" !== e.eventMode && "dynamic" !== t || (s.EventsTicker.pauseUpdate = !1), e.interactiveChildren && e.children) {
                            const s = e.children;
                            for (let o = s.length - 1; o >= 0; o--) {
                                const a = s[o],
                                    h = this.hitTestRecursive(a, this._isInteractive(t) ? t : a.eventMode, r, i, n);
                                if (h) {
                                    if (h.length > 0 && !h[h.length - 1].parent) continue;
                                    const t = e.isInteractive();
                                    return (h.length > 0 || t) && h.push(e), h
                                }
                            }
                        }
                        const o = this._isInteractive(t),
                            a = e.isInteractive();
                        return o && i(e, r) ? a ? [e] : [] : null
                    }
                    _isInteractive(e) {
                        return "static" === e || "dynamic" === e
                    }
                    _interactivePrune(e) {
                        return !(e && !e.isMask && e.visible && e.renderable) || "none" === e.eventMode || "passive" === e.eventMode && !e.interactiveChildren || !!e.isMask
                    }
                    hitPruneFn(e, t) {
                        if (e.hitArea && (e.worldTransform.applyInverse(t, l), !e.hitArea.contains(l.x, l.y))) return !0;
                        if (e._mask) {
                            const r = e._mask.isMaskData ? e._mask.maskObject : e._mask;
                            if (r && !r.containsPoint?.(t)) return !0
                        }
                        return !1
                    }
                    hitTestFn(e, t) {
                        return "passive" !== e.eventMode && (!!e.hitArea || !!e.containsPoint && e.containsPoint(t))
                    }
                    notifyTarget(e, t) {
                        const r = `on${t=t??e.type}`;
                        e.currentTarget[r]?.(e);
                        const i = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${t}capture` : t;
                        this.notifyListeners(e, i), e.eventPhase === e.AT_TARGET && this.notifyListeners(e, t)
                    }
                    mapPointerDown(e) {
                        if (!(e instanceof o.FederatedPointerEvent)) return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
                        const t = this.createPointerEvent(e);
                        if (this.dispatchEvent(t, "pointerdown"), "touch" === t.pointerType) this.dispatchEvent(t, "touchstart");
                        else if ("mouse" === t.pointerType || "pen" === t.pointerType) {
                            const e = 2 === t.button;
                            this.dispatchEvent(t, e ? "rightdown" : "mousedown")
                        }
                        this.trackingData(e.pointerId).pressTargetsByButton[e.button] = t.composedPath(), this.freeEvent(t)
                    }
                    mapPointerMove(e) {
                        if (!(e instanceof o.FederatedPointerEvent)) return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
                        this._allInteractiveElements.length = 0, this._hitElements.length = 0, this._isPointerMoveEvent = !0;
                        const t = this.createPointerEvent(e);
                        this._isPointerMoveEvent = !1;
                        const r = "mouse" === t.pointerType || "pen" === t.pointerType,
                            i = this.trackingData(e.pointerId),
                            s = this.findMountedTarget(i.overTargets);
                        if (i.overTargets?.length > 0 && s !== t.target) {
                            const i = "mousemove" === e.type ? "mouseout" : "pointerout",
                                n = this.createPointerEvent(e, i, s);
                            if (this.dispatchEvent(n, "pointerout"), r && this.dispatchEvent(n, "mouseout"), !t.composedPath().includes(s)) {
                                const i = this.createPointerEvent(e, "pointerleave", s);
                                for (i.eventPhase = i.AT_TARGET; i.target && !t.composedPath().includes(i.target);) i.currentTarget = i.target, this.notifyTarget(i), r && this.notifyTarget(i, "mouseleave"), i.target = i.target.parent;
                                this.freeEvent(i)
                            }
                            this.freeEvent(n)
                        }
                        if (s !== t.target) {
                            const i = "mousemove" === e.type ? "mouseover" : "pointerover",
                                n = this.clonePointerEvent(t, i);
                            this.dispatchEvent(n, "pointerover"), r && this.dispatchEvent(n, "mouseover");
                            let o = s?.parent;
                            for (; o && o !== this.rootTarget.parent && o !== t.target;) o = o.parent;
                            if (!o || o === this.rootTarget.parent) {
                                const e = this.clonePointerEvent(t, "pointerenter");
                                for (e.eventPhase = e.AT_TARGET; e.target && e.target !== s && e.target !== this.rootTarget.parent;) e.currentTarget = e.target, this.notifyTarget(e), r && this.notifyTarget(e, "mouseenter"), e.target = e.target.parent;
                                this.freeEvent(e)
                            }
                            this.freeEvent(n)
                        }
                        const n = [],
                            a = this.enableGlobalMoveEvents ?? !0;
                        this.moveOnAll ? n.push("pointermove") : this.dispatchEvent(t, "pointermove"), a && n.push("globalpointermove"), "touch" === t.pointerType && (this.moveOnAll ? n.splice(1, 0, "touchmove") : this.dispatchEvent(t, "touchmove"), a && n.push("globaltouchmove")), r && (this.moveOnAll ? n.splice(1, 0, "mousemove") : this.dispatchEvent(t, "mousemove"), a && n.push("globalmousemove"), this.cursor = t.target?.cursor), n.length > 0 && this.all(t, n), this._allInteractiveElements.length = 0, this._hitElements.length = 0, i.overTargets = t.composedPath(), this.freeEvent(t)
                    }
                    mapPointerOver(e) {
                        if (!(e instanceof o.FederatedPointerEvent)) return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
                        const t = this.trackingData(e.pointerId),
                            r = this.createPointerEvent(e),
                            i = "mouse" === r.pointerType || "pen" === r.pointerType;
                        this.dispatchEvent(r, "pointerover"), i && this.dispatchEvent(r, "mouseover"), "mouse" === r.pointerType && (this.cursor = r.target?.cursor);
                        const s = this.clonePointerEvent(r, "pointerenter");
                        for (s.eventPhase = s.AT_TARGET; s.target && s.target !== this.rootTarget.parent;) s.currentTarget = s.target, this.notifyTarget(s), i && this.notifyTarget(s, "mouseenter"), s.target = s.target.parent;
                        t.overTargets = r.composedPath(), this.freeEvent(r), this.freeEvent(s)
                    }
                    mapPointerOut(e) {
                        if (!(e instanceof o.FederatedPointerEvent)) return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
                        const t = this.trackingData(e.pointerId);
                        if (t.overTargets) {
                            const r = "mouse" === e.pointerType || "pen" === e.pointerType,
                                i = this.findMountedTarget(t.overTargets),
                                s = this.createPointerEvent(e, "pointerout", i);
                            this.dispatchEvent(s), r && this.dispatchEvent(s, "mouseout");
                            const n = this.createPointerEvent(e, "pointerleave", i);
                            for (n.eventPhase = n.AT_TARGET; n.target && n.target !== this.rootTarget.parent;) n.currentTarget = n.target, this.notifyTarget(n), r && this.notifyTarget(n, "mouseleave"), n.target = n.target.parent;
                            t.overTargets = null, this.freeEvent(s), this.freeEvent(n)
                        }
                        this.cursor = null
                    }
                    mapPointerUp(e) {
                        if (!(e instanceof o.FederatedPointerEvent)) return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
                        const t = performance.now(),
                            r = this.createPointerEvent(e);
                        if (this.dispatchEvent(r, "pointerup"), "touch" === r.pointerType) this.dispatchEvent(r, "touchend");
                        else if ("mouse" === r.pointerType || "pen" === r.pointerType) {
                            const e = 2 === r.button;
                            this.dispatchEvent(r, e ? "rightup" : "mouseup")
                        }
                        const i = this.trackingData(e.pointerId),
                            s = this.findMountedTarget(i.pressTargetsByButton[e.button]);
                        let n = s;
                        if (s && !r.composedPath().includes(s)) {
                            let t = s;
                            for (; t && !r.composedPath().includes(t);) {
                                if (r.currentTarget = t, this.notifyTarget(r, "pointerupoutside"), "touch" === r.pointerType) this.notifyTarget(r, "touchendoutside");
                                else if ("mouse" === r.pointerType || "pen" === r.pointerType) {
                                    const e = 2 === r.button;
                                    this.notifyTarget(r, e ? "rightupoutside" : "mouseupoutside")
                                }
                                t = t.parent
                            }
                            delete i.pressTargetsByButton[e.button], n = t
                        }
                        if (n) {
                            const s = this.clonePointerEvent(r, "click");
                            s.target = n, s.path = null, i.clicksByButton[e.button] || (i.clicksByButton[e.button] = {
                                clickCount: 0,
                                target: s.target,
                                timeStamp: t
                            });
                            const o = i.clicksByButton[e.button];
                            if (o.target === s.target && t - o.timeStamp < 200 ? ++o.clickCount : o.clickCount = 1, o.target = s.target, o.timeStamp = t, s.detail = o.clickCount, "mouse" === s.pointerType) {
                                const e = 2 === s.button;
                                this.dispatchEvent(s, e ? "rightclick" : "click")
                            } else "touch" === s.pointerType && this.dispatchEvent(s, "tap");
                            this.dispatchEvent(s, "pointertap"), this.freeEvent(s)
                        }
                        this.freeEvent(r)
                    }
                    mapPointerUpOutside(e) {
                        if (!(e instanceof o.FederatedPointerEvent)) return void console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
                        const t = this.trackingData(e.pointerId),
                            r = this.findMountedTarget(t.pressTargetsByButton[e.button]),
                            i = this.createPointerEvent(e);
                        if (r) {
                            let s = r;
                            for (; s;) i.currentTarget = s, this.notifyTarget(i, "pointerupoutside"), "touch" === i.pointerType ? this.notifyTarget(i, "touchendoutside") : "mouse" !== i.pointerType && "pen" !== i.pointerType || this.notifyTarget(i, 2 === i.button ? "rightupoutside" : "mouseupoutside"), s = s.parent;
                            delete t.pressTargetsByButton[e.button]
                        }
                        this.freeEvent(i)
                    }
                    mapWheel(e) {
                        if (!(e instanceof a.FederatedWheelEvent)) return void console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
                        const t = this.createWheelEvent(e);
                        this.dispatchEvent(t), this.freeEvent(t)
                    }
                    findMountedTarget(e) {
                        if (!e) return null;
                        let t = e[0];
                        for (let r = 1; r < e.length && e[r].parent === t; r++) t = e[r];
                        return t
                    }
                    createPointerEvent(e, t, r) {
                        const i = this.allocateEvent(o.FederatedPointerEvent);
                        return this.copyPointerData(e, i), this.copyMouseData(e, i), this.copyData(e, i), i.nativeEvent = e.nativeEvent, i.originalEvent = e, i.target = r ?? this.hitTest(i.global.x, i.global.y) ?? this._hitElements[0], "string" == typeof t && (i.type = t), i
                    }
                    createWheelEvent(e) {
                        const t = this.allocateEvent(a.FederatedWheelEvent);
                        return this.copyWheelData(e, t), this.copyMouseData(e, t), this.copyData(e, t), t.nativeEvent = e.nativeEvent, t.originalEvent = e, t.target = this.hitTest(t.global.x, t.global.y), t
                    }
                    clonePointerEvent(e, t) {
                        const r = this.allocateEvent(o.FederatedPointerEvent);
                        return r.nativeEvent = e.nativeEvent, r.originalEvent = e.originalEvent, this.copyPointerData(e, r), this.copyMouseData(e, r), this.copyData(e, r), r.target = e.target, r.path = e.composedPath().slice(), r.type = t ?? r.type, r
                    }
                    copyWheelData(e, t) {
                        t.deltaMode = e.deltaMode, t.deltaX = e.deltaX, t.deltaY = e.deltaY, t.deltaZ = e.deltaZ
                    }
                    copyPointerData(e, t) {
                        e instanceof o.FederatedPointerEvent && t instanceof o.FederatedPointerEvent && (t.pointerId = e.pointerId, t.width = e.width, t.height = e.height, t.isPrimary = e.isPrimary, t.pointerType = e.pointerType, t.pressure = e.pressure, t.tangentialPressure = e.tangentialPressure, t.tiltX = e.tiltX, t.tiltY = e.tiltY, t.twist = e.twist)
                    }
                    copyMouseData(e, t) {
                        e instanceof n.FederatedMouseEvent && t instanceof n.FederatedMouseEvent && (t.altKey = e.altKey, t.button = e.button, t.buttons = e.buttons, t.client.copyFrom(e.client), t.ctrlKey = e.ctrlKey, t.metaKey = e.metaKey, t.movement.copyFrom(e.movement), t.screen.copyFrom(e.screen), t.shiftKey = e.shiftKey, t.global.copyFrom(e.global))
                    }
                    copyData(e, t) {
                        t.isTrusted = e.isTrusted, t.srcElement = e.srcElement, t.timeStamp = performance.now(), t.type = e.type, t.detail = e.detail, t.view = e.view, t.which = e.which, t.layer.copyFrom(e.layer), t.page.copyFrom(e.page)
                    }
                    trackingData(e) {
                        return this.mappingState.trackingData[e] || (this.mappingState.trackingData[e] = {
                            pressTargetsByButton: {},
                            clicksByButton: {},
                            overTarget: null
                        }), this.mappingState.trackingData[e]
                    }
                    allocateEvent(e) {
                        this.eventPool.has(e) || this.eventPool.set(e, []);
                        const t = this.eventPool.get(e).pop() || new e(this);
                        return t.eventPhase = t.NONE, t.currentTarget = null, t.path = null, t.target = null, t
                    }
                    freeEvent(e) {
                        if (e.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
                        const t = e.constructor;
                        this.eventPool.has(t) || this.eventPool.set(t, []), this.eventPool.get(t).push(e)
                    }
                    notifyListeners(e, t) {
                        const r = e.currentTarget._events[t];
                        if (r && e.currentTarget.isInteractive())
                            if ("fn" in r) r.once && e.currentTarget.removeListener(t, r.fn, void 0, !0), r.fn.call(r.context, e);
                            else
                                for (let i = 0, s = r.length; i < s && !e.propagationImmediatelyStopped; i++) r[i].once && e.currentTarget.removeListener(t, r[i].fn, void 0, !0), r[i].fn.call(r[i].context, e)
                    }
                }
            },
            192: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(3240),
                    n = r(9106),
                    o = r(3438),
                    a = r(6911);
                const h = {
                        touchstart: "pointerdown",
                        touchend: "pointerup",
                        touchendoutside: "pointerupoutside",
                        touchmove: "pointermove",
                        touchcancel: "pointercancel"
                    },
                    l = class {
                        constructor(e) {
                            this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = e, this.rootBoundary = new s.EventBoundary(null), n.EventsTicker.init(this), this.autoPreventDefault = !0, this.eventsAdded = !1, this.rootPointerEvent = new o.FederatedPointerEvent(null), this.rootWheelEvent = new a.FederatedWheelEvent(null), this.cursorStyles = {
                                default: "inherit",
                                pointer: "pointer"
                            }, this.features = new Proxy({
                                ...l.defaultEventFeatures
                            }, {
                                set: (e, t, r) => ("globalMove" === t && (this.rootBoundary.enableGlobalMoveEvents = r), e[t] = r, !0)
                            }), this.onPointerDown = this.onPointerDown.bind(this), this.onPointerMove = this.onPointerMove.bind(this), this.onPointerUp = this.onPointerUp.bind(this), this.onPointerOverOut = this.onPointerOverOut.bind(this), this.onWheel = this.onWheel.bind(this)
                        }
                        static get defaultEventMode() {
                            return this._defaultEventMode
                        }
                        init(e) {
                            const {
                                view: t,
                                resolution: r
                            } = this.renderer;
                            this.setTargetElement(t), this.resolution = r, l._defaultEventMode = e.eventMode ?? "auto", Object.assign(this.features, e.eventFeatures ?? {}), this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove
                        }
                        resolutionChange(e) {
                            this.resolution = e
                        }
                        destroy() {
                            this.setTargetElement(null), this.renderer = null
                        }
                        setCursor(e) {
                            e = e || "default";
                            let t = !0;
                            if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (t = !1), this.currentCursor === e) return;
                            this.currentCursor = e;
                            const r = this.cursorStyles[e];
                            if (r) switch (typeof r) {
                                case "string":
                                    t && (this.domElement.style.cursor = r);
                                    break;
                                case "function":
                                    r(e);
                                    break;
                                case "object":
                                    t && Object.assign(this.domElement.style, r)
                            } else t && "string" == typeof e && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.domElement.style.cursor = e)
                        }
                        get pointer() {
                            return this.rootPointerEvent
                        }
                        onPointerDown(e) {
                            if (!this.features.click) return;
                            if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && "touch" === e.pointerType) return;
                            const t = this.normalizeToPointerData(e);
                            this.autoPreventDefault && t[0].isNormalized && (e.cancelable || !("cancelable" in e)) && e.preventDefault();
                            for (let e = 0, r = t.length; e < r; e++) {
                                const r = t[e],
                                    i = this.bootstrapEvent(this.rootPointerEvent, r);
                                this.rootBoundary.mapEvent(i)
                            }
                            this.setCursor(this.rootBoundary.cursor)
                        }
                        onPointerMove(e) {
                            if (!this.features.move) return;
                            if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && "touch" === e.pointerType) return;
                            n.EventsTicker.pointerMoved();
                            const t = this.normalizeToPointerData(e);
                            for (let e = 0, r = t.length; e < r; e++) {
                                const r = this.bootstrapEvent(this.rootPointerEvent, t[e]);
                                this.rootBoundary.mapEvent(r)
                            }
                            this.setCursor(this.rootBoundary.cursor)
                        }
                        onPointerUp(e) {
                            if (!this.features.click) return;
                            if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && "touch" === e.pointerType) return;
                            let t = e.target;
                            e.composedPath && e.composedPath().length > 0 && (t = e.composedPath()[0]);
                            const r = t !== this.domElement ? "outside" : "",
                                i = this.normalizeToPointerData(e);
                            for (let e = 0, t = i.length; e < t; e++) {
                                const t = this.bootstrapEvent(this.rootPointerEvent, i[e]);
                                t.type += r, this.rootBoundary.mapEvent(t)
                            }
                            this.setCursor(this.rootBoundary.cursor)
                        }
                        onPointerOverOut(e) {
                            if (!this.features.click) return;
                            if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && "touch" === e.pointerType) return;
                            const t = this.normalizeToPointerData(e);
                            for (let e = 0, r = t.length; e < r; e++) {
                                const r = this.bootstrapEvent(this.rootPointerEvent, t[e]);
                                this.rootBoundary.mapEvent(r)
                            }
                            this.setCursor(this.rootBoundary.cursor)
                        }
                        onWheel(e) {
                            if (!this.features.wheel) return;
                            const t = this.normalizeWheelEvent(e);
                            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(t)
                        }
                        setTargetElement(e) {
                            this.removeEvents(), this.domElement = e, n.EventsTicker.domElement = e, this.addEvents()
                        }
                        addEvents() {
                            if (this.eventsAdded || !this.domElement) return;
                            n.EventsTicker.addTickerListener();
                            const e = this.domElement.style;
                            e && (globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "none", e.msTouchAction = "none") : this.supportsPointerEvents && (e.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, !0), this.domElement.addEventListener("pointerdown", this.onPointerDown, !0), this.domElement.addEventListener("pointerleave", this.onPointerOverOut, !0), this.domElement.addEventListener("pointerover", this.onPointerOverOut, !0), globalThis.addEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, !0), this.domElement.addEventListener("mousedown", this.onPointerDown, !0), this.domElement.addEventListener("mouseout", this.onPointerOverOut, !0), this.domElement.addEventListener("mouseover", this.onPointerOverOut, !0), globalThis.addEventListener("mouseup", this.onPointerUp, !0)), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this.onPointerDown, !0), this.domElement.addEventListener("touchend", this.onPointerUp, !0), this.domElement.addEventListener("touchmove", this.onPointerMove, !0)), this.domElement.addEventListener("wheel", this.onWheel, {
                                passive: !0,
                                capture: !0
                            }), this.eventsAdded = !0
                        }
                        removeEvents() {
                            if (!this.eventsAdded || !this.domElement) return;
                            n.EventsTicker.removeTickerListener();
                            const e = this.domElement.style;
                            globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "", e.msTouchAction = "") : this.supportsPointerEvents && (e.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, !0), this.domElement.removeEventListener("pointerdown", this.onPointerDown, !0), this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, !0), this.domElement.removeEventListener("pointerover", this.onPointerOverOut, !0), globalThis.removeEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, !0), this.domElement.removeEventListener("mousedown", this.onPointerDown, !0), this.domElement.removeEventListener("mouseout", this.onPointerOverOut, !0), this.domElement.removeEventListener("mouseover", this.onPointerOverOut, !0), globalThis.removeEventListener("mouseup", this.onPointerUp, !0)), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this.onPointerDown, !0), this.domElement.removeEventListener("touchend", this.onPointerUp, !0), this.domElement.removeEventListener("touchmove", this.onPointerMove, !0)), this.domElement.removeEventListener("wheel", this.onWheel, !0), this.domElement = null, this.eventsAdded = !1
                        }
                        mapPositionToPoint(e, t, r) {
                            let i;
                            i = this.domElement.parentElement ? this.domElement.getBoundingClientRect() : {
                                x: 0,
                                y: 0,
                                width: this.domElement.width,
                                height: this.domElement.height,
                                left: 0,
                                top: 0
                            };
                            const s = 1 / this.resolution;
                            e.x = (t - i.left) * (this.domElement.width / i.width) * s, e.y = (r - i.top) * (this.domElement.height / i.height) * s
                        }
                        normalizeToPointerData(e) {
                            const t = [];
                            if (this.supportsTouchEvents && e instanceof TouchEvent)
                                for (let r = 0, i = e.changedTouches.length; r < i; r++) {
                                    const i = e.changedTouches[r];
                                    void 0 === i.button && (i.button = 0), void 0 === i.buttons && (i.buttons = 1), void 0 === i.isPrimary && (i.isPrimary = 1 === e.touches.length && "touchstart" === e.type), void 0 === i.width && (i.width = i.radiusX || 1), void 0 === i.height && (i.height = i.radiusY || 1), void 0 === i.tiltX && (i.tiltX = 0), void 0 === i.tiltY && (i.tiltY = 0), void 0 === i.pointerType && (i.pointerType = "touch"), void 0 === i.pointerId && (i.pointerId = i.identifier || 0), void 0 === i.pressure && (i.pressure = i.force || .5), void 0 === i.twist && (i.twist = 0), void 0 === i.tangentialPressure && (i.tangentialPressure = 0), void 0 === i.layerX && (i.layerX = i.offsetX = i.clientX), void 0 === i.layerY && (i.layerY = i.offsetY = i.clientY), i.isNormalized = !0, i.type = e.type, t.push(i)
                                } else if (!globalThis.MouseEvent || e instanceof MouseEvent && !(this.supportsPointerEvents && e instanceof globalThis.PointerEvent)) {
                                    const r = e;
                                    void 0 === r.isPrimary && (r.isPrimary = !0), void 0 === r.width && (r.width = 1), void 0 === r.height && (r.height = 1), void 0 === r.tiltX && (r.tiltX = 0), void 0 === r.tiltY && (r.tiltY = 0), void 0 === r.pointerType && (r.pointerType = "mouse"), void 0 === r.pointerId && (r.pointerId = 1), void 0 === r.pressure && (r.pressure = .5), void 0 === r.twist && (r.twist = 0), void 0 === r.tangentialPressure && (r.tangentialPressure = 0), r.isNormalized = !0, t.push(r)
                                } else t.push(e);
                            return t
                        }
                        normalizeWheelEvent(e) {
                            const t = this.rootWheelEvent;
                            return this.transferMouseData(t, e), t.deltaX = e.deltaX, t.deltaY = e.deltaY, t.deltaZ = e.deltaZ, t.deltaMode = e.deltaMode, this.mapPositionToPoint(t.screen, e.clientX, e.clientY), t.global.copyFrom(t.screen), t.offset.copyFrom(t.screen), t.nativeEvent = e, t.type = e.type, t
                        }
                        bootstrapEvent(e, t) {
                            return e.originalEvent = null, e.nativeEvent = t, e.pointerId = t.pointerId, e.width = t.width, e.height = t.height, e.isPrimary = t.isPrimary, e.pointerType = t.pointerType, e.pressure = t.pressure, e.tangentialPressure = t.tangentialPressure, e.tiltX = t.tiltX, e.tiltY = t.tiltY, e.twist = t.twist, this.transferMouseData(e, t), this.mapPositionToPoint(e.screen, t.clientX, t.clientY), e.global.copyFrom(e.screen), e.offset.copyFrom(e.screen), e.isTrusted = t.isTrusted, "pointerleave" === e.type && (e.type = "pointerout"), e.type.startsWith("mouse") && (e.type = e.type.replace("mouse", "pointer")), e.type.startsWith("touch") && (e.type = h[e.type] || e.type), e
                        }
                        transferMouseData(e, t) {
                            e.isTrusted = t.isTrusted, e.srcElement = t.srcElement, e.timeStamp = performance.now(), e.type = t.type, e.altKey = t.altKey, e.button = t.button, e.buttons = t.buttons, e.client.x = t.clientX, e.client.y = t.clientY, e.ctrlKey = t.ctrlKey, e.metaKey = t.metaKey, e.movement.x = t.movementX, e.movement.y = t.movementY, e.page.x = t.pageX, e.page.y = t.pageY, e.relatedTarget = null, e.shiftKey = t.shiftKey
                        }
                    };
                let u = l;
                u.extension = {
                    name: "events",
                    type: [i.ExtensionType.RendererSystem, i.ExtensionType.CanvasRendererSystem]
                }, u.defaultEventFeatures = {
                    move: !0,
                    globalMove: !0,
                    click: !0,
                    wheel: !0
                }, i.extensions.add(u), t.EventSystem = u
            },
            9106: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                const s = new class {
                    constructor() {
                        this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = !1, this.tickerAdded = !1, this._pauseUpdate = !0
                    }
                    init(e) {
                        this.removeTickerListener(), this.events = e, this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = !1, this.tickerAdded = !1, this._pauseUpdate = !0
                    }
                    get pauseUpdate() {
                        return this._pauseUpdate
                    }
                    set pauseUpdate(e) {
                        this._pauseUpdate = e
                    }
                    addTickerListener() {
                        !this.tickerAdded && this.domElement && (i.Ticker.system.add(this.tickerUpdate, this, i.UPDATE_PRIORITY.INTERACTION), this.tickerAdded = !0)
                    }
                    removeTickerListener() {
                        this.tickerAdded && (i.Ticker.system.remove(this.tickerUpdate, this), this.tickerAdded = !1)
                    }
                    pointerMoved() {
                        this._didMove = !0
                    }
                    update() {
                        if (!this.domElement || this._pauseUpdate) return;
                        if (this._didMove) return void(this._didMove = !1);
                        const e = this.events.rootPointerEvent;
                        this.events.supportsTouchEvents && "touch" === e.pointerType || globalThis.document.dispatchEvent(new PointerEvent("pointermove", {
                            clientX: e.clientX,
                            clientY: e.clientY
                        }))
                    }
                    tickerUpdate(e) {
                        this._deltaTime += e, this._deltaTime < this.interactionFrequency || (this._deltaTime = 0, this.update())
                    }
                };
                t.EventsTicker = s
            },
            3564: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                class s {
                    constructor(e) {
                        this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = s.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = new i.Point, this.page = new i.Point, this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = e
                    }
                    get layerX() {
                        return this.layer.x
                    }
                    get layerY() {
                        return this.layer.y
                    }
                    get pageX() {
                        return this.page.x
                    }
                    get pageY() {
                        return this.page.y
                    }
                    get data() {
                        return this
                    }
                    composedPath() {
                        return !this.manager || this.path && this.path[this.path.length - 1] === this.target || (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path
                    }
                    initEvent(e, t, r) {
                        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
                    }
                    initUIEvent(e, t, r, i, s) {
                        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
                    }
                    preventDefault() {
                        this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = !0
                    }
                    stopImmediatePropagation() {
                        this.propagationImmediatelyStopped = !0
                    }
                    stopPropagation() {
                        this.propagationStopped = !0
                    }
                }
                t.FederatedEvent = s
            },
            1235: () => {},
            4606: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2781),
                    s = r(6128),
                    n = r(192),
                    o = r(3564);

                function a(e) {
                    return "dynamic" === e || "static" === e
                }
                const h = {
                    onclick: null,
                    onmousedown: null,
                    onmouseenter: null,
                    onmouseleave: null,
                    onmousemove: null,
                    onglobalmousemove: null,
                    onmouseout: null,
                    onmouseover: null,
                    onmouseup: null,
                    onmouseupoutside: null,
                    onpointercancel: null,
                    onpointerdown: null,
                    onpointerenter: null,
                    onpointerleave: null,
                    onpointermove: null,
                    onglobalpointermove: null,
                    onpointerout: null,
                    onpointerover: null,
                    onpointertap: null,
                    onpointerup: null,
                    onpointerupoutside: null,
                    onrightclick: null,
                    onrightdown: null,
                    onrightup: null,
                    onrightupoutside: null,
                    ontap: null,
                    ontouchcancel: null,
                    ontouchend: null,
                    ontouchendoutside: null,
                    ontouchmove: null,
                    onglobaltouchmove: null,
                    ontouchstart: null,
                    onwheel: null,
                    _internalInteractive: void 0,
                    get interactive() {
                        return this._internalInteractive ?? a(n.EventSystem.defaultEventMode)
                    },
                    set interactive(e) {
                        s.deprecation("7.2.0", "Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead."), this._internalInteractive = e, this.eventMode = e ? "static" : "auto"
                    },
                    _internalEventMode: void 0,
                    get eventMode() {
                        return this._internalEventMode ?? n.EventSystem.defaultEventMode
                    },
                    set eventMode(e) {
                        this._internalInteractive = a(e), this._internalEventMode = e
                    },
                    isInteractive() {
                        return "static" === this.eventMode || "dynamic" === this.eventMode
                    },
                    interactiveChildren: !0,
                    hitArea: null,
                    addEventListener(e, t, r) {
                        const i = "function" == typeof t ? void 0 : t;
                        e = "boolean" == typeof r && r || "object" == typeof r && r.capture ? `${e}capture` : e, t = "function" == typeof t ? t : t.handleEvent, this.on(e, t, i)
                    },
                    removeEventListener(e, t, r) {
                        const i = "function" == typeof t ? void 0 : t;
                        e = "boolean" == typeof r && r || "object" == typeof r && r.capture ? `${e}capture` : e, t = "function" == typeof t ? t : t.handleEvent, this.off(e, t, i)
                    },
                    dispatchEvent(e) {
                        if (!(e instanceof o.FederatedEvent)) throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
                        return e.defaultPrevented = !1, e.path = null, e.target = this, e.manager.dispatchEvent(e), !e.defaultPrevented
                    }
                };
                i.DisplayObject.mixin(h), t.FederatedDisplayObject = h
            },
            7747: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(3564);
                class n extends s.FederatedEvent {
                    constructor() {
                        super(...arguments), this.client = new i.Point, this.movement = new i.Point, this.offset = new i.Point, this.global = new i.Point, this.screen = new i.Point
                    }
                    get clientX() {
                        return this.client.x
                    }
                    get clientY() {
                        return this.client.y
                    }
                    get x() {
                        return this.clientX
                    }
                    get y() {
                        return this.clientY
                    }
                    get movementX() {
                        return this.movement.x
                    }
                    get movementY() {
                        return this.movement.y
                    }
                    get offsetX() {
                        return this.offset.x
                    }
                    get offsetY() {
                        return this.offset.y
                    }
                    get globalX() {
                        return this.global.x
                    }
                    get globalY() {
                        return this.global.y
                    }
                    get screenX() {
                        return this.screen.x
                    }
                    get screenY() {
                        return this.screen.y
                    }
                    getLocalPosition(e, t, r) {
                        return e.worldTransform.applyInverse(r || this.global, t)
                    }
                    getModifierState(e) {
                        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(e)
                    }
                    initMouseEvent(e, t, r, i, s, n, o, a, h, l, u, c, d, p, f) {
                        throw new Error("Method not implemented.")
                    }
                }
                t.FederatedMouseEvent = n
            },
            3438: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7747);
                class s extends i.FederatedMouseEvent {
                    constructor() {
                        super(...arguments), this.width = 0, this.height = 0, this.isPrimary = !1
                    }
                    getCoalescedEvents() {
                        return "pointermove" === this.type || "mousemove" === this.type || "touchmove" === this.type ? [this] : []
                    }
                    getPredictedEvents() {
                        throw new Error("getPredictedEvents is not supported!")
                    }
                }
                t.FederatedPointerEvent = s
            },
            6911: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7747);
                class s extends i.FederatedMouseEvent {
                    constructor() {
                        super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2
                    }
                }
                s.DOM_DELTA_PIXEL = 0, s.DOM_DELTA_LINE = 1, s.DOM_DELTA_PAGE = 2, t.FederatedWheelEvent = s
            },
            4868: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(3240),
                    s = r(192),
                    n = r(3564);
                r(1235);
                var o = r(4606),
                    a = r(7747),
                    h = r(3438),
                    l = r(6911);
                t.EventBoundary = i.EventBoundary, t.EventSystem = s.EventSystem, t.FederatedEvent = n.FederatedEvent, t.FederatedDisplayObject = o.FederatedDisplayObject, t.FederatedMouseEvent = a.FederatedMouseEvent, t.FederatedPointerEvent = h.FederatedPointerEvent, t.FederatedWheelEvent = l.FederatedWheelEvent
            },
            7222: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = (e => (e.Renderer = "renderer", e.Application = "application", e.RendererSystem = "renderer-webgl-system", e.RendererPlugin = "renderer-webgl-plugin", e.CanvasRendererSystem = "renderer-canvas-system", e.CanvasRendererPlugin = "renderer-canvas-plugin", e.Asset = "asset", e.LoadParser = "load-parser", e.ResolveParser = "resolve-parser", e.CacheParser = "cache-parser", e.DetectionParser = "detection-parser", e))(r || {});
                const i = e => {
                        if ("function" == typeof e || "object" == typeof e && e.extension) {
                            if (!e.extension) throw new Error("Extension class must have an extension object");
                            e = {
                                ..."object" != typeof e.extension ? {
                                    type: e.extension
                                } : e.extension,
                                ref: e
                            }
                        }
                        if ("object" != typeof e) throw new Error("Invalid extension type");
                        return "string" == typeof(e = {
                            ...e
                        }).type && (e.type = [e.type]), e
                    },
                    s = (e, t) => i(e).priority ?? t,
                    n = {
                        _addHandlers: {},
                        _removeHandlers: {},
                        _queue: {},
                        remove(...e) {
                            return e.map(i).forEach((e => {
                                e.type.forEach((t => this._removeHandlers[t]?.(e)))
                            })), this
                        },
                        add(...e) {
                            return e.map(i).forEach((e => {
                                e.type.forEach((t => {
                                    const r = this._addHandlers,
                                        i = this._queue;
                                    r[t] ? r[t](e) : (i[t] = i[t] || [], i[t].push(e))
                                }))
                            })), this
                        },
                        handle(e, t, r) {
                            const i = this._addHandlers,
                                s = this._removeHandlers;
                            if (i[e] || s[e]) throw new Error(`Extension type ${e} already has a handler`);
                            i[e] = t, s[e] = r;
                            const n = this._queue;
                            return n[e] && (n[e].forEach((e => t(e))), delete n[e]), this
                        },
                        handleByMap(e, t) {
                            return this.handle(e, (e => {
                                t[e.name] = e.ref
                            }), (e => {
                                delete t[e.name]
                            }))
                        },
                        handleByList(e, t, r = -1) {
                            return this.handle(e, (e => {
                                t.includes(e.ref) || (t.push(e.ref), t.sort(((e, t) => s(t, r) - s(e, r))))
                            }), (e => {
                                const r = t.indexOf(e.ref); - 1 !== r && t.splice(r, 1)
                            }))
                        }
                    };
                t.ExtensionType = r, t.extensions = n
            },
            5632: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                const s = new i.Rectangle,
                    n = class {
                        constructor(e) {
                            this.renderer = e
                        }
                        async image(e, t, r) {
                            const i = new Image;
                            return i.src = await this.base64(e, t, r), i
                        }
                        async base64(e, t, r) {
                            const i = this.canvas(e);
                            if (void 0 !== i.toDataURL) return i.toDataURL(t, r);
                            if (void 0 !== i.convertToBlob) {
                                const e = await i.convertToBlob({
                                    type: t,
                                    quality: r
                                });
                                return await new Promise((t => {
                                    const r = new FileReader;
                                    r.onload = () => t(r.result), r.readAsDataURL(e)
                                }))
                            }
                            throw new Error("Extract.base64() requires ICanvas.toDataURL or ICanvas.convertToBlob to be implemented")
                        }
                        canvas(e, t) {
                            const {
                                pixels: r,
                                width: s,
                                height: o,
                                flipY: a
                            } = this._rawPixels(e, t);
                            let h = new i.utils.CanvasRenderTarget(s, o, 1);
                            const l = h.context.getImageData(0, 0, s, o);
                            if (n.arrayPostDivide(r, l.data), h.context.putImageData(l, 0, 0), a) {
                                const e = new i.utils.CanvasRenderTarget(h.width, h.height, 1);
                                e.context.scale(1, -1), e.context.drawImage(h.canvas, 0, -o), h.destroy(), h = e
                            }
                            return h.canvas
                        }
                        pixels(e, t) {
                            const {
                                pixels: r
                            } = this._rawPixels(e, t);
                            return n.arrayPostDivide(r, r), r
                        }
                        _rawPixels(e, t) {
                            const r = this.renderer;
                            if (!r) throw new Error("The Extract has already been destroyed");
                            let n, o, a = !1,
                                h = !1;
                            if (e)
                                if (e instanceof i.RenderTexture) o = e;
                                else {
                                    const t = r.context.webGLVersion >= 2 ? r.multisample : i.MSAA_QUALITY.NONE;
                                    if (o = r.generateTexture(e, {
                                            multisample: t
                                        }), t !== i.MSAA_QUALITY.NONE) {
                                        const e = i.RenderTexture.create({
                                            width: o.width,
                                            height: o.height
                                        });
                                        r.framebuffer.bind(o.framebuffer), r.framebuffer.blit(e.framebuffer), r.framebuffer.bind(), o.destroy(!0), o = e
                                    }
                                    h = !0
                                } o ? (n = o.baseTexture.resolution, t = t ?? o.frame, a = !1, r.renderTexture.bind(o)) : (n = r.resolution, t || ((t = s).width = r.width, t.height = r.height), a = !0, r.renderTexture.bind());
                            const l = Math.round(t.width * n),
                                u = Math.round(t.height * n),
                                c = new Uint8Array(4 * l * u),
                                d = r.gl;
                            return d.readPixels(Math.round(t.x * n), Math.round(t.y * n), l, u, d.RGBA, d.UNSIGNED_BYTE, c), h && o?.destroy(!0), {
                                pixels: c,
                                width: l,
                                height: u,
                                flipY: a
                            }
                        }
                        destroy() {
                            this.renderer = null
                        }
                        static arrayPostDivide(e, t) {
                            for (let r = 0; r < e.length; r += 4) {
                                const i = t[r + 3] = e[r + 3];
                                0 !== i ? (t[r] = Math.round(Math.min(255 * e[r] / i, 255)), t[r + 1] = Math.round(Math.min(255 * e[r + 1] / i, 255)), t[r + 2] = Math.round(Math.min(255 * e[r + 2] / i, 255))) : (t[r] = e[r], t[r + 1] = e[r + 1], t[r + 2] = e[r + 2])
                            }
                        }
                    };
                let o = n;
                o.extension = {
                    name: "extract",
                    type: i.ExtensionType.RendererSystem
                }, i.extensions.add(o), t.Extract = o
            },
            2110: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(5632);
                t.Extract = i.Extract
            },
            8563: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(4633);
                class n extends i.Filter {
                    constructor(e = 1) {
                        super(i.defaultVertex, s.default, {
                            uAlpha: 1
                        }), this.alpha = e
                    }
                    get alpha() {
                        return this.uniforms.uAlpha
                    }
                    set alpha(e) {
                        this.uniforms.uAlpha = e
                    }
                }
                t.AlphaFilter = n
            },
            4633: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float uAlpha;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;\n}\n"
            },
            2005: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(8563);
                t.AlphaFilter = i.AlphaFilter
            },
            7515: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(4315);
                class n extends i.Filter {
                    constructor(e = 8, t = 4, r = i.Filter.defaultResolution, n = 5) {
                        super(), this._repeatEdgePixels = !1, this.blurXFilter = new s.BlurFilterPass(!0, e, t, r, n), this.blurYFilter = new s.BlurFilterPass(!1, e, t, r, n), this.resolution = r, this.quality = t, this.blur = e, this.repeatEdgePixels = !1
                    }
                    apply(e, t, r, s) {
                        const n = Math.abs(this.blurXFilter.strength),
                            o = Math.abs(this.blurYFilter.strength);
                        if (n && o) {
                            const n = e.getFilterTexture();
                            this.blurXFilter.apply(e, t, n, i.CLEAR_MODES.CLEAR), this.blurYFilter.apply(e, n, r, s), e.returnFilterTexture(n)
                        } else o ? this.blurYFilter.apply(e, t, r, s) : this.blurXFilter.apply(e, t, r, s)
                    }
                    updatePadding() {
                        this._repeatEdgePixels ? this.padding = 0 : this.padding = 2 * Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength))
                    }
                    get blur() {
                        return this.blurXFilter.blur
                    }
                    set blur(e) {
                        this.blurXFilter.blur = this.blurYFilter.blur = e, this.updatePadding()
                    }
                    get quality() {
                        return this.blurXFilter.quality
                    }
                    set quality(e) {
                        this.blurXFilter.quality = this.blurYFilter.quality = e
                    }
                    get blurX() {
                        return this.blurXFilter.blur
                    }
                    set blurX(e) {
                        this.blurXFilter.blur = e, this.updatePadding()
                    }
                    get blurY() {
                        return this.blurYFilter.blur
                    }
                    set blurY(e) {
                        this.blurYFilter.blur = e, this.updatePadding()
                    }
                    get blendMode() {
                        return this.blurYFilter.blendMode
                    }
                    set blendMode(e) {
                        this.blurYFilter.blendMode = e
                    }
                    get repeatEdgePixels() {
                        return this._repeatEdgePixels
                    }
                    set repeatEdgePixels(e) {
                        this._repeatEdgePixels = e, this.updatePadding()
                    }
                }
                t.BlurFilter = n
            },
            4315: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(8472),
                    n = r(6967);
                class o extends i.Filter {
                    constructor(e, t = 8, r = 4, o = i.Filter.defaultResolution, a = 5) {
                        super(n.generateBlurVertSource(a, e), s.generateBlurFragSource(a)), this.horizontal = e, this.resolution = o, this._quality = 0, this.quality = r, this.blur = t
                    }
                    apply(e, t, r, s) {
                        if (r ? this.horizontal ? this.uniforms.strength = 1 / r.width * (r.width / t.width) : this.uniforms.strength = 1 / r.height * (r.height / t.height) : this.horizontal ? this.uniforms.strength = 1 / e.renderer.width * (e.renderer.width / t.width) : this.uniforms.strength = 1 / e.renderer.height * (e.renderer.height / t.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, 1 === this.passes) e.applyFilter(this, t, r, s);
                        else {
                            const n = e.getFilterTexture(),
                                o = e.renderer;
                            let a = t,
                                h = n;
                            this.state.blend = !1, e.applyFilter(this, a, h, i.CLEAR_MODES.CLEAR);
                            for (let t = 1; t < this.passes - 1; t++) {
                                e.bindAndClear(a, i.CLEAR_MODES.BLIT), this.uniforms.uSampler = h;
                                const t = h;
                                h = a, a = t, o.shader.bind(this), o.geometry.draw(5)
                            }
                            this.state.blend = !0, e.applyFilter(this, h, r, s), e.returnFilterTexture(n)
                        }
                    }
                    get blur() {
                        return this.strength
                    }
                    set blur(e) {
                        this.padding = 1 + 2 * Math.abs(e), this.strength = e
                    }
                    get quality() {
                        return this._quality
                    }
                    set quality(e) {
                        this._quality = e, this.passes = e
                    }
                }
                t.BlurFilterPass = o
            },
            8472: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const r = {
                        5: [.153388, .221461, .250301],
                        7: [.071303, .131514, .189879, .214607],
                        9: [.028532, .067234, .124009, .179044, .20236],
                        11: [.0093, .028002, .065984, .121703, .175713, .198596],
                        13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
                        15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
                    },
                    i = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join("\n");
                t.generateBlurFragSource = function(e) {
                    const t = r[e],
                        s = t.length;
                    let n, o = i,
                        a = "";
                    for (let r = 0; r < e; r++) {
                        let i = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;".replace("%index%", r.toString());
                        n = r, r >= s && (n = e - r - 1), i = i.replace("%value%", t[n].toString()), a += i, a += "\n"
                    }
                    return o = o.replace("%blur%", a), o = o.replace("%size%", e.toString()), o
                }
            },
            6967: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.generateBlurVertSource = function(e, t) {
                    const r = Math.ceil(e / 2);
                    let i, s = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n\n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n\n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }",
                        n = "";
                    i = t ? "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
                    for (let t = 0; t < e; t++) {
                        let e = i.replace("%index%", t.toString());
                        e = e.replace("%sampleIndex%", t - (r - 1) + ".0"), n += e, n += "\n"
                    }
                    return s = s.replace("%blur%", n), s = s.replace("%size%", e.toString()), s
                }
            },
            7155: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7515),
                    s = r(4315);
                t.BlurFilter = i.BlurFilter, t.BlurFilterPass = s.BlurFilterPass
            },
            5394: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(2820);
                class n extends i.Filter {
                    constructor() {
                        const e = {
                            m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]),
                            uAlpha: 1
                        };
                        super(i.defaultFilterVertex, s.default, e), this.alpha = 1
                    }
                    _loadMatrix(e, t = !1) {
                        let r = e;
                        t && (this._multiply(r, this.uniforms.m, e), r = this._colorMatrix(r)), this.uniforms.m = r
                    }
                    _multiply(e, t, r) {
                        return e[0] = t[0] * r[0] + t[1] * r[5] + t[2] * r[10] + t[3] * r[15], e[1] = t[0] * r[1] + t[1] * r[6] + t[2] * r[11] + t[3] * r[16], e[2] = t[0] * r[2] + t[1] * r[7] + t[2] * r[12] + t[3] * r[17], e[3] = t[0] * r[3] + t[1] * r[8] + t[2] * r[13] + t[3] * r[18], e[4] = t[0] * r[4] + t[1] * r[9] + t[2] * r[14] + t[3] * r[19] + t[4], e[5] = t[5] * r[0] + t[6] * r[5] + t[7] * r[10] + t[8] * r[15], e[6] = t[5] * r[1] + t[6] * r[6] + t[7] * r[11] + t[8] * r[16], e[7] = t[5] * r[2] + t[6] * r[7] + t[7] * r[12] + t[8] * r[17], e[8] = t[5] * r[3] + t[6] * r[8] + t[7] * r[13] + t[8] * r[18], e[9] = t[5] * r[4] + t[6] * r[9] + t[7] * r[14] + t[8] * r[19] + t[9], e[10] = t[10] * r[0] + t[11] * r[5] + t[12] * r[10] + t[13] * r[15], e[11] = t[10] * r[1] + t[11] * r[6] + t[12] * r[11] + t[13] * r[16], e[12] = t[10] * r[2] + t[11] * r[7] + t[12] * r[12] + t[13] * r[17], e[13] = t[10] * r[3] + t[11] * r[8] + t[12] * r[13] + t[13] * r[18], e[14] = t[10] * r[4] + t[11] * r[9] + t[12] * r[14] + t[13] * r[19] + t[14], e[15] = t[15] * r[0] + t[16] * r[5] + t[17] * r[10] + t[18] * r[15], e[16] = t[15] * r[1] + t[16] * r[6] + t[17] * r[11] + t[18] * r[16], e[17] = t[15] * r[2] + t[16] * r[7] + t[17] * r[12] + t[18] * r[17], e[18] = t[15] * r[3] + t[16] * r[8] + t[17] * r[13] + t[18] * r[18], e[19] = t[15] * r[4] + t[16] * r[9] + t[17] * r[14] + t[18] * r[19] + t[19], e
                    }
                    _colorMatrix(e) {
                        const t = new Float32Array(e);
                        return t[4] /= 255, t[9] /= 255, t[14] /= 255, t[19] /= 255, t
                    }
                    brightness(e, t) {
                        const r = [e, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 1, 0];
                        this._loadMatrix(r, t)
                    }
                    tint(e, t) {
                        const [r, s, n] = i.Color.shared.setValue(e).toArray(), o = [r, 0, 0, 0, 0, 0, s, 0, 0, 0, 0, 0, n, 0, 0, 0, 0, 0, 1, 0];
                        this._loadMatrix(o, t)
                    }
                    greyscale(e, t) {
                        const r = [e, e, e, 0, 0, e, e, e, 0, 0, e, e, e, 0, 0, 0, 0, 0, 1, 0];
                        this._loadMatrix(r, t)
                    }
                    blackAndWhite(e) {
                        this._loadMatrix([.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0], e)
                    }
                    hue(e, t) {
                        e = (e || 0) / 180 * Math.PI;
                        const r = Math.cos(e),
                            i = Math.sin(e),
                            s = 1 / 3,
                            n = (0, Math.sqrt)(s),
                            o = [r + (1 - r) * s, s * (1 - r) - n * i, s * (1 - r) + n * i, 0, 0, s * (1 - r) + n * i, r + s * (1 - r), s * (1 - r) - n * i, 0, 0, s * (1 - r) - n * i, s * (1 - r) + n * i, r + s * (1 - r), 0, 0, 0, 0, 0, 1, 0];
                        this._loadMatrix(o, t)
                    }
                    contrast(e, t) {
                        const r = (e || 0) + 1,
                            i = -.5 * (r - 1),
                            s = [r, 0, 0, 0, i, 0, r, 0, 0, i, 0, 0, r, 0, i, 0, 0, 0, 1, 0];
                        this._loadMatrix(s, t)
                    }
                    saturate(e = 0, t) {
                        const r = 2 * e / 3 + 1,
                            i = -.5 * (r - 1),
                            s = [r, i, i, 0, 0, i, r, i, 0, 0, i, i, r, 0, 0, 0, 0, 0, 1, 0];
                        this._loadMatrix(s, t)
                    }
                    desaturate() {
                        this.saturate(-1)
                    }
                    negative(e) {
                        this._loadMatrix([-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0], e)
                    }
                    sepia(e) {
                        this._loadMatrix([.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0], e)
                    }
                    technicolor(e) {
                        this._loadMatrix([1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0], e)
                    }
                    polaroid(e) {
                        this._loadMatrix([1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0], e)
                    }
                    toBGR(e) {
                        this._loadMatrix([0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], e)
                    }
                    kodachrome(e) {
                        this._loadMatrix([1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0], e)
                    }
                    browni(e) {
                        this._loadMatrix([.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0], e)
                    }
                    vintage(e) {
                        this._loadMatrix([.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0], e)
                    }
                    colorTone(e, t, r, s, n) {
                        e = e || .2, t = t || .15, r = r || 16770432, s = s || 3375104;
                        const o = i.Color.shared,
                            [a, h, l] = o.setValue(r).toArray(),
                            [u, c, d] = o.setValue(s).toArray(),
                            p = [.3, .59, .11, 0, 0, a, h, l, e, 0, u, c, d, t, 0, a - u, h - c, l - d, 0, 0];
                        this._loadMatrix(p, n)
                    }
                    night(e, t) {
                        const r = [-2 * (e = e || .1), -e, 0, 0, 0, -e, 0, e, 0, 0, 0, e, 2 * e, 0, 0, 0, 0, 0, 1, 0];
                        this._loadMatrix(r, t)
                    }
                    predator(e, t) {
                        const r = [11.224130630493164 * e, -4.794486999511719 * e, -2.8746118545532227 * e, 0 * e, .40342438220977783 * e, -3.6330697536468506 * e, 9.193157196044922 * e, -2.951810836791992 * e, 0 * e, -1.316135048866272 * e, -3.2184197902679443 * e, -4.2375030517578125 * e, 7.476448059082031 * e, 0 * e, .8044459223747253 * e, 0, 0, 0, 1, 0];
                        this._loadMatrix(r, t)
                    }
                    lsd(e) {
                        this._loadMatrix([2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0], e)
                    }
                    reset() {
                        this._loadMatrix([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], !1)
                    }
                    get matrix() {
                        return this.uniforms.m
                    }
                    set matrix(e) {
                        this.uniforms.m = e
                    }
                    get alpha() {
                        return this.uniforms.uAlpha
                    }
                    set alpha(e) {
                        this.uniforms.uAlpha = e
                    }
                }
                n.prototype.grayscale = n.prototype.greyscale, t.ColorMatrixFilter = n
            },
            2820: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n"
            },
            1496: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(5394);
                t.ColorMatrixFilter = i.ColorMatrixFilter
            },
            8177: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(6635),
                    n = r(3355);
                class o extends i.Filter {
                    constructor(e, t) {
                        const r = new i.Matrix;
                        e.renderable = !1, super(n.default, s.default, {
                            mapSampler: e._texture,
                            filterMatrix: r,
                            scale: {
                                x: 1,
                                y: 1
                            },
                            rotation: new Float32Array([1, 0, 0, 1])
                        }), this.maskSprite = e, this.maskMatrix = r, null == t && (t = 20), this.scale = new i.Point(t, t)
                    }
                    apply(e, t, r, i) {
                        this.uniforms.filterMatrix = e.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
                        const s = this.maskSprite.worldTransform,
                            n = Math.sqrt(s.a * s.a + s.b * s.b),
                            o = Math.sqrt(s.c * s.c + s.d * s.d);
                        0 !== n && 0 !== o && (this.uniforms.rotation[0] = s.a / n, this.uniforms.rotation[1] = s.b / n, this.uniforms.rotation[2] = s.c / o, this.uniforms.rotation[3] = s.d / o), e.applyFilter(this, t, r, i)
                    }
                    get map() {
                        return this.uniforms.mapSampler
                    }
                    set map(e) {
                        this.uniforms.mapSampler = e
                    }
                }
                t.DisplacementFilter = o
            },
            6635: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\nuniform mat2 rotation;\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform highp vec4 inputSize;\nuniform vec4 inputClamp;\n\nvoid main(void)\n{\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n  map -= 0.5;\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\n\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\n}\n"
            },
            3355: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "attribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\n}\n\nvoid main(void)\n{\n\tgl_Position = filterVertexPosition();\n\tvTextureCoord = filterTextureCoord();\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\n}\n"
            },
            7290: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(8177);
                t.DisplacementFilter = i.DisplacementFilter
            },
            580: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(6084),
                    n = r(8750);
                class o extends i.Filter {
                    constructor() {
                        super(n.default, s.default)
                    }
                }
                t.FXAAFilter = o
            },
            6084: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = 'varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\nuniform sampler2D uSampler;\nuniform highp vec4 inputSize;\n\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it\'s\n unsupported by WebGL.\n\n --\n\n From:\n https://github.com/mitsuhiko/webgl-meincraft\n\n Copyright (c) 2011 by Armin Ronacher.\n\n Some rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n\n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n\n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n\n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec4 color;\n\n      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n'
            },
            8750: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "\nattribute vec2 aVertexPosition;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vFragCoord;\n\nuniform vec4 inputSize;\nuniform vec4 outputFrame;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n}\n\nvoid texcoords(vec2 fragCoord, vec2 inverseVP,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = filterVertexPosition();\n\n   vFragCoord = aVertexPosition * outputFrame.zw;\n\n   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n"
            },
            9798: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(580);
                t.FXAAFilter = i.FXAAFilter
            },
            3631: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(6862);
                class n extends i.Filter {
                    constructor(e = .5, t = Math.random()) {
                        super(i.defaultFilterVertex, s.default, {
                            uNoise: 0,
                            uSeed: 0
                        }), this.noise = e, this.seed = t
                    }
                    get noise() {
                        return this.uniforms.uNoise
                    }
                    set noise(e) {
                        this.uniforms.uNoise = e
                    }
                    get seed() {
                        return this.uniforms.uSeed
                    }
                    set seed(e) {
                        this.uniforms.uSeed = e
                    }
                }
                t.NoiseFilter = n
            },
            9030: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(3631);
                t.NoiseFilter = i.NoiseFilter
            },
            6862: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n"
            },
            3453: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(2781),
                    n = r(5530),
                    o = r(8977),
                    a = r(3440),
                    h = r(5285);
                r(9356);
                var l = r(9794),
                    u = r(165),
                    c = r(9883);
                const d = {},
                    p = class extends s.Container {
                        constructor(e = null) {
                            super(), this.shader = null, this.pluginName = "batch", this.currentPath = null, this.batches = [], this.batchTint = -1, this.batchDirty = -1, this.vertexData = null, this._fillStyle = new a.FillStyle, this._lineStyle = new h.LineStyle, this._matrix = null, this._holeMode = !1, this.state = i.State.for2d(), this._geometry = e || new o.GraphicsGeometry, this._geometry.refCount++, this._transformID = -1, this._tintColor = new i.Color(16777215), this.blendMode = i.BLEND_MODES.NORMAL
                        }
                        get geometry() {
                            return this._geometry
                        }
                        clone() {
                            return this.finishPoly(), new p(this._geometry)
                        }
                        set blendMode(e) {
                            this.state.blendMode = e
                        }
                        get blendMode() {
                            return this.state.blendMode
                        }
                        get tint() {
                            return this._tintColor.value
                        }
                        set tint(e) {
                            this._tintColor.setValue(e)
                        }
                        get fill() {
                            return this._fillStyle
                        }
                        get line() {
                            return this._lineStyle
                        }
                        lineStyle(e = null, t = 0, r, i = .5, s = !1) {
                            return "number" == typeof e && (e = {
                                width: e,
                                color: t,
                                alpha: r,
                                alignment: i,
                                native: s
                            }), this.lineTextureStyle(e)
                        }
                        lineTextureStyle(e) {
                            const t = {
                                width: 0,
                                texture: i.Texture.WHITE,
                                color: e?.texture ? 16777215 : 0,
                                matrix: null,
                                alignment: .5,
                                native: !1,
                                cap: n.LINE_CAP.BUTT,
                                join: n.LINE_JOIN.MITER,
                                miterLimit: 10
                            };
                            e = Object.assign(t, e), this.normalizeColor(e), this.currentPath && this.startPoly();
                            const r = e.width > 0 && e.alpha > 0;
                            return r ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._lineStyle, {
                                visible: r
                            }, e)) : this._lineStyle.reset(), this
                        }
                        startPoly() {
                            if (this.currentPath) {
                                const e = this.currentPath.points,
                                    t = this.currentPath.points.length;
                                t > 2 && (this.drawShape(this.currentPath), this.currentPath = new i.Polygon, this.currentPath.closeStroke = !1, this.currentPath.points.push(e[t - 2], e[t - 1]))
                            } else this.currentPath = new i.Polygon, this.currentPath.closeStroke = !1
                        }
                        finishPoly() {
                            this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0)
                        }
                        moveTo(e, t) {
                            return this.startPoly(), this.currentPath.points[0] = e, this.currentPath.points[1] = t, this
                        }
                        lineTo(e, t) {
                            this.currentPath || this.moveTo(0, 0);
                            const r = this.currentPath.points,
                                i = r[r.length - 2],
                                s = r[r.length - 1];
                            return i === e && s === t || r.push(e, t), this
                        }
                        _initCurve(e = 0, t = 0) {
                            this.currentPath ? 0 === this.currentPath.points.length && (this.currentPath.points = [e, t]) : this.moveTo(e, t)
                        }
                        quadraticCurveTo(e, t, r, i) {
                            this._initCurve();
                            const s = this.currentPath.points;
                            return 0 === s.length && this.moveTo(0, 0), l.QuadraticUtils.curveTo(e, t, r, i, s), this
                        }
                        bezierCurveTo(e, t, r, i, s, n) {
                            return this._initCurve(), u.BezierUtils.curveTo(e, t, r, i, s, n, this.currentPath.points), this
                        }
                        arcTo(e, t, r, i, s) {
                            this._initCurve(e, t);
                            const n = this.currentPath.points,
                                o = c.ArcUtils.curveTo(e, t, r, i, s, n);
                            if (o) {
                                const {
                                    cx: e,
                                    cy: t,
                                    radius: r,
                                    startAngle: i,
                                    endAngle: s,
                                    anticlockwise: n
                                } = o;
                                this.arc(e, t, r, i, s, n)
                            }
                            return this
                        }
                        arc(e, t, r, s, n, o = !1) {
                            if (s === n) return this;
                            if (!o && n <= s ? n += i.PI_2 : o && s <= n && (s += i.PI_2), 0 == n - s) return this;
                            const a = e + Math.cos(s) * r,
                                h = t + Math.sin(s) * r,
                                l = this._geometry.closePointEps;
                            let u = this.currentPath ? this.currentPath.points : null;
                            if (u) {
                                const e = Math.abs(u[u.length - 2] - a),
                                    t = Math.abs(u[u.length - 1] - h);
                                e < l && t < l || u.push(a, h)
                            } else this.moveTo(a, h), u = this.currentPath.points;
                            return c.ArcUtils.arc(a, h, e, t, r, s, n, o, u), this
                        }
                        beginFill(e = 0, t) {
                            return this.beginTextureFill({
                                texture: i.Texture.WHITE,
                                color: e,
                                alpha: t
                            })
                        }
                        normalizeColor(e) {
                            const t = i.Color.shared.setValue(e.color ?? 0);
                            e.color = t.toNumber(), e.alpha ?? (e.alpha = t.alpha)
                        }
                        beginTextureFill(e) {
                            const t = {
                                texture: i.Texture.WHITE,
                                color: 16777215,
                                matrix: null
                            };
                            e = Object.assign(t, e), this.normalizeColor(e), this.currentPath && this.startPoly();
                            const r = e.alpha > 0;
                            return r ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._fillStyle, {
                                visible: r
                            }, e)) : this._fillStyle.reset(), this
                        }
                        endFill() {
                            return this.finishPoly(), this._fillStyle.reset(), this
                        }
                        drawRect(e, t, r, s) {
                            return this.drawShape(new i.Rectangle(e, t, r, s))
                        }
                        drawRoundedRect(e, t, r, s, n) {
                            return this.drawShape(new i.RoundedRectangle(e, t, r, s, n))
                        }
                        drawCircle(e, t, r) {
                            return this.drawShape(new i.Circle(e, t, r))
                        }
                        drawEllipse(e, t, r, s) {
                            return this.drawShape(new i.Ellipse(e, t, r, s))
                        }
                        drawPolygon(...e) {
                            let t, r = !0;
                            const s = e[0];
                            s.points ? (r = s.closeStroke, t = s.points) : t = Array.isArray(e[0]) ? e[0] : e;
                            const n = new i.Polygon(t);
                            return n.closeStroke = r, this.drawShape(n), this
                        }
                        drawShape(e) {
                            return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this
                        }
                        clear() {
                            return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this
                        }
                        isFastRect() {
                            const e = this._geometry.graphicsData;
                            return !(1 !== e.length || e[0].shape.type !== i.SHAPES.RECT || e[0].matrix || e[0].holes.length || e[0].lineStyle.visible && e[0].lineStyle.width)
                        }
                        _render(e) {
                            this.finishPoly();
                            const t = this._geometry;
                            t.updateBatches(), t.batchable ? (this.batchDirty !== t.batchDirty && this._populateBatches(), this._renderBatched(e)) : (e.batch.flush(), this._renderDirect(e))
                        }
                        _populateBatches() {
                            const e = this._geometry,
                                t = this.blendMode,
                                r = e.batches.length;
                            this.batchTint = -1, this._transformID = -1, this.batchDirty = e.batchDirty, this.batches.length = r, this.vertexData = new Float32Array(e.points);
                            for (let s = 0; s < r; s++) {
                                const r = e.batches[s],
                                    n = r.style.color,
                                    o = new Float32Array(this.vertexData.buffer, 4 * r.attribStart * 2, 2 * r.attribSize),
                                    a = new Float32Array(e.uvsFloat32.buffer, 4 * r.attribStart * 2, 2 * r.attribSize),
                                    h = {
                                        vertexData: o,
                                        blendMode: t,
                                        indices: new Uint16Array(e.indicesUint16.buffer, 2 * r.start, r.size),
                                        uvs: a,
                                        _batchRGB: i.Color.shared.setValue(n).toRgbArray(),
                                        _tintRGB: n,
                                        _texture: r.style.texture,
                                        alpha: r.style.alpha,
                                        worldAlpha: 1
                                    };
                                this.batches[s] = h
                            }
                        }
                        _renderBatched(e) {
                            if (this.batches.length) {
                                e.batch.setObjectRenderer(e.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
                                for (let t = 0, r = this.batches.length; t < r; t++) {
                                    const r = this.batches[t];
                                    r.worldAlpha = this.worldAlpha * r.alpha, e.plugins[this.pluginName].render(r)
                                }
                            }
                        }
                        _renderDirect(e) {
                            const t = this._resolveDirectShader(e),
                                r = this._geometry,
                                s = this.worldAlpha,
                                n = t.uniforms,
                                o = r.drawCalls;
                            n.translationMatrix = this.transform.worldTransform, i.Color.shared.setValue(this._tintColor).premultiply(s).toArray(n.tint), e.shader.bind(t), e.geometry.bind(r, t), e.state.set(this.state);
                            for (let t = 0, i = o.length; t < i; t++) this._renderDrawCallDirect(e, r.drawCalls[t])
                        }
                        _renderDrawCallDirect(e, t) {
                            const {
                                texArray: r,
                                type: i,
                                size: s,
                                start: n
                            } = t, o = r.count;
                            for (let t = 0; t < o; t++) e.texture.bind(r.elements[t], t);
                            e.geometry.draw(i, s, n)
                        }
                        _resolveDirectShader(e) {
                            let t = this.shader;
                            const r = this.pluginName;
                            if (!t) {
                                if (!d[r]) {
                                    const {
                                        maxTextures: t
                                    } = e.plugins[r], s = new Int32Array(t);
                                    for (let e = 0; e < t; e++) s[e] = e;
                                    const n = {
                                            tint: new Float32Array([1, 1, 1, 1]),
                                            translationMatrix: new i.Matrix,
                                            default: i.UniformGroup.from({
                                                uSamplers: s
                                            }, !0)
                                        },
                                        o = e.plugins[r]._shader.program;
                                    d[r] = new i.Shader(o, n)
                                }
                                t = d[r]
                            }
                            return t
                        }
                        _calculateBounds() {
                            this.finishPoly();
                            const e = this._geometry;
                            if (!e.graphicsData.length) return;
                            const {
                                minX: t,
                                minY: r,
                                maxX: i,
                                maxY: s
                            } = e.bounds;
                            this._bounds.addFrame(this.transform, t, r, i, s)
                        }
                        containsPoint(e) {
                            return this.worldTransform.applyInverse(e, p._TEMP_POINT), this._geometry.containsPoint(p._TEMP_POINT)
                        }
                        calculateTints() {
                            if (this.batchTint !== this.tint) {
                                this.batchTint = this._tintColor.toNumber();
                                for (let e = 0; e < this.batches.length; e++) {
                                    const t = this.batches[e];
                                    t._tintRGB = i.Color.shared.setValue(this._tintColor).multiply(t._batchRGB).toLittleEndianNumber()
                                }
                            }
                        }
                        calculateVertices() {
                            const e = this.transform._worldID;
                            if (this._transformID === e) return;
                            this._transformID = e;
                            const t = this.transform.worldTransform,
                                r = t.a,
                                i = t.b,
                                s = t.c,
                                n = t.d,
                                o = t.tx,
                                a = t.ty,
                                h = this._geometry.points,
                                l = this.vertexData;
                            let u = 0;
                            for (let e = 0; e < h.length; e += 2) {
                                const t = h[e],
                                    c = h[e + 1];
                                l[u++] = r * t + s * c + o, l[u++] = n * c + i * t + a
                            }
                        }
                        closePath() {
                            const e = this.currentPath;
                            return e && (e.closeStroke = !0, this.finishPoly()), this
                        }
                        setMatrix(e) {
                            return this._matrix = e, this
                        }
                        beginHole() {
                            return this.finishPoly(), this._holeMode = !0, this
                        }
                        endHole() {
                            return this.finishPoly(), this._holeMode = !1, this
                        }
                        destroy(e) {
                            this._geometry.refCount--, 0 === this._geometry.refCount && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, super.destroy(e)
                        }
                    };
                let f = p;
                f.curves = n.curves, f._TEMP_POINT = new i.Point, t.Graphics = f
            },
            750: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                class r {
                    constructor(e, t = null, r = null, i = null) {
                        this.points = [], this.holes = [], this.shape = e, this.lineStyle = r, this.fillStyle = t, this.matrix = i, this.type = e.type
                    }
                    clone() {
                        return new r(this.shape, this.fillStyle, this.lineStyle, this.matrix)
                    }
                    destroy() {
                        this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null
                    }
                }
                t.GraphicsData = r
            },
            8977: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(2781),
                    n = r(750),
                    o = r(9356),
                    a = r(9446),
                    h = r(7197),
                    l = r(357);
                const u = new i.Point,
                    c = class extends i.BatchGeometry {
                        constructor() {
                            super(), this.closePointEps = 1e-4, this.boundsPadding = 0, this.uvsFloat32 = null, this.indicesUint16 = null, this.batchable = !1, this.points = [], this.colors = [], this.uvs = [], this.indices = [], this.textureIds = [], this.graphicsData = [], this.drawCalls = [], this.batchDirty = -1, this.batches = [], this.dirty = 0, this.cacheDirty = -1, this.clearDirty = 0, this.shapeIndex = 0, this._bounds = new s.Bounds, this.boundsDirty = -1
                        }
                        get bounds() {
                            return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds
                        }
                        invalidate() {
                            this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
                            for (let e = 0; e < this.drawCalls.length; e++) this.drawCalls[e].texArray.clear(), o.DRAW_CALL_POOL.push(this.drawCalls[e]);
                            this.drawCalls.length = 0;
                            for (let e = 0; e < this.batches.length; e++) {
                                const t = this.batches[e];
                                t.reset(), o.BATCH_POOL.push(t)
                            }
                            this.batches.length = 0
                        }
                        clear() {
                            return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this
                        }
                        drawShape(e, t = null, r = null, i = null) {
                            const s = new n.GraphicsData(e, t, r, i);
                            return this.graphicsData.push(s), this.dirty++, this
                        }
                        drawHole(e, t = null) {
                            if (!this.graphicsData.length) return null;
                            const r = new n.GraphicsData(e, null, null, t),
                                i = this.graphicsData[this.graphicsData.length - 1];
                            return r.lineStyle = i.lineStyle, i.holes.push(r), this.dirty++, this
                        }
                        destroy() {
                            super.destroy();
                            for (let e = 0; e < this.graphicsData.length; ++e) this.graphicsData[e].destroy();
                            this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null
                        }
                        containsPoint(e) {
                            const t = this.graphicsData;
                            for (let r = 0; r < t.length; ++r) {
                                const i = t[r];
                                if (i.fillStyle.visible && i.shape && (i.matrix ? i.matrix.applyInverse(e, u) : u.copyFrom(e), i.shape.contains(u.x, u.y))) {
                                    let e = !1;
                                    if (i.holes)
                                        for (let t = 0; t < i.holes.length; t++)
                                            if (i.holes[t].shape.contains(u.x, u.y)) {
                                                e = !0;
                                                break
                                            } if (!e) return !0
                                }
                            }
                            return !1
                        }
                        updateBatches() {
                            if (!this.graphicsData.length) return void(this.batchable = !0);
                            if (!this.validateBatching()) return;
                            this.cacheDirty = this.dirty;
                            const e = this.uvs,
                                t = this.graphicsData;
                            let r = null,
                                s = null;
                            this.batches.length > 0 && (r = this.batches[this.batches.length - 1], s = r.style);
                            for (let n = this.shapeIndex; n < t.length; n++) {
                                this.shapeIndex++;
                                const h = t[n],
                                    l = h.fillStyle,
                                    u = h.lineStyle;
                                o.FILL_COMMANDS[h.type].build(h), h.matrix && this.transformPoints(h.points, h.matrix), (l.visible || u.visible) && this.processHoles(h.holes);
                                for (let t = 0; t < 2; t++) {
                                    const n = 0 === t ? l : u;
                                    if (!n.visible) continue;
                                    const c = n.texture.baseTexture,
                                        d = this.indices.length,
                                        p = this.points.length / 2;
                                    c.wrapMode = i.WRAP_MODES.REPEAT, 0 === t ? this.processFill(h) : this.processLine(h);
                                    const f = this.points.length / 2 - p;
                                    0 !== f && (r && !this._compareStyles(s, n) && (r.end(d, p), r = null), r || (r = o.BATCH_POOL.pop() || new a.BatchPart, r.begin(n, d, p), this.batches.push(r), s = n), this.addUvs(this.points, e, n.texture, p, f, n.matrix))
                                }
                            }
                            const n = this.indices.length,
                                h = this.points.length / 2;
                            if (r && r.end(n, h), 0 === this.batches.length) return void(this.batchable = !0);
                            const l = h > 65535;
                            this.indicesUint16 && this.indices.length === this.indicesUint16.length && l === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = l ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls()
                        }
                        _compareStyles(e, t) {
                            return !(!e || !t) && e.texture.baseTexture === t.texture.baseTexture && e.color + e.alpha === t.color + t.alpha && !!e.native == !!t.native
                        }
                        validateBatching() {
                            if (this.dirty === this.cacheDirty || !this.graphicsData.length) return !1;
                            for (let e = 0, t = this.graphicsData.length; e < t; e++) {
                                const t = this.graphicsData[e],
                                    r = t.fillStyle,
                                    i = t.lineStyle;
                                if (r && !r.texture.baseTexture.valid) return !1;
                                if (i && !i.texture.baseTexture.valid) return !1
                            }
                            return !0
                        }
                        packBatches() {
                            this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
                            const e = this.batches;
                            for (let t = 0, r = e.length; t < r; t++) {
                                const r = e[t];
                                for (let e = 0; e < r.size; e++) {
                                    const t = r.start + e;
                                    this.indicesUint16[t] = this.indicesUint16[t] - r.attribStart
                                }
                            }
                        }
                        isBatchable() {
                            if (this.points.length > 131070) return !1;
                            const e = this.batches;
                            for (let t = 0; t < e.length; t++)
                                if (e[t].style.native) return !1;
                            return this.points.length < 2 * c.BATCHABLE_SIZE
                        }
                        buildDrawCalls() {
                            let e = ++i.BaseTexture._globalBatch;
                            for (let e = 0; e < this.drawCalls.length; e++) this.drawCalls[e].texArray.clear(), o.DRAW_CALL_POOL.push(this.drawCalls[e]);
                            this.drawCalls.length = 0;
                            const t = this.colors,
                                r = this.textureIds;
                            let s = o.DRAW_CALL_POOL.pop();
                            s || (s = new i.BatchDrawCall, s.texArray = new i.BatchTextureArray), s.texArray.count = 0, s.start = 0, s.size = 0, s.type = i.DRAW_MODES.TRIANGLES;
                            let n = 0,
                                a = null,
                                h = 0,
                                l = !1,
                                u = i.DRAW_MODES.TRIANGLES,
                                c = 0;
                            this.drawCalls.push(s);
                            for (let d = 0; d < this.batches.length; d++) {
                                const p = this.batches[d],
                                    f = 8,
                                    m = p.style,
                                    g = m.texture.baseTexture;
                                l !== !!m.native && (l = !!m.native, u = l ? i.DRAW_MODES.LINES : i.DRAW_MODES.TRIANGLES, a = null, n = f, e++), a !== g && (a = g, g._batchEnabled !== e && (n === f && (e++, n = 0, s.size > 0 && (s = o.DRAW_CALL_POOL.pop(), s || (s = new i.BatchDrawCall, s.texArray = new i.BatchTextureArray), this.drawCalls.push(s)), s.start = c, s.size = 0, s.texArray.count = 0, s.type = u), g.touched = 1, g._batchEnabled = e, g._batchLocation = n, g.wrapMode = i.WRAP_MODES.REPEAT, s.texArray.elements[s.texArray.count++] = g, n++)), s.size += p.size, c += p.size, h = g._batchLocation, this.addColors(t, m.color, m.alpha, p.attribSize, p.attribStart), this.addTextureIds(r, h, p.attribSize, p.attribStart)
                            }
                            i.BaseTexture._globalBatch = e, this.packAttributes()
                        }
                        packAttributes() {
                            const e = this.points,
                                t = this.uvs,
                                r = this.colors,
                                i = this.textureIds,
                                s = new ArrayBuffer(3 * e.length * 4),
                                n = new Float32Array(s),
                                o = new Uint32Array(s);
                            let a = 0;
                            for (let s = 0; s < e.length / 2; s++) n[a++] = e[2 * s], n[a++] = e[2 * s + 1], n[a++] = t[2 * s], n[a++] = t[2 * s + 1], o[a++] = r[s], n[a++] = i[s];
                            this._buffer.update(s), this._indexBuffer.update(this.indicesUint16)
                        }
                        processFill(e) {
                            e.holes.length ? h.buildPoly.triangulate(e, this) : o.FILL_COMMANDS[e.type].triangulate(e, this)
                        }
                        processLine(e) {
                            l.buildLine(e, this);
                            for (let t = 0; t < e.holes.length; t++) l.buildLine(e.holes[t], this)
                        }
                        processHoles(e) {
                            for (let t = 0; t < e.length; t++) {
                                const r = e[t];
                                o.FILL_COMMANDS[r.type].build(r), r.matrix && this.transformPoints(r.points, r.matrix)
                            }
                        }
                        calculateBounds() {
                            const e = this._bounds;
                            e.clear(), e.addVertexData(this.points, 0, this.points.length), e.pad(this.boundsPadding, this.boundsPadding)
                        }
                        transformPoints(e, t) {
                            for (let r = 0; r < e.length / 2; r++) {
                                const i = e[2 * r],
                                    s = e[2 * r + 1];
                                e[2 * r] = t.a * i + t.c * s + t.tx, e[2 * r + 1] = t.b * i + t.d * s + t.ty
                            }
                        }
                        addColors(e, t, r, s, n = 0) {
                            const o = i.Color.shared.setValue(t).toLittleEndianNumber(),
                                a = i.Color.shared.setValue(o).toPremultiplied(r);
                            e.length = Math.max(e.length, n + s);
                            for (let t = 0; t < s; t++) e[n + t] = a
                        }
                        addTextureIds(e, t, r, i = 0) {
                            e.length = Math.max(e.length, i + r);
                            for (let s = 0; s < r; s++) e[i + s] = t
                        }
                        addUvs(e, t, r, i, s, n = null) {
                            let o = 0;
                            const a = t.length,
                                h = r.frame;
                            for (; o < s;) {
                                let r = e[2 * (i + o)],
                                    s = e[2 * (i + o) + 1];
                                if (n) {
                                    const e = n.a * r + n.c * s + n.tx;
                                    s = n.b * r + n.d * s + n.ty, r = e
                                }
                                o++, t.push(r / h.width, s / h.height)
                            }
                            const l = r.baseTexture;
                            (h.width < l.width || h.height < l.height) && this.adjustUvs(t, r, a, s)
                        }
                        adjustUvs(e, t, r, i) {
                            const s = t.baseTexture,
                                n = 1e-6,
                                o = r + 2 * i,
                                a = t.frame,
                                h = a.width / s.width,
                                l = a.height / s.height;
                            let u = a.x / a.width,
                                c = a.y / a.height,
                                d = Math.floor(e[r] + n),
                                p = Math.floor(e[r + 1] + n);
                            for (let t = r + 2; t < o; t += 2) d = Math.min(d, Math.floor(e[t] + n)), p = Math.min(p, Math.floor(e[t + 1] + n));
                            u -= d, c -= p;
                            for (let t = r; t < o; t += 2) e[t] = (e[t] + u) * h, e[t + 1] = (e[t + 1] + c) * l
                        }
                    };
                let d = c;
                d.BATCHABLE_SIZE = 100, t.GraphicsGeometry = d
            },
            5530: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = (e => (e.MITER = "miter", e.BEVEL = "bevel", e.ROUND = "round", e))(r || {}),
                    i = (e => (e.BUTT = "butt", e.ROUND = "round", e.SQUARE = "square", e))(i || {});
                const s = {
                        adaptive: !0,
                        maxLength: 10,
                        minSegments: 8,
                        maxSegments: 2048,
                        epsilon: 1e-4,
                        _segmentsCount(e, t = 20) {
                            if (!this.adaptive || !e || isNaN(e)) return t;
                            let r = Math.ceil(e / this.maxLength);
                            return r < this.minSegments ? r = this.minSegments : r > this.maxSegments && (r = this.maxSegments), r
                        }
                    },
                    n = s;
                t.GRAPHICS_CURVES = n, t.LINE_CAP = i, t.LINE_JOIN = r, t.curves = s
            },
            4742: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(9356),
                    s = r(5530),
                    n = r(3453),
                    o = r(750),
                    a = r(8977),
                    h = r(3440),
                    l = r(5285),
                    u = r(7197),
                    c = r(6423),
                    d = r(3877),
                    p = r(1098),
                    f = r(357),
                    m = r(9883),
                    g = r(165),
                    y = r(9794),
                    _ = r(9446);
                const v = {
                    buildPoly: u.buildPoly,
                    buildCircle: c.buildCircle,
                    buildRectangle: d.buildRectangle,
                    buildRoundedRectangle: p.buildRoundedRectangle,
                    buildLine: f.buildLine,
                    ArcUtils: m.ArcUtils,
                    BezierUtils: g.BezierUtils,
                    QuadraticUtils: y.QuadraticUtils,
                    BatchPart: _.BatchPart,
                    FILL_COMMANDS: i.FILL_COMMANDS,
                    BATCH_POOL: i.BATCH_POOL,
                    DRAW_CALL_POOL: i.DRAW_CALL_POOL
                };
                t.GRAPHICS_CURVES = s.GRAPHICS_CURVES, t.LINE_CAP = s.LINE_CAP, t.LINE_JOIN = s.LINE_JOIN, t.curves = s.curves, t.Graphics = n.Graphics, t.GraphicsData = o.GraphicsData, t.GraphicsGeometry = a.GraphicsGeometry, t.FillStyle = h.FillStyle, t.LineStyle = l.LineStyle, t.graphicsUtils = v
            },
            3440: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                class s {
                    constructor() {
                        this.color = 16777215, this.alpha = 1, this.texture = i.Texture.WHITE, this.matrix = null, this.visible = !1, this.reset()
                    }
                    clone() {
                        const e = new s;
                        return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e
                    }
                    reset() {
                        this.color = 16777215, this.alpha = 1, this.texture = i.Texture.WHITE, this.matrix = null, this.visible = !1
                    }
                    destroy() {
                        this.texture = null, this.matrix = null
                    }
                }
                t.FillStyle = s
            },
            5285: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(5530),
                    s = r(3440);
                class n extends s.FillStyle {
                    constructor() {
                        super(...arguments), this.width = 0, this.alignment = .5, this.native = !1, this.cap = i.LINE_CAP.BUTT, this.join = i.LINE_JOIN.MITER, this.miterLimit = 10
                    }
                    clone() {
                        const e = new n;
                        return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e.width = this.width, e.alignment = this.alignment, e.native = this.native, e.cap = this.cap, e.join = this.join, e.miterLimit = this.miterLimit, e
                    }
                    reset() {
                        super.reset(), this.color = 0, this.alignment = .5, this.width = 0, this.native = !1
                    }
                }
                t.LineStyle = n
            },
            9883: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(5530);
                t.ArcUtils = class {
                    static curveTo(e, t, r, i, s, n) {
                        const o = n[n.length - 2],
                            a = n[n.length - 1] - t,
                            h = o - e,
                            l = i - t,
                            u = r - e,
                            c = Math.abs(a * u - h * l);
                        if (c < 1e-8 || 0 === s) return n[n.length - 2] === e && n[n.length - 1] === t || n.push(e, t), null;
                        const d = a * a + h * h,
                            p = l * l + u * u,
                            f = a * l + h * u,
                            m = s * Math.sqrt(d) / c,
                            g = s * Math.sqrt(p) / c,
                            y = m * f / d,
                            _ = g * f / p,
                            v = m * u + g * h,
                            S = m * l + g * a,
                            T = h * (g + y),
                            b = a * (g + y),
                            E = u * (m + _),
                            x = l * (m + _);
                        return {
                            cx: v + e,
                            cy: S + t,
                            radius: s,
                            startAngle: Math.atan2(b - S, T - v),
                            endAngle: Math.atan2(x - S, E - v),
                            anticlockwise: h * l > u * a
                        }
                    }
                    static arc(e, t, r, n, o, a, h, l, u) {
                        const c = h - a,
                            d = s.curves._segmentsCount(Math.abs(c) * o, 40 * Math.ceil(Math.abs(c) / i.PI_2)),
                            p = c / (2 * d),
                            f = 2 * p,
                            m = Math.cos(p),
                            g = Math.sin(p),
                            y = d - 1,
                            _ = y % 1 / y;
                        for (let e = 0; e <= y; ++e) {
                            const t = p + a + f * (e + _ * e),
                                i = Math.cos(t),
                                s = -Math.sin(t);
                            u.push((m * i + g * s) * o + r, (m * -s + g * i) * o + n)
                        }
                    }
                }
            },
            9446: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.BatchPart = class {
                    constructor() {
                        this.reset()
                    }
                    begin(e, t, r) {
                        this.reset(), this.style = e, this.start = t, this.attribStart = r
                    }
                    end(e, t) {
                        this.attribSize = t - this.attribStart, this.size = e - this.start
                    }
                    reset() {
                        this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0
                    }
                }
            },
            165: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(5530);
                class s {
                    static curveLength(e, t, r, i, s, n, o, a) {
                        let h = 0,
                            l = 0,
                            u = 0,
                            c = 0,
                            d = 0,
                            p = 0,
                            f = 0,
                            m = 0,
                            g = 0,
                            y = 0,
                            _ = 0,
                            v = e,
                            S = t;
                        for (let T = 1; T <= 10; ++T) l = T / 10, u = l * l, c = u * l, d = 1 - l, p = d * d, f = p * d, m = f * e + 3 * p * l * r + 3 * d * u * s + c * o, g = f * t + 3 * p * l * i + 3 * d * u * n + c * a, y = v - m, _ = S - g, v = m, S = g, h += Math.sqrt(y * y + _ * _);
                        return h
                    }
                    static curveTo(e, t, r, n, o, a, h) {
                        const l = h[h.length - 2],
                            u = h[h.length - 1];
                        h.length -= 2;
                        const c = i.curves._segmentsCount(s.curveLength(l, u, e, t, r, n, o, a));
                        let d = 0,
                            p = 0,
                            f = 0,
                            m = 0,
                            g = 0;
                        h.push(l, u);
                        for (let i = 1, s = 0; i <= c; ++i) s = i / c, d = 1 - s, p = d * d, f = p * d, m = s * s, g = m * s, h.push(f * l + 3 * p * s * e + 3 * d * m * r + g * o, f * u + 3 * p * s * t + 3 * d * m * n + g * a)
                    }
                }
                t.BezierUtils = s
            },
            9794: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(5530);
                class s {
                    static curveLength(e, t, r, i, s, n) {
                        const o = e - 2 * r + s,
                            a = t - 2 * i + n,
                            h = 2 * r - 2 * e,
                            l = 2 * i - 2 * t,
                            u = 4 * (o * o + a * a),
                            c = 4 * (o * h + a * l),
                            d = h * h + l * l,
                            p = 2 * Math.sqrt(u + c + d),
                            f = Math.sqrt(u),
                            m = 2 * u * f,
                            g = 2 * Math.sqrt(d),
                            y = c / f;
                        return (m * p + f * c * (p - g) + (4 * d * u - c * c) * Math.log((2 * f + y + p) / (y + g))) / (4 * m)
                    }
                    static curveTo(e, t, r, n, o) {
                        const a = o[o.length - 2],
                            h = o[o.length - 1],
                            l = i.curves._segmentsCount(s.curveLength(a, h, e, t, r, n));
                        let u = 0,
                            c = 0;
                        for (let i = 1; i <= l; ++i) {
                            const s = i / l;
                            u = a + (e - a) * s, c = h + (t - h) * s, o.push(u + (e + (r - e) * s - u) * s, c + (t + (n - t) * s - c) * s)
                        }
                    }
                }
                t.QuadraticUtils = s
            },
            6423: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                const s = {
                    build(e) {
                        const t = e.points;
                        let r, s, n, o, a, h;
                        if (e.type === i.SHAPES.CIRC) {
                            const t = e.shape;
                            r = t.x, s = t.y, a = h = t.radius, n = o = 0
                        } else if (e.type === i.SHAPES.ELIP) {
                            const t = e.shape;
                            r = t.x, s = t.y, a = t.width, h = t.height, n = o = 0
                        } else {
                            const t = e.shape,
                                i = t.width / 2,
                                l = t.height / 2;
                            r = t.x + i, s = t.y + l, a = h = Math.max(0, Math.min(t.radius, Math.min(i, l))), n = i - a, o = l - h
                        }
                        if (!(a >= 0 && h >= 0 && n >= 0 && o >= 0)) return void(t.length = 0);
                        const l = Math.ceil(2.3 * Math.sqrt(a + h)),
                            u = 8 * l + (n ? 4 : 0) + (o ? 4 : 0);
                        if (t.length = u, 0 === u) return;
                        if (0 === l) return t.length = 8, t[0] = t[6] = r + n, t[1] = t[3] = s + o, t[2] = t[4] = r - n, void(t[5] = t[7] = s - o);
                        let c = 0,
                            d = 4 * l + (n ? 2 : 0) + 2,
                            p = d,
                            f = u;
                        {
                            const e = n + a,
                                i = o,
                                h = r + e,
                                l = r - e,
                                u = s + i;
                            if (t[c++] = h, t[c++] = u, t[--d] = u, t[--d] = l, o) {
                                const e = s - i;
                                t[p++] = l, t[p++] = e, t[--f] = e, t[--f] = h
                            }
                        }
                        for (let e = 1; e < l; e++) {
                            const i = Math.PI / 2 * (e / l),
                                u = n + Math.cos(i) * a,
                                m = o + Math.sin(i) * h,
                                g = r + u,
                                y = r - u,
                                _ = s + m,
                                v = s - m;
                            t[c++] = g, t[c++] = _, t[--d] = _, t[--d] = y, t[p++] = y, t[p++] = v, t[--f] = v, t[--f] = g
                        } {
                            const e = o + h,
                                i = r + n,
                                a = r - n,
                                l = s + e,
                                u = s - e;
                            t[c++] = i, t[c++] = l, t[--f] = u, t[--f] = i, n && (t[c++] = a, t[c++] = l, t[--f] = u, t[--f] = a)
                        }
                    },
                    triangulate(e, t) {
                        const r = e.points,
                            s = t.points,
                            n = t.indices;
                        if (0 === r.length) return;
                        let o = s.length / 2;
                        const a = o;
                        let h, l;
                        if (e.type !== i.SHAPES.RREC) {
                            const t = e.shape;
                            h = t.x, l = t.y
                        } else {
                            const t = e.shape;
                            h = t.x + t.width / 2, l = t.y + t.height / 2
                        }
                        const u = e.matrix;
                        s.push(e.matrix ? u.a * h + u.c * l + u.tx : h, e.matrix ? u.b * h + u.d * l + u.ty : l), o++, s.push(r[0], r[1]);
                        for (let e = 2; e < r.length; e += 2) s.push(r[e], r[e + 1]), n.push(o++, a, o);
                        n.push(a + 1, a, o)
                    }
                };
                t.buildCircle = s
            },
            357: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(5530);

                function n(e, t, r, i, s, n, o, a) {
                    let h, l;
                    o ? (h = i, l = -r) : (h = -i, l = r);
                    const u = e - r * s + h,
                        c = t - i * s + l,
                        d = e + r * n + h,
                        p = t + i * n + l;
                    return a.push(u, c, d, p), 2
                }

                function o(e, t, r, i, s, n, o, a) {
                    const h = r - e,
                        l = i - t;
                    let u = Math.atan2(h, l),
                        c = Math.atan2(s - e, n - t);
                    a && u < c ? u += 2 * Math.PI : !a && u > c && (c += 2 * Math.PI);
                    let d = u;
                    const p = c - u,
                        f = Math.abs(p),
                        m = Math.sqrt(h * h + l * l),
                        g = 1 + (15 * f * Math.sqrt(m) / Math.PI >> 0),
                        y = p / g;
                    if (d += y, a) {
                        o.push(e, t, r, i);
                        for (let r = 1, i = d; r < g; r++, i += y) o.push(e, t, e + Math.sin(i) * m, t + Math.cos(i) * m);
                        o.push(e, t, s, n)
                    } else {
                        o.push(r, i, e, t);
                        for (let r = 1, i = d; r < g; r++, i += y) o.push(e + Math.sin(i) * m, t + Math.cos(i) * m, e, t);
                        o.push(s, n, e, t)
                    }
                    return 2 * g
                }
                t.buildLine = function(e, t) {
                    e.lineStyle.native ? function(e, t) {
                        let r = 0;
                        const s = e.shape,
                            n = e.points || s.points,
                            o = s.type !== i.SHAPES.POLY || s.closeStroke;
                        if (0 === n.length) return;
                        const a = t.points,
                            h = t.indices,
                            l = n.length / 2,
                            u = a.length / 2;
                        let c = u;
                        for (a.push(n[0], n[1]), r = 1; r < l; r++) a.push(n[2 * r], n[2 * r + 1]), h.push(c, c + 1), c++;
                        o && h.push(c, u)
                    }(e, t) : function(e, t) {
                        const r = e.shape;
                        let a = e.points || r.points.slice();
                        const h = t.closePointEps;
                        if (0 === a.length) return;
                        const l = e.lineStyle,
                            u = new i.Point(a[0], a[1]),
                            c = new i.Point(a[a.length - 2], a[a.length - 1]),
                            d = r.type !== i.SHAPES.POLY || r.closeStroke,
                            p = Math.abs(u.x - c.x) < h && Math.abs(u.y - c.y) < h;
                        if (d) {
                            a = a.slice(), p && (a.pop(), a.pop(), c.set(a[a.length - 2], a[a.length - 1]));
                            const e = .5 * (u.x + c.x),
                                t = .5 * (c.y + u.y);
                            a.unshift(e, t), a.push(e, t)
                        }
                        const f = t.points,
                            m = a.length / 2;
                        let g = a.length;
                        const y = f.length / 2,
                            _ = l.width / 2,
                            v = _ * _,
                            S = l.miterLimit * l.miterLimit;
                        let T = a[0],
                            b = a[1],
                            E = a[2],
                            x = a[3],
                            w = 0,
                            O = 0,
                            A = -(b - x),
                            P = T - E,
                            M = 0,
                            C = 0,
                            R = Math.sqrt(A * A + P * P);
                        A /= R, P /= R, A *= _, P *= _;
                        const I = l.alignment,
                            B = 2 * (1 - I),
                            D = 2 * I;
                        d || (l.cap === s.LINE_CAP.ROUND ? g += o(T - A * (B - D) * .5, b - P * (B - D) * .5, T - A * B, b - P * B, T + A * D, b + P * D, f, !0) + 2 : l.cap === s.LINE_CAP.SQUARE && (g += n(T, b, A, P, B, D, !0, f))), f.push(T - A * B, b - P * B, T + A * D, b + P * D);
                        for (let e = 1; e < m - 1; ++e) {
                            T = a[2 * (e - 1)], b = a[2 * (e - 1) + 1], E = a[2 * e], x = a[2 * e + 1], w = a[2 * (e + 1)], O = a[2 * (e + 1) + 1], A = -(b - x), P = T - E, R = Math.sqrt(A * A + P * P), A /= R, P /= R, A *= _, P *= _, M = -(x - O), C = E - w, R = Math.sqrt(M * M + C * C), M /= R, C /= R, M *= _, C *= _;
                            const t = E - T,
                                r = b - x,
                                i = E - w,
                                n = O - x,
                                h = t * i + r * n,
                                u = r * i - n * t,
                                c = u < 0;
                            if (Math.abs(u) < .001 * Math.abs(h)) {
                                f.push(E - A * B, x - P * B, E + A * D, x + P * D), h >= 0 && (l.join === s.LINE_JOIN.ROUND ? g += o(E, x, E - A * B, x - P * B, E - M * B, x - C * B, f, !1) + 4 : g += 2, f.push(E - M * D, x - C * D, E + M * B, x + C * B));
                                continue
                            }
                            const d = (-A + T) * (-P + x) - (-A + E) * (-P + b),
                                p = (-M + w) * (-C + x) - (-M + E) * (-C + O),
                                m = (t * p - i * d) / u,
                                y = (n * d - r * p) / u,
                                I = (m - E) * (m - E) + (y - x) * (y - x),
                                H = E + (m - E) * B,
                                k = x + (y - x) * B,
                                F = E - (m - E) * D,
                                N = x - (y - x) * D,
                                L = c ? B : D,
                                j = I <= Math.min(t * t + r * r, i * i + n * n) + L * L * v;
                            let U = l.join;
                            if (U === s.LINE_JOIN.MITER && I / v > S && (U = s.LINE_JOIN.BEVEL), j) switch (U) {
                                case s.LINE_JOIN.MITER:
                                    f.push(H, k, F, N);
                                    break;
                                case s.LINE_JOIN.BEVEL:
                                    c ? f.push(H, k, E + A * D, x + P * D, H, k, E + M * D, x + C * D) : f.push(E - A * B, x - P * B, F, N, E - M * B, x - C * B, F, N), g += 2;
                                    break;
                                case s.LINE_JOIN.ROUND:
                                    c ? (f.push(H, k, E + A * D, x + P * D), g += o(E, x, E + A * D, x + P * D, E + M * D, x + C * D, f, !0) + 4, f.push(H, k, E + M * D, x + C * D)) : (f.push(E - A * B, x - P * B, F, N), g += o(E, x, E - A * B, x - P * B, E - M * B, x - C * B, f, !1) + 4, f.push(E - M * B, x - C * B, F, N))
                            } else {
                                switch (f.push(E - A * B, x - P * B, E + A * D, x + P * D), U) {
                                    case s.LINE_JOIN.MITER:
                                        c ? f.push(F, N, F, N) : f.push(H, k, H, k), g += 2;
                                        break;
                                    case s.LINE_JOIN.ROUND:
                                        g += c ? o(E, x, E + A * D, x + P * D, E + M * D, x + C * D, f, !0) + 2 : o(E, x, E - A * B, x - P * B, E - M * B, x - C * B, f, !1) + 2
                                }
                                f.push(E - M * B, x - C * B, E + M * D, x + C * D), g += 2
                            }
                        }
                        T = a[2 * (m - 2)], b = a[2 * (m - 2) + 1], E = a[2 * (m - 1)], x = a[2 * (m - 1) + 1], A = -(b - x), P = T - E, R = Math.sqrt(A * A + P * P), A /= R, P /= R, A *= _, P *= _, f.push(E - A * B, x - P * B, E + A * D, x + P * D), d || (l.cap === s.LINE_CAP.ROUND ? g += o(E - A * (B - D) * .5, x - P * (B - D) * .5, E - A * B, x - P * B, E + A * D, x + P * D, f, !1) + 2 : l.cap === s.LINE_CAP.SQUARE && (g += n(E, x, A, P, B, D, !1, f)));
                        const H = t.indices,
                            k = s.curves.epsilon * s.curves.epsilon;
                        for (let e = y; e < g + y - 2; ++e) T = f[2 * e], b = f[2 * e + 1], E = f[2 * (e + 1)], x = f[2 * (e + 1) + 1], w = f[2 * (e + 2)], O = f[2 * (e + 2) + 1], Math.abs(T * (x - O) + E * (O - b) + w * (b - x)) < k || H.push(e, e + 1, e + 2)
                    }(e, t)
                }
            },
            7197: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);

                function s(e, t = !1) {
                    const r = e.length;
                    if (r < 6) return;
                    let i = 0;
                    for (let t = 0, s = e[r - 2], n = e[r - 1]; t < r; t += 2) {
                        const r = e[t],
                            o = e[t + 1];
                        i += (r - s) * (o + n), s = r, n = o
                    }
                    if (!t && i > 0 || t && i <= 0) {
                        const t = r / 2;
                        for (let i = t + t % 2; i < r; i += 2) {
                            const t = r - i - 2,
                                s = r - i - 1,
                                n = i,
                                o = i + 1;
                            [e[t], e[n]] = [e[n], e[t]], [e[s], e[o]] = [e[o], e[s]]
                        }
                    }
                }
                const n = {
                    build(e) {
                        e.points = e.shape.points.slice()
                    },
                    triangulate(e, t) {
                        let r = e.points;
                        const n = e.holes,
                            o = t.points,
                            a = t.indices;
                        if (r.length >= 6) {
                            s(r, !1);
                            const e = [];
                            for (let t = 0; t < n.length; t++) {
                                const i = n[t];
                                s(i.points, !0), e.push(r.length / 2), r = r.concat(i.points)
                            }
                            const t = i.utils.earcut(r, e, 2);
                            if (!t) return;
                            const h = o.length / 2;
                            for (let e = 0; e < t.length; e += 3) a.push(t[e] + h), a.push(t[e + 1] + h), a.push(t[e + 2] + h);
                            for (let e = 0; e < r.length; e++) o.push(r[e])
                        }
                    }
                };
                t.buildPoly = n
            },
            3877: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const r = {
                    build(e) {
                        const t = e.shape,
                            r = t.x,
                            i = t.y,
                            s = t.width,
                            n = t.height,
                            o = e.points;
                        o.length = 0, s >= 0 && n >= 0 && o.push(r, i, r + s, i, r + s, i + n, r, i + n)
                    },
                    triangulate(e, t) {
                        const r = e.points,
                            i = t.points;
                        if (0 === r.length) return;
                        const s = i.length / 2;
                        i.push(r[0], r[1], r[2], r[3], r[6], r[7], r[4], r[5]), t.indices.push(s, s + 1, s + 2, s + 1, s + 2, s + 3)
                    }
                };
                t.buildRectangle = r
            },
            1098: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(6423);
                const s = {
                    build(e) {
                        i.buildCircle.build(e)
                    },
                    triangulate(e, t) {
                        i.buildCircle.triangulate(e, t)
                    }
                };
                t.buildRoundedRectangle = s
            },
            9356: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(6423),
                    n = r(7197),
                    o = r(3877),
                    a = r(1098),
                    h = r(9883),
                    l = r(9446),
                    u = r(165),
                    c = r(357),
                    d = r(9794);
                const p = {
                    [i.SHAPES.POLY]: n.buildPoly,
                    [i.SHAPES.CIRC]: s.buildCircle,
                    [i.SHAPES.ELIP]: s.buildCircle,
                    [i.SHAPES.RECT]: o.buildRectangle,
                    [i.SHAPES.RREC]: a.buildRoundedRectangle
                };
                t.buildCircle = s.buildCircle, t.buildPoly = n.buildPoly, t.buildRectangle = o.buildRectangle, t.buildRoundedRectangle = a.buildRoundedRectangle, t.ArcUtils = h.ArcUtils, t.BatchPart = l.BatchPart, t.BezierUtils = u.BezierUtils, t.buildLine = c.buildLine, t.QuadraticUtils = d.QuadraticUtils, t.BATCH_POOL = [], t.DRAW_CALL_POOL = [], t.FILL_COMMANDS = p
            },
            1261: () => {},
            9799: () => {},
            2863: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2849),
                    s = r(9970);
                class n {
                    constructor(e = 1, t = 0, r = 0, i = 1, s = 0, n = 0) {
                        this.array = null, this.a = e, this.b = t, this.c = r, this.d = i, this.tx = s, this.ty = n
                    }
                    fromArray(e) {
                        this.a = e[0], this.b = e[1], this.c = e[3], this.d = e[4], this.tx = e[2], this.ty = e[5]
                    }
                    set(e, t, r, i, s, n) {
                        return this.a = e, this.b = t, this.c = r, this.d = i, this.tx = s, this.ty = n, this
                    }
                    toArray(e, t) {
                        this.array || (this.array = new Float32Array(9));
                        const r = t || this.array;
                        return e ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r
                    }
                    apply(e, t) {
                        t = t || new s.Point;
                        const r = e.x,
                            i = e.y;
                        return t.x = this.a * r + this.c * i + this.tx, t.y = this.b * r + this.d * i + this.ty, t
                    }
                    applyInverse(e, t) {
                        t = t || new s.Point;
                        const r = 1 / (this.a * this.d + this.c * -this.b),
                            i = e.x,
                            n = e.y;
                        return t.x = this.d * r * i + -this.c * r * n + (this.ty * this.c - this.tx * this.d) * r, t.y = this.a * r * n + -this.b * r * i + (-this.ty * this.a + this.tx * this.b) * r, t
                    }
                    translate(e, t) {
                        return this.tx += e, this.ty += t, this
                    }
                    scale(e, t) {
                        return this.a *= e, this.d *= t, this.c *= e, this.b *= t, this.tx *= e, this.ty *= t, this
                    }
                    rotate(e) {
                        const t = Math.cos(e),
                            r = Math.sin(e),
                            i = this.a,
                            s = this.c,
                            n = this.tx;
                        return this.a = i * t - this.b * r, this.b = i * r + this.b * t, this.c = s * t - this.d * r, this.d = s * r + this.d * t, this.tx = n * t - this.ty * r, this.ty = n * r + this.ty * t, this
                    }
                    append(e) {
                        const t = this.a,
                            r = this.b,
                            i = this.c,
                            s = this.d;
                        return this.a = e.a * t + e.b * i, this.b = e.a * r + e.b * s, this.c = e.c * t + e.d * i, this.d = e.c * r + e.d * s, this.tx = e.tx * t + e.ty * i + this.tx, this.ty = e.tx * r + e.ty * s + this.ty, this
                    }
                    setTransform(e, t, r, i, s, n, o, a, h) {
                        return this.a = Math.cos(o + h) * s, this.b = Math.sin(o + h) * s, this.c = -Math.sin(o - a) * n, this.d = Math.cos(o - a) * n, this.tx = e - (r * this.a + i * this.c), this.ty = t - (r * this.b + i * this.d), this
                    }
                    prepend(e) {
                        const t = this.tx;
                        if (1 !== e.a || 0 !== e.b || 0 !== e.c || 1 !== e.d) {
                            const t = this.a,
                                r = this.c;
                            this.a = t * e.a + this.b * e.c, this.b = t * e.b + this.b * e.d, this.c = r * e.a + this.d * e.c, this.d = r * e.b + this.d * e.d
                        }
                        return this.tx = t * e.a + this.ty * e.c + e.tx, this.ty = t * e.b + this.ty * e.d + e.ty, this
                    }
                    decompose(e) {
                        const t = this.a,
                            r = this.b,
                            s = this.c,
                            n = this.d,
                            o = e.pivot,
                            a = -Math.atan2(-s, n),
                            h = Math.atan2(r, t),
                            l = Math.abs(a + h);
                        return l < 1e-5 || Math.abs(i.PI_2 - l) < 1e-5 ? (e.rotation = h, e.skew.x = e.skew.y = 0) : (e.rotation = 0, e.skew.x = a, e.skew.y = h), e.scale.x = Math.sqrt(t * t + r * r), e.scale.y = Math.sqrt(s * s + n * n), e.position.x = this.tx + (o.x * t + o.y * s), e.position.y = this.ty + (o.x * r + o.y * n), e
                    }
                    invert() {
                        const e = this.a,
                            t = this.b,
                            r = this.c,
                            i = this.d,
                            s = this.tx,
                            n = e * i - t * r;
                        return this.a = i / n, this.b = -t / n, this.c = -r / n, this.d = e / n, this.tx = (r * this.ty - i * s) / n, this.ty = -(e * this.ty - t * s) / n, this
                    }
                    identity() {
                        return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this
                    }
                    clone() {
                        const e = new n;
                        return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e
                    }
                    copyTo(e) {
                        return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e
                    }
                    copyFrom(e) {
                        return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this
                    }
                    toString() {
                        return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`
                    }
                    static get IDENTITY() {
                        return new n
                    }
                    static get TEMP_MATRIX() {
                        return new n
                    }
                }
                t.Matrix = n
            },
            1059: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                class r {
                    constructor(e, t, r = 0, i = 0) {
                        this._x = r, this._y = i, this.cb = e, this.scope = t
                    }
                    clone(e = this.cb, t = this.scope) {
                        return new r(e, t, this._x, this._y)
                    }
                    set(e = 0, t = e) {
                        return this._x === e && this._y === t || (this._x = e, this._y = t, this.cb.call(this.scope)), this
                    }
                    copyFrom(e) {
                        return this._x === e.x && this._y === e.y || (this._x = e.x, this._y = e.y, this.cb.call(this.scope)), this
                    }
                    copyTo(e) {
                        return e.set(this._x, this._y), e
                    }
                    equals(e) {
                        return e.x === this._x && e.y === this._y
                    }
                    toString() {
                        return `[@pixi/math:ObservablePoint x=0 y=0 scope=${this.scope}]`
                    }
                    get x() {
                        return this._x
                    }
                    set x(e) {
                        this._x !== e && (this._x = e, this.cb.call(this.scope))
                    }
                    get y() {
                        return this._y
                    }
                    set y(e) {
                        this._y !== e && (this._y = e, this.cb.call(this.scope))
                    }
                }
                t.ObservablePoint = r
            },
            9970: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                class r {
                    constructor(e = 0, t = 0) {
                        this.x = 0, this.y = 0, this.x = e, this.y = t
                    }
                    clone() {
                        return new r(this.x, this.y)
                    }
                    copyFrom(e) {
                        return this.set(e.x, e.y), this
                    }
                    copyTo(e) {
                        return e.set(this.x, this.y), e
                    }
                    equals(e) {
                        return e.x === this.x && e.y === this.y
                    }
                    set(e = 0, t = e) {
                        return this.x = e, this.y = t, this
                    }
                    toString() {
                        return `[@pixi/math:Point x=${this.x} y=${this.y}]`
                    }
                }
                t.Point = r
            },
            2214: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2863),
                    s = r(1059);
                const n = class {
                    constructor() {
                        this.worldTransform = new i.Matrix, this.localTransform = new i.Matrix, this.position = new s.ObservablePoint(this.onChange, this, 0, 0), this.scale = new s.ObservablePoint(this.onChange, this, 1, 1), this.pivot = new s.ObservablePoint(this.onChange, this, 0, 0), this.skew = new s.ObservablePoint(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0
                    }
                    onChange() {
                        this._localID++
                    }
                    updateSkew() {
                        this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++
                    }
                    toString() {
                        return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`
                    }
                    updateLocalTransform() {
                        const e = this.localTransform;
                        this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1)
                    }
                    updateTransform(e) {
                        const t = this.localTransform;
                        if (this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== e._worldID) {
                            const r = e.worldTransform,
                                i = this.worldTransform;
                            i.a = t.a * r.a + t.b * r.c, i.b = t.a * r.b + t.b * r.d, i.c = t.c * r.a + t.d * r.c, i.d = t.c * r.b + t.d * r.d, i.tx = t.tx * r.a + t.ty * r.c + r.tx, i.ty = t.tx * r.b + t.ty * r.d + r.ty, this._parentID = e._worldID, this._worldID++
                        }
                    }
                    setFromMatrix(e) {
                        e.decompose(this), this._localID++
                    }
                    get rotation() {
                        return this._rotation
                    }
                    set rotation(e) {
                        this._rotation !== e && (this._rotation = e, this.updateSkew())
                    }
                };
                let o = n;
                o.IDENTITY = new n, t.Transform = o
            },
            2849: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const r = 2 * Math.PI,
                    i = 180 / Math.PI,
                    s = Math.PI / 180;
                var n = (e => (e[e.POLY = 0] = "POLY", e[e.RECT = 1] = "RECT", e[e.CIRC = 2] = "CIRC", e[e.ELIP = 3] = "ELIP", e[e.RREC = 4] = "RREC", e))(n || {});
                t.DEG_TO_RAD = s, t.PI_2 = r, t.RAD_TO_DEG = i, t.SHAPES = n
            },
            1851: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2863);
                const s = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
                    n = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
                    o = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
                    a = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
                    h = [],
                    l = [],
                    u = Math.sign;
                ! function() {
                    for (let e = 0; e < 16; e++) {
                        const t = [];
                        h.push(t);
                        for (let r = 0; r < 16; r++) {
                            const i = u(s[e] * s[r] + o[e] * n[r]),
                                h = u(n[e] * s[r] + a[e] * n[r]),
                                l = u(s[e] * o[r] + o[e] * a[r]),
                                c = u(n[e] * o[r] + a[e] * a[r]);
                            for (let e = 0; e < 16; e++)
                                if (s[e] === i && n[e] === h && o[e] === l && a[e] === c) {
                                    t.push(e);
                                    break
                                }
                        }
                    }
                    for (let e = 0; e < 16; e++) {
                        const t = new i.Matrix;
                        t.set(s[e], n[e], o[e], a[e], 0, 0), l.push(t)
                    }
                }();
                const c = {
                    E: 0,
                    SE: 1,
                    S: 2,
                    SW: 3,
                    W: 4,
                    NW: 5,
                    N: 6,
                    NE: 7,
                    MIRROR_VERTICAL: 8,
                    MAIN_DIAGONAL: 10,
                    MIRROR_HORIZONTAL: 12,
                    REVERSE_DIAGONAL: 14,
                    uX: e => s[e],
                    uY: e => n[e],
                    vX: e => o[e],
                    vY: e => a[e],
                    inv: e => 8 & e ? 15 & e : 7 & -e,
                    add: (e, t) => h[e][t],
                    sub: (e, t) => h[e][c.inv(t)],
                    rotate180: e => 4 ^ e,
                    isVertical: e => 2 == (3 & e),
                    byDirection: (e, t) => 2 * Math.abs(e) <= Math.abs(t) ? t >= 0 ? c.S : c.N : 2 * Math.abs(t) <= Math.abs(e) ? e > 0 ? c.E : c.W : t > 0 ? e > 0 ? c.SE : c.SW : e > 0 ? c.NE : c.NW,
                    matrixAppendRotationInv: (e, t, r = 0, i = 0) => {
                        const s = l[c.inv(t)];
                        s.tx = r, s.ty = i, e.append(s)
                    }
                };
                t.groupD8 = c
            },
            8153: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2953),
                    s = r(3881),
                    n = r(1808),
                    o = r(1170),
                    a = r(269),
                    h = r(1851);
                r(1261), r(9799);
                var l = r(2863),
                    u = r(1059),
                    c = r(9970),
                    d = r(2214),
                    p = r(2849);
                t.Circle = i.Circle, t.Ellipse = s.Ellipse, t.Polygon = n.Polygon, t.Rectangle = o.Rectangle, t.RoundedRectangle = a.RoundedRectangle, t.groupD8 = h.groupD8, t.Matrix = l.Matrix, t.ObservablePoint = u.ObservablePoint, t.Point = c.Point, t.Transform = d.Transform, t.DEG_TO_RAD = p.DEG_TO_RAD, t.PI_2 = p.PI_2, t.RAD_TO_DEG = p.RAD_TO_DEG, t.SHAPES = p.SHAPES
            },
            2953: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2849),
                    s = r(1170);
                class n {
                    constructor(e = 0, t = 0, r = 0) {
                        this.x = e, this.y = t, this.radius = r, this.type = i.SHAPES.CIRC
                    }
                    clone() {
                        return new n(this.x, this.y, this.radius)
                    }
                    contains(e, t) {
                        if (this.radius <= 0) return !1;
                        const r = this.radius * this.radius;
                        let i = this.x - e,
                            s = this.y - t;
                        return i *= i, s *= s, i + s <= r
                    }
                    getBounds() {
                        return new s.Rectangle(this.x - this.radius, this.y - this.radius, 2 * this.radius, 2 * this.radius)
                    }
                    toString() {
                        return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`
                    }
                }
                t.Circle = n
            },
            3881: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2849),
                    s = r(1170);
                class n {
                    constructor(e = 0, t = 0, r = 0, s = 0) {
                        this.x = e, this.y = t, this.width = r, this.height = s, this.type = i.SHAPES.ELIP
                    }
                    clone() {
                        return new n(this.x, this.y, this.width, this.height)
                    }
                    contains(e, t) {
                        if (this.width <= 0 || this.height <= 0) return !1;
                        let r = (e - this.x) / this.width,
                            i = (t - this.y) / this.height;
                        return r *= r, i *= i, r + i <= 1
                    }
                    getBounds() {
                        return new s.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height)
                    }
                    toString() {
                        return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
                    }
                }
                t.Ellipse = n
            },
            1808: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2849);
                class s {
                    constructor(...e) {
                        let t = Array.isArray(e[0]) ? e[0] : e;
                        if ("number" != typeof t[0]) {
                            const e = [];
                            for (let r = 0, i = t.length; r < i; r++) e.push(t[r].x, t[r].y);
                            t = e
                        }
                        this.points = t, this.type = i.SHAPES.POLY, this.closeStroke = !0
                    }
                    clone() {
                        const e = this.points.slice(),
                            t = new s(e);
                        return t.closeStroke = this.closeStroke, t
                    }
                    contains(e, t) {
                        let r = !1;
                        const i = this.points.length / 2;
                        for (let s = 0, n = i - 1; s < i; n = s++) {
                            const i = this.points[2 * s],
                                o = this.points[2 * s + 1],
                                a = this.points[2 * n],
                                h = this.points[2 * n + 1];
                            o > t != h > t && e < (t - o) / (h - o) * (a - i) + i && (r = !r)
                        }
                        return r
                    }
                    toString() {
                        return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce(((e,t)=>`${e}, ${t}`),"")}]`
                    }
                }
                t.Polygon = s
            },
            1170: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2849),
                    s = r(9970);
                const n = [new s.Point, new s.Point, new s.Point, new s.Point];
                class o {
                    constructor(e = 0, t = 0, r = 0, s = 0) {
                        this.x = Number(e), this.y = Number(t), this.width = Number(r), this.height = Number(s), this.type = i.SHAPES.RECT
                    }
                    get left() {
                        return this.x
                    }
                    get right() {
                        return this.x + this.width
                    }
                    get top() {
                        return this.y
                    }
                    get bottom() {
                        return this.y + this.height
                    }
                    static get EMPTY() {
                        return new o(0, 0, 0, 0)
                    }
                    clone() {
                        return new o(this.x, this.y, this.width, this.height)
                    }
                    copyFrom(e) {
                        return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this
                    }
                    copyTo(e) {
                        return e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e
                    }
                    contains(e, t) {
                        return !(this.width <= 0 || this.height <= 0) && e >= this.x && e < this.x + this.width && t >= this.y && t < this.y + this.height
                    }
                    intersects(e, t) {
                        if (!t) {
                            const t = this.x < e.x ? e.x : this.x;
                            if ((this.right > e.right ? e.right : this.right) <= t) return !1;
                            const r = this.y < e.y ? e.y : this.y;
                            return (this.bottom > e.bottom ? e.bottom : this.bottom) > r
                        }
                        const r = this.left,
                            i = this.right,
                            s = this.top,
                            o = this.bottom;
                        if (i <= r || o <= s) return !1;
                        const a = n[0].set(e.left, e.top),
                            h = n[1].set(e.left, e.bottom),
                            l = n[2].set(e.right, e.top),
                            u = n[3].set(e.right, e.bottom);
                        if (l.x <= a.x || h.y <= a.y) return !1;
                        const c = Math.sign(t.a * t.d - t.b * t.c);
                        if (0 === c) return !1;
                        if (t.apply(a, a), t.apply(h, h), t.apply(l, l), t.apply(u, u), Math.max(a.x, h.x, l.x, u.x) <= r || Math.min(a.x, h.x, l.x, u.x) >= i || Math.max(a.y, h.y, l.y, u.y) <= s || Math.min(a.y, h.y, l.y, u.y) >= o) return !1;
                        const d = c * (h.y - a.y),
                            p = c * (a.x - h.x),
                            f = d * r + p * s,
                            m = d * i + p * s,
                            g = d * r + p * o,
                            y = d * i + p * o;
                        if (Math.max(f, m, g, y) <= d * a.x + p * a.y || Math.min(f, m, g, y) >= d * u.x + p * u.y) return !1;
                        const _ = c * (a.y - l.y),
                            v = c * (l.x - a.x),
                            S = _ * r + v * s,
                            T = _ * i + v * s,
                            b = _ * r + v * o,
                            E = _ * i + v * o;
                        return !(Math.max(S, T, b, E) <= _ * a.x + v * a.y || Math.min(S, T, b, E) >= _ * u.x + v * u.y)
                    }
                    pad(e = 0, t = e) {
                        return this.x -= e, this.y -= t, this.width += 2 * e, this.height += 2 * t, this
                    }
                    fit(e) {
                        const t = Math.max(this.x, e.x),
                            r = Math.min(this.x + this.width, e.x + e.width),
                            i = Math.max(this.y, e.y),
                            s = Math.min(this.y + this.height, e.y + e.height);
                        return this.x = t, this.width = Math.max(r - t, 0), this.y = i, this.height = Math.max(s - i, 0), this
                    }
                    ceil(e = 1, t = .001) {
                        const r = Math.ceil((this.x + this.width - t) * e) / e,
                            i = Math.ceil((this.y + this.height - t) * e) / e;
                        return this.x = Math.floor((this.x + t) * e) / e, this.y = Math.floor((this.y + t) * e) / e, this.width = r - this.x, this.height = i - this.y, this
                    }
                    enlarge(e) {
                        const t = Math.min(this.x, e.x),
                            r = Math.max(this.x + this.width, e.x + e.width),
                            i = Math.min(this.y, e.y),
                            s = Math.max(this.y + this.height, e.y + e.height);
                        return this.x = t, this.width = r - t, this.y = i, this.height = s - i, this
                    }
                    toString() {
                        return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
                    }
                }
                t.Rectangle = o
            },
            269: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2849);
                class s {
                    constructor(e = 0, t = 0, r = 0, s = 0, n = 20) {
                        this.x = e, this.y = t, this.width = r, this.height = s, this.radius = n, this.type = i.SHAPES.RREC
                    }
                    clone() {
                        return new s(this.x, this.y, this.width, this.height, this.radius)
                    }
                    contains(e, t) {
                        if (this.width <= 0 || this.height <= 0) return !1;
                        if (e >= this.x && e <= this.x + this.width && t >= this.y && t <= this.y + this.height) {
                            const r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
                            if (t >= this.y + r && t <= this.y + this.height - r || e >= this.x + r && e <= this.x + this.width - r) return !0;
                            let i = e - (this.x + r),
                                s = t - (this.y + r);
                            const n = r * r;
                            if (i * i + s * s <= n) return !0;
                            if (i = e - (this.x + this.width - r), i * i + s * s <= n) return !0;
                            if (s = t - (this.y + this.height - r), i * i + s * s <= n) return !0;
                            if (i = e - (this.x + r), i * i + s * s <= n) return !0
                        }
                        return !1
                    }
                    toString() {
                        return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`
                    }
                }
                t.RoundedRectangle = s
            },
            9339: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(9136);
                class n extends s.SimplePlane {
                    constructor(e, t, r, s, n) {
                        super(i.Texture.WHITE, 4, 4), this._origWidth = e.orig.width, this._origHeight = e.orig.height, this._width = this._origWidth, this._height = this._origHeight, this._leftWidth = t ?? e.defaultBorders?.left ?? 10, this._rightWidth = s ?? e.defaultBorders?.right ?? 10, this._topHeight = r ?? e.defaultBorders?.top ?? 10, this._bottomHeight = n ?? e.defaultBorders?.bottom ?? 10, this.texture = e
                    }
                    textureUpdated() {
                        this._textureID = this.shader.texture._updateID, this._refresh()
                    }
                    get vertices() {
                        return this.geometry.getBuffer("aVertexPosition").data
                    }
                    set vertices(e) {
                        this.geometry.getBuffer("aVertexPosition").data = e
                    }
                    updateHorizontalVertices() {
                        const e = this.vertices,
                            t = this._getMinScale();
                        e[9] = e[11] = e[13] = e[15] = this._topHeight * t, e[17] = e[19] = e[21] = e[23] = this._height - this._bottomHeight * t, e[25] = e[27] = e[29] = e[31] = this._height
                    }
                    updateVerticalVertices() {
                        const e = this.vertices,
                            t = this._getMinScale();
                        e[2] = e[10] = e[18] = e[26] = this._leftWidth * t, e[4] = e[12] = e[20] = e[28] = this._width - this._rightWidth * t, e[6] = e[14] = e[22] = e[30] = this._width
                    }
                    _getMinScale() {
                        const e = this._leftWidth + this._rightWidth,
                            t = this._width > e ? 1 : this._width / e,
                            r = this._topHeight + this._bottomHeight,
                            i = this._height > r ? 1 : this._height / r;
                        return Math.min(t, i)
                    }
                    get width() {
                        return this._width
                    }
                    set width(e) {
                        this._width = e, this._refresh()
                    }
                    get height() {
                        return this._height
                    }
                    set height(e) {
                        this._height = e, this._refresh()
                    }
                    get leftWidth() {
                        return this._leftWidth
                    }
                    set leftWidth(e) {
                        this._leftWidth = e, this._refresh()
                    }
                    get rightWidth() {
                        return this._rightWidth
                    }
                    set rightWidth(e) {
                        this._rightWidth = e, this._refresh()
                    }
                    get topHeight() {
                        return this._topHeight
                    }
                    set topHeight(e) {
                        this._topHeight = e, this._refresh()
                    }
                    get bottomHeight() {
                        return this._bottomHeight
                    }
                    set bottomHeight(e) {
                        this._bottomHeight = e, this._refresh()
                    }
                    _refresh() {
                        const e = this.texture,
                            t = this.geometry.buffers[1].data;
                        this._origWidth = e.orig.width, this._origHeight = e.orig.height;
                        const r = 1 / this._origWidth,
                            i = 1 / this._origHeight;
                        t[0] = t[8] = t[16] = t[24] = 0, t[1] = t[3] = t[5] = t[7] = 0, t[6] = t[14] = t[22] = t[30] = 1, t[25] = t[27] = t[29] = t[31] = 1, t[2] = t[10] = t[18] = t[26] = r * this._leftWidth, t[4] = t[12] = t[20] = t[28] = 1 - r * this._rightWidth, t[9] = t[11] = t[13] = t[15] = i * this._topHeight, t[17] = t[19] = t[21] = t[23] = 1 - i * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update()
                    }
                }
                t.NineSlicePlane = n
            },
            2403: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(1917);
                class n extends s.Mesh {
                    constructor(e = i.Texture.EMPTY, t, r, n, o) {
                        const a = new s.MeshGeometry(t, r, n);
                        a.getBuffer("aVertexPosition").static = !1, super(a, new s.MeshMaterial(e), null, o), this.autoUpdate = !0
                    }
                    get vertices() {
                        return this.geometry.getBuffer("aVertexPosition").data
                    }
                    set vertices(e) {
                        this.geometry.getBuffer("aVertexPosition").data = e
                    }
                    _render(e) {
                        this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), super._render(e)
                    }
                }
                t.SimpleMesh = n
            },
            9136: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(1917),
                    n = r(341);
                class o extends s.Mesh {
                    constructor(e, t, r) {
                        super(new n.PlaneGeometry(e.width, e.height, t, r), new s.MeshMaterial(i.Texture.WHITE)), this.texture = e, this.autoResize = !0
                    }
                    textureUpdated() {
                        this._textureID = this.shader.texture._updateID;
                        const e = this.geometry,
                            {
                                width: t,
                                height: r
                            } = this.shader.texture;
                        !this.autoResize || e.width === t && e.height === r || (e.width = this.shader.texture.width, e.height = this.shader.texture.height, e.build())
                    }
                    set texture(e) {
                        this.shader.texture !== e && (this.shader.texture = e, this._textureID = -1, e.baseTexture.valid ? this.textureUpdated() : e.once("update", this.textureUpdated, this))
                    }
                    get texture() {
                        return this.shader.texture
                    }
                    _render(e) {
                        this._textureID !== this.shader.texture._updateID && this.textureUpdated(), super._render(e)
                    }
                    destroy(e) {
                        this.shader.texture.off("update", this.textureUpdated, this), super.destroy(e)
                    }
                }
                t.SimplePlane = o
            },
            7721: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(1917),
                    n = r(9420);
                class o extends s.Mesh {
                    constructor(e, t, r = 0) {
                        const o = new n.RopeGeometry(e.height, t, r),
                            a = new s.MeshMaterial(e);
                        r > 0 && (e.baseTexture.wrapMode = i.WRAP_MODES.REPEAT), super(o, a), this.autoUpdate = !0
                    }
                    _render(e) {
                        const t = this.geometry;
                        (this.autoUpdate || t._width !== this.shader.texture.height) && (t._width = this.shader.texture.height, t.update()), super._render(e)
                    }
                }
                t.SimpleRope = o
            },
            341: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(1917);
                class s extends i.MeshGeometry {
                    constructor(e = 100, t = 100, r = 10, i = 10) {
                        super(), this.segWidth = r, this.segHeight = i, this.width = e, this.height = t, this.build()
                    }
                    build() {
                        const e = this.segWidth * this.segHeight,
                            t = [],
                            r = [],
                            i = [],
                            s = this.segWidth - 1,
                            n = this.segHeight - 1,
                            o = this.width / s,
                            a = this.height / n;
                        for (let i = 0; i < e; i++) {
                            const e = i % this.segWidth,
                                h = i / this.segWidth | 0;
                            t.push(e * o, h * a), r.push(e / s, h / n)
                        }
                        const h = s * n;
                        for (let e = 0; e < h; e++) {
                            const t = e % s,
                                r = e / s | 0,
                                n = r * this.segWidth + t,
                                o = r * this.segWidth + t + 1,
                                a = (r + 1) * this.segWidth + t,
                                h = (r + 1) * this.segWidth + t + 1;
                            i.push(n, o, a, o, h, a)
                        }
                        this.buffers[0].data = new Float32Array(t), this.buffers[1].data = new Float32Array(r), this.indexBuffer.data = new Uint16Array(i), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update()
                    }
                }
                t.PlaneGeometry = s
            },
            9420: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(1917);
                class s extends i.MeshGeometry {
                    constructor(e = 200, t, r = 0) {
                        super(new Float32Array(4 * t.length), new Float32Array(4 * t.length), new Uint16Array(6 * (t.length - 1))), this.points = t, this._width = e, this.textureScale = r, this.build()
                    }
                    get width() {
                        return this._width
                    }
                    build() {
                        const e = this.points;
                        if (!e) return;
                        const t = this.getBuffer("aVertexPosition"),
                            r = this.getBuffer("aTextureCoord"),
                            i = this.getIndex();
                        if (e.length < 1) return;
                        t.data.length / 4 !== e.length && (t.data = new Float32Array(4 * e.length), r.data = new Float32Array(4 * e.length), i.data = new Uint16Array(6 * (e.length - 1)));
                        const s = r.data,
                            n = i.data;
                        s[0] = 0, s[1] = 0, s[2] = 0, s[3] = 1;
                        let o = 0,
                            a = e[0];
                        const h = this._width * this.textureScale,
                            l = e.length;
                        for (let t = 0; t < l; t++) {
                            const r = 4 * t;
                            if (this.textureScale > 0) {
                                const r = a.x - e[t].x,
                                    i = a.y - e[t].y,
                                    s = Math.sqrt(r * r + i * i);
                                a = e[t], o += s / h
                            } else o = t / (l - 1);
                            s[r] = o, s[r + 1] = 0, s[r + 2] = o, s[r + 3] = 1
                        }
                        let u = 0;
                        for (let e = 0; e < l - 1; e++) {
                            const t = 2 * e;
                            n[u++] = t, n[u++] = t + 1, n[u++] = t + 2, n[u++] = t + 2, n[u++] = t + 1, n[u++] = t + 3
                        }
                        r.update(), i.update(), this.updateVertices()
                    }
                    updateVertices() {
                        const e = this.points;
                        if (e.length < 1) return;
                        let t, r = e[0],
                            i = 0,
                            s = 0;
                        const n = this.buffers[0].data,
                            o = e.length,
                            a = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
                        for (let h = 0; h < o; h++) {
                            const l = e[h],
                                u = 4 * h;
                            t = h < e.length - 1 ? e[h + 1] : l, s = -(t.x - r.x), i = t.y - r.y;
                            let c = 10 * (1 - h / (o - 1));
                            c > 1 && (c = 1);
                            const d = Math.sqrt(i * i + s * s);
                            d < 1e-6 ? (i = 0, s = 0) : (i /= d, s /= d, i *= a, s *= a), n[u] = l.x + i, n[u + 1] = l.y + s, n[u + 2] = l.x - i, n[u + 3] = l.y - s, r = l
                        }
                        this.buffers[0].update()
                    }
                    update() {
                        this.textureScale > 0 ? this.build() : this.updateVertices()
                    }
                }
                t.RopeGeometry = s
            },
            151: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(341),
                    s = r(9420),
                    n = r(9339),
                    o = r(2403),
                    a = r(9136),
                    h = r(7721);
                t.PlaneGeometry = i.PlaneGeometry, t.RopeGeometry = s.RopeGeometry, t.NineSlicePlane = n.NineSlicePlane, t.SimpleMesh = o.SimpleMesh, t.SimplePlane = a.SimplePlane, t.SimpleRope = h.SimpleRope
            },
            3131: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(2781),
                    n = r(7703);
                const o = new i.Point,
                    a = new i.Polygon,
                    h = class extends s.Container {
                        constructor(e, t, r, s = i.DRAW_MODES.TRIANGLES) {
                            super(), this.geometry = e, this.shader = t, this.state = r || i.State.for2d(), this.drawMode = s, this.start = 0, this.size = 0, this.uvs = null, this.indices = null, this.vertexData = new Float32Array(1), this.vertexDirty = -1, this._transformID = -1, this._roundPixels = i.settings.ROUND_PIXELS, this.batchUvs = null
                        }
                        get geometry() {
                            return this._geometry
                        }
                        set geometry(e) {
                            this._geometry !== e && (this._geometry && (this._geometry.refCount--, 0 === this._geometry.refCount && this._geometry.dispose()), this._geometry = e, this._geometry && this._geometry.refCount++, this.vertexDirty = -1)
                        }
                        get uvBuffer() {
                            return this.geometry.buffers[1]
                        }
                        get verticesBuffer() {
                            return this.geometry.buffers[0]
                        }
                        set material(e) {
                            this.shader = e
                        }
                        get material() {
                            return this.shader
                        }
                        set blendMode(e) {
                            this.state.blendMode = e
                        }
                        get blendMode() {
                            return this.state.blendMode
                        }
                        set roundPixels(e) {
                            this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e
                        }
                        get roundPixels() {
                            return this._roundPixels
                        }
                        get tint() {
                            return "tint" in this.shader ? this.shader.tint : null
                        }
                        set tint(e) {
                            this.shader.tint = e
                        }
                        get tintValue() {
                            return this.shader.tintValue
                        }
                        get texture() {
                            return "texture" in this.shader ? this.shader.texture : null
                        }
                        set texture(e) {
                            this.shader.texture = e
                        }
                        _render(e) {
                            const t = this.geometry.buffers[0].data;
                            this.shader.batchable && this.drawMode === i.DRAW_MODES.TRIANGLES && t.length < 2 * h.BATCHABLE_SIZE ? this._renderToBatch(e) : this._renderDefault(e)
                        }
                        _renderDefault(e) {
                            const t = this.shader;
                            t.alpha = this.worldAlpha, t.update && t.update(), e.batch.flush(), t.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), e.shader.bind(t), e.state.set(this.state), e.geometry.bind(this.geometry, t), e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount)
                        }
                        _renderToBatch(e) {
                            const t = this.geometry,
                                r = this.shader;
                            r.uvMatrix && (r.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = t.indexBuffer.data, this._tintRGB = r._tintRGB, this._texture = r.texture;
                            const i = this.material.pluginName;
                            e.batch.setObjectRenderer(e.plugins[i]), e.plugins[i].render(this)
                        }
                        calculateVertices() {
                            const e = this.geometry.buffers[0],
                                t = e.data,
                                r = e._updateID;
                            if (r === this.vertexDirty && this._transformID === this.transform._worldID) return;
                            this._transformID = this.transform._worldID, this.vertexData.length !== t.length && (this.vertexData = new Float32Array(t.length));
                            const s = this.transform.worldTransform,
                                n = s.a,
                                o = s.b,
                                a = s.c,
                                h = s.d,
                                l = s.tx,
                                u = s.ty,
                                c = this.vertexData;
                            for (let e = 0; e < c.length / 2; e++) {
                                const r = t[2 * e],
                                    i = t[2 * e + 1];
                                c[2 * e] = n * r + a * i + l, c[2 * e + 1] = o * r + h * i + u
                            }
                            if (this._roundPixels) {
                                const e = i.settings.RESOLUTION;
                                for (let t = 0; t < c.length; ++t) c[t] = Math.round(c[t] * e) / e
                            }
                            this.vertexDirty = r
                        }
                        calculateUvs() {
                            const e = this.geometry.buffers[1],
                                t = this.shader;
                            t.uvMatrix.isSimple ? this.uvs = e.data : (this.batchUvs || (this.batchUvs = new n.MeshBatchUvs(e, t.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data)
                        }
                        _calculateBounds() {
                            this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length)
                        }
                        containsPoint(e) {
                            if (!this.getBounds().contains(e.x, e.y)) return !1;
                            this.worldTransform.applyInverse(e, o);
                            const t = this.geometry.getBuffer("aVertexPosition").data,
                                r = a.points,
                                i = this.geometry.getIndex().data,
                                s = i.length,
                                n = 4 === this.drawMode ? 3 : 1;
                            for (let e = 0; e + 2 < s; e += n) {
                                const s = 2 * i[e],
                                    n = 2 * i[e + 1],
                                    h = 2 * i[e + 2];
                                if (r[0] = t[s], r[1] = t[s + 1], r[2] = t[n], r[3] = t[n + 1], r[4] = t[h], r[5] = t[h + 1], a.contains(o.x, o.y)) return !0
                            }
                            return !1
                        }
                        destroy(e) {
                            super.destroy(e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null
                        }
                    };
                let l = h;
                l.BATCHABLE_SIZE = 100, t.Mesh = l
            },
            7703: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.MeshBatchUvs = class {
                    constructor(e, t) {
                        this.uvBuffer = e, this.uvMatrix = t, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0
                    }
                    update(e) {
                        if (!e && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) return;
                        this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
                        const t = this.uvBuffer.data;
                        this.data && this.data.length === t.length || (this.data = new Float32Array(t.length)), this.uvMatrix.multiplyUvs(t, this.data), this._updateID++
                    }
                }
            },
            5015: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                class s extends i.Geometry {
                    constructor(e, t, r) {
                        super();
                        const s = new i.Buffer(e),
                            n = new i.Buffer(t, !0),
                            o = new i.Buffer(r, !0, !0);
                        this.addAttribute("aVertexPosition", s, 2, !1, i.TYPES.FLOAT).addAttribute("aTextureCoord", n, 2, !1, i.TYPES.FLOAT).addIndex(o), this._updateId = -1
                    }
                    get vertexDirtyId() {
                        return this.buffers[0]._updateID
                    }
                }
                t.MeshGeometry = s
            },
            4927: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(3615),
                    n = r(1152);
                class o extends i.Shader {
                    constructor(e, t) {
                        const r = {
                            uSampler: e,
                            alpha: 1,
                            uTextureMatrix: i.Matrix.IDENTITY,
                            uColor: new Float32Array([1, 1, 1, 1])
                        };
                        (t = Object.assign({
                            tint: 16777215,
                            alpha: 1,
                            pluginName: "batch"
                        }, t)).uniforms && Object.assign(r, t.uniforms), super(t.program || i.Program.from(n.default, s.default), r), this._colorDirty = !1, this.uvMatrix = new i.TextureMatrix(e), this.batchable = void 0 === t.program, this.pluginName = t.pluginName, this._tintColor = new i.Color(t.tint), this._tintRGB = this._tintColor.toLittleEndianNumber(), this._colorDirty = !0, this.alpha = t.alpha
                    }
                    get texture() {
                        return this.uniforms.uSampler
                    }
                    set texture(e) {
                        this.uniforms.uSampler !== e && (!this.uniforms.uSampler.baseTexture.alphaMode != !e.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = e, this.uvMatrix.texture = e)
                    }
                    set alpha(e) {
                        e !== this._alpha && (this._alpha = e, this._colorDirty = !0)
                    }
                    get alpha() {
                        return this._alpha
                    }
                    set tint(e) {
                        e !== this.tint && (this._tintColor.setValue(e), this._tintRGB = this._tintColor.toLittleEndianNumber(), this._colorDirty = !0)
                    }
                    get tint() {
                        return this._tintColor.value
                    }
                    get tintValue() {
                        return this._tintColor.toNumber()
                    }
                    update() {
                        if (this._colorDirty) {
                            this._colorDirty = !1;
                            const e = this.texture.baseTexture.alphaMode;
                            i.Color.shared.setValue(this._tintColor).premultiply(this._alpha, e).toArray(this.uniforms.uColor)
                        }
                        this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord)
                    }
                }
                t.MeshMaterial = o
            },
            1917: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(3131),
                    s = r(7703),
                    n = r(5015),
                    o = r(4927);
                t.Mesh = i.Mesh, t.MeshBatchUvs = s.MeshBatchUvs, t.MeshGeometry = n.MeshGeometry, t.MeshMaterial = o.MeshMaterial
            },
            3615: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "varying vec2 vTextureCoord;\nuniform vec4 uColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n"
            },
            1152: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTextureMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\n}\n"
            },
            4142: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(2781),
                    n = r(2517);
                const o = new i.Matrix;
                s.DisplayObject.prototype._cacheAsBitmap = !1, s.DisplayObject.prototype._cacheData = null, s.DisplayObject.prototype._cacheAsBitmapResolution = null, s.DisplayObject.prototype._cacheAsBitmapMultisample = null;
                class a {
                    constructor() {
                        this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null
                    }
                }
                Object.defineProperties(s.DisplayObject.prototype, {
                    cacheAsBitmapResolution: {
                        get() {
                            return this._cacheAsBitmapResolution
                        },
                        set(e) {
                            e !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = e, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0))
                        }
                    },
                    cacheAsBitmapMultisample: {
                        get() {
                            return this._cacheAsBitmapMultisample
                        },
                        set(e) {
                            e !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = e, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0))
                        }
                    },
                    cacheAsBitmap: {
                        get() {
                            return this._cacheAsBitmap
                        },
                        set(e) {
                            if (this._cacheAsBitmap === e) return;
                            let t;
                            this._cacheAsBitmap = e, e ? (this._cacheData || (this._cacheData = new a), t = this._cacheData, t.originalRender = this.render, t.originalRenderCanvas = this.renderCanvas, t.originalUpdateTransform = this.updateTransform, t.originalCalculateBounds = this.calculateBounds, t.originalGetLocalBounds = this.getLocalBounds, t.originalDestroy = this.destroy, t.originalContainsPoint = this.containsPoint, t.originalMask = this._mask, t.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData, t.sprite && this._destroyCachedDisplayObject(), this.render = t.originalRender, this.renderCanvas = t.originalRenderCanvas, this.calculateBounds = t.originalCalculateBounds, this.getLocalBounds = t.originalGetLocalBounds, this.destroy = t.originalDestroy, this.updateTransform = t.originalUpdateTransform, this.containsPoint = t.originalContainsPoint, this._mask = t.originalMask, this.filterArea = t.originalFilterArea)
                        }
                    }
                }), s.DisplayObject.prototype._renderCached = function(e) {
                    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(e), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(e))
                }, s.DisplayObject.prototype._initCachedDisplayObject = function(e) {
                    if (this._cacheData?.sprite) return;
                    const t = this.alpha;
                    this.alpha = 1, e.batch.flush();
                    const r = this.getLocalBounds(null, !0).clone();
                    if (this.filters?.length) {
                        const e = this.filters[0].padding;
                        r.pad(e)
                    }
                    r.ceil(i.settings.RESOLUTION);
                    const s = e.renderTexture.current,
                        a = e.renderTexture.sourceFrame.clone(),
                        h = e.renderTexture.destinationFrame.clone(),
                        l = e.projection.transform,
                        u = i.RenderTexture.create({
                            width: r.width,
                            height: r.height,
                            resolution: this.cacheAsBitmapResolution || e.resolution,
                            multisample: this.cacheAsBitmapMultisample ?? e.multisample
                        }),
                        c = `cacheAsBitmap_${i.utils.uid()}`;
                    this._cacheData.textureCacheId = c, i.BaseTexture.addToCache(u.baseTexture, c), i.Texture.addToCache(u, c);
                    const d = this.transform.localTransform.copyTo(o).invert().translate(-r.x, -r.y);
                    this.render = this._cacheData.originalRender, e.render(this, {
                        renderTexture: u,
                        clear: !0,
                        transform: d,
                        skipUpdateTransform: !1
                    }), e.framebuffer.blit(), e.projection.transform = l, e.renderTexture.bind(s, a, h), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = t;
                    const p = new n.Sprite(u);
                    p.transform.worldTransform = this.transform.worldTransform, p.anchor.x = -r.x / r.width, p.anchor.y = -r.y / r.height, p.alpha = t, p._bounds = this._bounds, this._cacheData.sprite = p, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = p.containsPoint.bind(p)
                }, s.DisplayObject.prototype._renderCachedCanvas = function(e) {
                    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(e), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(e))
                }, s.DisplayObject.prototype._initCachedDisplayObjectCanvas = function(e) {
                    if (this._cacheData?.sprite) return;
                    const t = this.getLocalBounds(null, !0),
                        r = this.alpha;
                    this.alpha = 1;
                    const s = e.canvasContext.activeContext,
                        a = e._projTransform;
                    t.ceil(i.settings.RESOLUTION);
                    const h = i.RenderTexture.create({
                            width: t.width,
                            height: t.height
                        }),
                        l = `cacheAsBitmap_${i.utils.uid()}`;
                    this._cacheData.textureCacheId = l, i.BaseTexture.addToCache(h.baseTexture, l), i.Texture.addToCache(h, l);
                    const u = o;
                    this.transform.localTransform.copyTo(u), u.invert(), u.tx -= t.x, u.ty -= t.y, this.renderCanvas = this._cacheData.originalRenderCanvas, e.render(this, {
                        renderTexture: h,
                        clear: !0,
                        transform: u,
                        skipUpdateTransform: !1
                    }), e.canvasContext.activeContext = s, e._projTransform = a, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = r;
                    const c = new n.Sprite(h);
                    c.transform.worldTransform = this.transform.worldTransform, c.anchor.x = -t.x / t.width, c.anchor.y = -t.y / t.height, c.alpha = r, c._bounds = this._bounds, this._cacheData.sprite = c, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = e._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = c.containsPoint.bind(c)
                }, s.DisplayObject.prototype._calculateCachedBounds = function() {
                    this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID
                }, s.DisplayObject.prototype._getCachedLocalBounds = function() {
                    return this._cacheData.sprite.getLocalBounds(null)
                }, s.DisplayObject.prototype._destroyCachedDisplayObject = function() {
                    this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, i.BaseTexture.removeFromCache(this._cacheData.textureCacheId), i.Texture.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null
                }, s.DisplayObject.prototype._cacheAsBitmapDestroy = function(e) {
                    this.cacheAsBitmap = !1, this.destroy(e)
                }, t.CacheData = a
            },
            1181: (e, t, r) => {
                "use strict";
                var i = r(2781);
                i.DisplayObject.prototype.name = null, i.Container.prototype.getChildByName = function(e, t) {
                    for (let t = 0, r = this.children.length; t < r; t++)
                        if (this.children[t].name === e) return this.children[t];
                    if (t)
                        for (let t = 0, r = this.children.length; t < r; t++) {
                            const r = this.children[t];
                            if (!r.getChildByName) continue;
                            const i = r.getChildByName(e, !0);
                            if (i) return i
                        }
                    return null
                }
            },
            9989: (e, t, r) => {
                "use strict";
                var i = r(7163);
                r(2781).DisplayObject.prototype.getGlobalPosition = function(e = new i.Point, t = !1) {
                    return this.parent ? this.parent.toGlobal(this.position, e, t) : (e.x = this.position.x, e.y = this.position.y), e
                }
            },
            455: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                t.ParticleBuffer = class {
                    constructor(e, t, r) {
                        this.geometry = new i.Geometry, this.indexBuffer = null, this.size = r, this.dynamicProperties = [], this.staticProperties = [];
                        for (let r = 0; r < e.length; ++r) {
                            let s = e[r];
                            s = {
                                attributeName: s.attributeName,
                                size: s.size,
                                uploadFunction: s.uploadFunction,
                                type: s.type || i.TYPES.FLOAT,
                                offset: s.offset
                            }, t[r] ? this.dynamicProperties.push(s) : this.staticProperties.push(s)
                        }
                        this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers()
                    }
                    initBuffers() {
                        const e = this.geometry;
                        let t = 0;
                        this.indexBuffer = new i.Buffer(i.utils.createIndicesForQuads(this.size), !0, !0), e.addIndex(this.indexBuffer), this.dynamicStride = 0;
                        for (let e = 0; e < this.dynamicProperties.length; ++e) {
                            const r = this.dynamicProperties[e];
                            r.offset = t, t += r.size, this.dynamicStride += r.size
                        }
                        const r = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
                        this.dynamicData = new Float32Array(r), this.dynamicDataUint32 = new Uint32Array(r), this.dynamicBuffer = new i.Buffer(this.dynamicData, !1, !1);
                        let s = 0;
                        this.staticStride = 0;
                        for (let e = 0; e < this.staticProperties.length; ++e) {
                            const t = this.staticProperties[e];
                            t.offset = s, s += t.size, this.staticStride += t.size
                        }
                        const n = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
                        this.staticData = new Float32Array(n), this.staticDataUint32 = new Uint32Array(n), this.staticBuffer = new i.Buffer(this.staticData, !0, !1);
                        for (let t = 0; t < this.dynamicProperties.length; ++t) {
                            const r = this.dynamicProperties[t];
                            e.addAttribute(r.attributeName, this.dynamicBuffer, 0, r.type === i.TYPES.UNSIGNED_BYTE, r.type, 4 * this.dynamicStride, 4 * r.offset)
                        }
                        for (let t = 0; t < this.staticProperties.length; ++t) {
                            const r = this.staticProperties[t];
                            e.addAttribute(r.attributeName, this.staticBuffer, 0, r.type === i.TYPES.UNSIGNED_BYTE, r.type, 4 * this.staticStride, 4 * r.offset)
                        }
                    }
                    uploadDynamic(e, t, r) {
                        for (let s = 0; s < this.dynamicProperties.length; s++) {
                            const n = this.dynamicProperties[s];
                            n.uploadFunction(e, t, r, n.type === i.TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, n.offset)
                        }
                        this.dynamicBuffer._updateID++
                    }
                    uploadStatic(e, t, r) {
                        for (let s = 0; s < this.staticProperties.length; s++) {
                            const n = this.staticProperties[s];
                            n.uploadFunction(e, t, r, n.type === i.TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, n.offset)
                        }
                        this.staticBuffer._updateID++
                    }
                    destroy() {
                        this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy()
                    }
                }
            },
            5568: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(2781);
                class n extends s.Container {
                    constructor(e = 1500, t, r = 16384, s = !1) {
                        super(), r > 16384 && (r = 16384), this._properties = [!1, !0, !1, !1, !1], this._maxSize = e, this._batchSize = r, this._buffers = null, this._bufferUpdateIDs = [], this._updateID = 0, this.interactiveChildren = !1, this.blendMode = i.BLEND_MODES.NORMAL, this.autoResize = s, this.roundPixels = !0, this.baseTexture = null, this.setProperties(t), this._tintColor = new i.Color(0), this.tintRgb = new Float32Array(3), this.tint = 16777215
                    }
                    setProperties(e) {
                        e && (this._properties[0] = "vertices" in e || "scale" in e ? !!e.vertices || !!e.scale : this._properties[0], this._properties[1] = "position" in e ? !!e.position : this._properties[1], this._properties[2] = "rotation" in e ? !!e.rotation : this._properties[2], this._properties[3] = "uvs" in e ? !!e.uvs : this._properties[3], this._properties[4] = "tint" in e || "alpha" in e ? !!e.tint || !!e.alpha : this._properties[4])
                    }
                    updateTransform() {
                        this.displayObjectUpdateTransform()
                    }
                    get tint() {
                        return this._tintColor.value
                    }
                    set tint(e) {
                        this._tintColor.setValue(e), this._tintColor.toRgbArray(this.tintRgb)
                    }
                    render(e) {
                        this.visible && !(this.worldAlpha <= 0) && this.children.length && this.renderable && (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", (() => this.onChildrenChange(0)))), e.batch.setObjectRenderer(e.plugins.particle), e.plugins.particle.render(this))
                    }
                    onChildrenChange(e) {
                        const t = Math.floor(e / this._batchSize);
                        for (; this._bufferUpdateIDs.length < t;) this._bufferUpdateIDs.push(0);
                        this._bufferUpdateIDs[t] = ++this._updateID
                    }
                    dispose() {
                        if (this._buffers) {
                            for (let e = 0; e < this._buffers.length; ++e) this._buffers[e].destroy();
                            this._buffers = null
                        }
                    }
                    destroy(e) {
                        super.destroy(e), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null
                    }
                }
                t.ParticleContainer = n
            },
            8627: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(455),
                    n = r(5723),
                    o = r(7130);
                class a extends i.ObjectRenderer {
                    constructor(e) {
                        super(e), this.shader = null, this.properties = null, this.tempMatrix = new i.Matrix, this.properties = [{
                            attributeName: "aVertexPosition",
                            size: 2,
                            uploadFunction: this.uploadVertices,
                            offset: 0
                        }, {
                            attributeName: "aPositionCoord",
                            size: 2,
                            uploadFunction: this.uploadPosition,
                            offset: 0
                        }, {
                            attributeName: "aRotation",
                            size: 1,
                            uploadFunction: this.uploadRotation,
                            offset: 0
                        }, {
                            attributeName: "aTextureCoord",
                            size: 2,
                            uploadFunction: this.uploadUvs,
                            offset: 0
                        }, {
                            attributeName: "aColor",
                            size: 1,
                            type: i.TYPES.UNSIGNED_BYTE,
                            uploadFunction: this.uploadTint,
                            offset: 0
                        }], this.shader = i.Shader.from(o.default, n.default, {}), this.state = i.State.for2d()
                    }
                    render(e) {
                        const t = e.children,
                            r = e._maxSize,
                            s = e._batchSize,
                            n = this.renderer;
                        let o = t.length;
                        if (0 === o) return;
                        o > r && !e.autoResize && (o = r);
                        let a = e._buffers;
                        a || (a = e._buffers = this.generateBuffers(e));
                        const h = t[0]._texture.baseTexture,
                            l = h.alphaMode > 0;
                        this.state.blendMode = i.utils.correctBlendMode(e.blendMode, l), n.state.set(this.state);
                        const u = n.gl,
                            c = e.worldTransform.copyTo(this.tempMatrix);
                        c.prepend(n.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = c.toArray(!0), this.shader.uniforms.uColor = i.Color.shared.setValue(e.tintRgb).premultiply(e.worldAlpha, l).toArray(this.shader.uniforms.uColor), this.shader.uniforms.uSampler = h, this.renderer.shader.bind(this.shader);
                        let d = !1;
                        for (let r = 0, i = 0; r < o; r += s, i += 1) {
                            let h = o - r;
                            h > s && (h = s), i >= a.length && a.push(this._generateOneMoreBuffer(e));
                            const l = a[i];
                            l.uploadDynamic(t, r, h);
                            const c = e._bufferUpdateIDs[i] || 0;
                            d = d || l._updateID < c, d && (l._updateID = e._updateID, l.uploadStatic(t, r, h)), n.geometry.bind(l.geometry), u.drawElements(u.TRIANGLES, 6 * h, u.UNSIGNED_SHORT, 0)
                        }
                    }
                    generateBuffers(e) {
                        const t = [],
                            r = e._maxSize,
                            i = e._batchSize,
                            n = e._properties;
                        for (let e = 0; e < r; e += i) t.push(new s.ParticleBuffer(this.properties, n, i));
                        return t
                    }
                    _generateOneMoreBuffer(e) {
                        const t = e._batchSize,
                            r = e._properties;
                        return new s.ParticleBuffer(this.properties, r, t)
                    }
                    uploadVertices(e, t, r, i, s, n) {
                        let o = 0,
                            a = 0,
                            h = 0,
                            l = 0;
                        for (let u = 0; u < r; ++u) {
                            const r = e[t + u],
                                c = r._texture,
                                d = r.scale.x,
                                p = r.scale.y,
                                f = c.trim,
                                m = c.orig;
                            f ? (a = f.x - r.anchor.x * m.width, o = a + f.width, l = f.y - r.anchor.y * m.height, h = l + f.height) : (o = m.width * (1 - r.anchor.x), a = m.width * -r.anchor.x, h = m.height * (1 - r.anchor.y), l = m.height * -r.anchor.y), i[n] = a * d, i[n + 1] = l * p, i[n + s] = o * d, i[n + s + 1] = l * p, i[n + 2 * s] = o * d, i[n + 2 * s + 1] = h * p, i[n + 3 * s] = a * d, i[n + 3 * s + 1] = h * p, n += 4 * s
                        }
                    }
                    uploadPosition(e, t, r, i, s, n) {
                        for (let o = 0; o < r; o++) {
                            const r = e[t + o].position;
                            i[n] = r.x, i[n + 1] = r.y, i[n + s] = r.x, i[n + s + 1] = r.y, i[n + 2 * s] = r.x, i[n + 2 * s + 1] = r.y, i[n + 3 * s] = r.x, i[n + 3 * s + 1] = r.y, n += 4 * s
                        }
                    }
                    uploadRotation(e, t, r, i, s, n) {
                        for (let o = 0; o < r; o++) {
                            const r = e[t + o].rotation;
                            i[n] = r, i[n + s] = r, i[n + 2 * s] = r, i[n + 3 * s] = r, n += 4 * s
                        }
                    }
                    uploadUvs(e, t, r, i, s, n) {
                        for (let o = 0; o < r; ++o) {
                            const r = e[t + o]._texture._uvs;
                            r ? (i[n] = r.x0, i[n + 1] = r.y0, i[n + s] = r.x1, i[n + s + 1] = r.y1, i[n + 2 * s] = r.x2, i[n + 2 * s + 1] = r.y2, i[n + 3 * s] = r.x3, i[n + 3 * s + 1] = r.y3, n += 4 * s) : (i[n] = 0, i[n + 1] = 0, i[n + s] = 0, i[n + s + 1] = 0, i[n + 2 * s] = 0, i[n + 2 * s + 1] = 0, i[n + 3 * s] = 0, i[n + 3 * s + 1] = 0, n += 4 * s)
                        }
                    }
                    uploadTint(e, t, r, s, n, o) {
                        for (let a = 0; a < r; ++a) {
                            const r = e[t + a],
                                h = i.Color.shared.setValue(r._tintRGB).toPremultiplied(r.alpha);
                            s[o] = h, s[o + n] = h, s[o + 2 * n] = h, s[o + 3 * n] = h, o += 4 * n
                        }
                    }
                    destroy() {
                        super.destroy(), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null
                    }
                }
                a.extension = {
                    name: "particle",
                    type: i.ExtensionType.RendererPlugin
                }, i.extensions.add(a), t.ParticleRenderer = a
            },
            9212: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(5568),
                    s = r(8627);
                t.ParticleContainer = i.ParticleContainer, t.ParticleRenderer = s.ParticleRenderer
            },
            5723: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "varying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform sampler2D uSampler;\n\nvoid main(void){\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\n    gl_FragColor = color;\n}"
            },
            7130: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\n\nattribute vec2 aPositionCoord;\nattribute float aRotation;\n\nuniform mat3 translationMatrix;\nuniform vec4 uColor;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nvoid main(void){\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\n\n    vec2 v = vec2(x, y);\n    v = v + aPositionCoord;\n\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vColor = aColor * uColor;\n}\n"
            },
            5217: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(2781),
                    n = r(1418),
                    o = r(8968);

                function a(e, t) {
                    let r = !1;
                    if (e?._textures?.length)
                        for (let s = 0; s < e._textures.length; s++)
                            if (e._textures[s] instanceof i.Texture) {
                                const i = e._textures[s].baseTexture;
                                t.includes(i) || (t.push(i), r = !0)
                            } return r
                }

                function h(e, t) {
                    if (e.baseTexture instanceof i.BaseTexture) {
                        const r = e.baseTexture;
                        return t.includes(r) || t.push(r), !0
                    }
                    return !1
                }

                function l(e, t) {
                    if (e._texture && e._texture instanceof i.Texture) {
                        const r = e._texture.baseTexture;
                        return t.includes(r) || t.push(r), !0
                    }
                    return !1
                }

                function u(e, t) {
                    return t instanceof n.Text && (t.updateText(!0), !0)
                }

                function c(e, t) {
                    if (t instanceof n.TextStyle) {
                        const e = t.toFontString();
                        return n.TextMetrics.measureFont(e), !0
                    }
                    return !1
                }

                function d(e, t) {
                    if (e instanceof n.Text) {
                        t.includes(e.style) || t.push(e.style), t.includes(e) || t.push(e);
                        const r = e._texture.baseTexture;
                        return t.includes(r) || t.push(r), !0
                    }
                    return !1
                }

                function p(e, t) {
                    return e instanceof n.TextStyle && (t.includes(e) || t.push(e), !0)
                }
                const f = class {
                    constructor(e) {
                        this.limiter = new o.CountLimiter(f.uploadsPerFrame), this.renderer = e, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = () => {
                            this.queue && this.prepareItems()
                        }, this.registerFindHook(d), this.registerFindHook(p), this.registerFindHook(a), this.registerFindHook(h), this.registerFindHook(l), this.registerUploadHook(u), this.registerUploadHook(c)
                    }
                    upload(e) {
                        return new Promise((t => {
                            e && this.add(e), this.queue.length ? (this.completes.push(t), this.ticking || (this.ticking = !0, i.Ticker.system.addOnce(this.tick, this, i.UPDATE_PRIORITY.UTILITY))) : t()
                        }))
                    }
                    tick() {
                        setTimeout(this.delayedTick, 0)
                    }
                    prepareItems() {
                        for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload();) {
                            const e = this.queue[0];
                            let t = !1;
                            if (e && !e._destroyed)
                                for (let r = 0, i = this.uploadHooks.length; r < i; r++)
                                    if (this.uploadHooks[r](this.uploadHookHelper, e)) {
                                        this.queue.shift(), t = !0;
                                        break
                                    } t || this.queue.shift()
                        }
                        if (this.queue.length) i.Ticker.system.addOnce(this.tick, this, i.UPDATE_PRIORITY.UTILITY);
                        else {
                            this.ticking = !1;
                            const e = this.completes.slice(0);
                            this.completes.length = 0;
                            for (let t = 0, r = e.length; t < r; t++) e[t]()
                        }
                    }
                    registerFindHook(e) {
                        return e && this.addHooks.push(e), this
                    }
                    registerUploadHook(e) {
                        return e && this.uploadHooks.push(e), this
                    }
                    add(e) {
                        for (let t = 0, r = this.addHooks.length; t < r && !this.addHooks[t](e, this.queue); t++);
                        if (e instanceof s.Container)
                            for (let t = e.children.length - 1; t >= 0; t--) this.add(e.children[t]);
                        return this
                    }
                    destroy() {
                        this.ticking && i.Ticker.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null
                    }
                };
                let m = f;
                m.uploadsPerFrame = 4, t.BasePrepare = m
            },
            8968: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CountLimiter = class {
                    constructor(e) {
                        this.maxItemsPerFrame = e, this.itemsLeft = 0
                    }
                    beginFrame() {
                        this.itemsLeft = this.maxItemsPerFrame
                    }
                    allowedToUpload() {
                        return this.itemsLeft-- > 0
                    }
                }
            },
            585: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(4742),
                    n = r(5217);

                function o(e, t) {
                    return t instanceof i.BaseTexture && (t._glTextures[e.CONTEXT_UID] || e.texture.bind(t), !0)
                }

                function a(e, t) {
                    if (!(t instanceof s.Graphics)) return !1;
                    const {
                        geometry: r
                    } = t;
                    t.finishPoly(), r.updateBatches();
                    const {
                        batches: i
                    } = r;
                    for (let t = 0; t < i.length; t++) {
                        const {
                            texture: r
                        } = i[t].style;
                        r && o(e, r.baseTexture)
                    }
                    return r.batchable || e.geometry.bind(r, t._resolveDirectShader(e)), !0
                }

                function h(e, t) {
                    return e instanceof s.Graphics && (t.push(e), !0)
                }
                class l extends n.BasePrepare {
                    constructor(e) {
                        super(e), this.uploadHookHelper = this.renderer, this.registerFindHook(h), this.registerUploadHook(o), this.registerUploadHook(a)
                    }
                }
                l.extension = {
                    name: "prepare",
                    type: i.ExtensionType.RendererSystem
                }, i.extensions.add(l), t.Prepare = l
            },
            4626: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.TimeLimiter = class {
                    constructor(e) {
                        this.maxMilliseconds = e, this.frameStart = 0
                    }
                    beginFrame() {
                        this.frameStart = Date.now()
                    }
                    allowedToUpload() {
                        return Date.now() - this.frameStart < this.maxMilliseconds
                    }
                }
            },
            8642: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), r(7735);
                var i = r(5217),
                    s = r(8968),
                    n = r(585),
                    o = r(4626);
                t.BasePrepare = i.BasePrepare, t.CountLimiter = s.CountLimiter, t.Prepare = n.Prepare, t.TimeLimiter = o.TimeLimiter
            },
            7735: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(5217);
                Object.defineProperties(i.settings, {
                    UPLOADS_PER_FRAME: {
                        get: () => s.BasePrepare.uploadsPerFrame,
                        set(e) {
                            i.utils.deprecation("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame"), s.BasePrepare.uploadsPerFrame = e
                        }
                    }
                }), Object.defineProperty(t, "settings", {
                    enumerable: !0,
                    get: function() {
                        return i.settings
                    }
                })
            },
            8652: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                class r {
                    constructor(e) {
                        this.items = [], this._name = e, this._aliasCount = 0
                    }
                    emit(e, t, r, i, s, n, o, a) {
                        if (arguments.length > 8) throw new Error("max arguments reached");
                        const {
                            name: h,
                            items: l
                        } = this;
                        this._aliasCount++;
                        for (let u = 0, c = l.length; u < c; u++) l[u][h](e, t, r, i, s, n, o, a);
                        return l === this.items && this._aliasCount--, this
                    }
                    ensureNonAliasedItems() {
                        this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0))
                    }
                    add(e) {
                        return e[this._name] && (this.ensureNonAliasedItems(), this.remove(e), this.items.push(e)), this
                    }
                    remove(e) {
                        const t = this.items.indexOf(e);
                        return -1 !== t && (this.ensureNonAliasedItems(), this.items.splice(t, 1)), this
                    }
                    contains(e) {
                        return this.items.includes(e)
                    }
                    removeAll() {
                        return this.ensureNonAliasedItems(), this.items.length = 0, this
                    }
                    destroy() {
                        this.removeAll(), this.items = null, this._name = null
                    }
                    get empty() {
                        return 0 === this.items.length
                    }
                    get name() {
                        return this._name
                    }
                }
                Object.defineProperties(r.prototype, {
                    dispatch: {
                        value: r.prototype.emit
                    },
                    run: {
                        value: r.prototype.emit
                    }
                }), t.Runner = r
            },
            5802: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(8652);
                t.Runner = i.Runner
            },
            7637: () => {},
            5479: () => {},
            6301: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const r = {
                    createCanvas: (e, t) => {
                        const r = document.createElement("canvas");
                        return r.width = e, r.height = t, r
                    },
                    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
                    getWebGLRenderingContext: () => WebGLRenderingContext,
                    getNavigator: () => navigator,
                    getBaseUrl: () => document.baseURI ?? window.location.href,
                    getFontFaceSet: () => document.fonts,
                    fetch: (e, t) => fetch(e, t),
                    parseXML: e => (new DOMParser).parseFromString(e, "text/xml")
                };
                t.BrowserAdapter = r
            },
            6667: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(6301);
                r(7637), r(5479);
                var s = r(9291),
                    n = r(7811);
                t.BrowserAdapter = i.BrowserAdapter, t.settings = s.settings, t.isMobile = n.isMobile
            },
            9291: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const i = {
                    ADAPTER: r(6301).BrowserAdapter,
                    RESOLUTION: 1,
                    CREATE_IMAGE_BITMAP: !1,
                    ROUND_PIXELS: !1
                };
                t.settings = i
            },
            7811: (e, t, r) => {
                "use strict";

                function i(e) {
                    return e && "object" == typeof e && "default" in e ? e : {
                        default: e
                    }
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var s = i(r(891));
                const n = (s.default.default ?? s.default)(globalThis.navigator);
                t.isMobile = n
            },
            8932: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(2517);
                class n extends s.Sprite {
                    constructor(e, t = !0) {
                        super(e[0] instanceof i.Texture ? e[0] : e[0].texture), this._textures = null, this._durations = null, this._autoUpdate = t, this._isConnectedToTicker = !1, this.animationSpeed = 1, this.loop = !0, this.updateAnchor = !1, this.onComplete = null, this.onFrameChange = null, this.onLoop = null, this._currentTime = 0, this._playing = !1, this._previousFrame = null, this.textures = e
                    }
                    stop() {
                        this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (i.Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1))
                    }
                    play() {
                        this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (i.Ticker.shared.add(this.update, this, i.UPDATE_PRIORITY.HIGH), this._isConnectedToTicker = !0))
                    }
                    gotoAndStop(e) {
                        this.stop(), this.currentFrame = e
                    }
                    gotoAndPlay(e) {
                        this.currentFrame = e, this.play()
                    }
                    update(e) {
                        if (!this._playing) return;
                        const t = this.animationSpeed * e,
                            r = this.currentFrame;
                        if (null !== this._durations) {
                            let r = this._currentTime % 1 * this._durations[this.currentFrame];
                            for (r += t / 60 * 1e3; r < 0;) this._currentTime--, r += this._durations[this.currentFrame];
                            const i = Math.sign(this.animationSpeed * e);
                            for (this._currentTime = Math.floor(this._currentTime); r >= this._durations[this.currentFrame];) r -= this._durations[this.currentFrame] * i, this._currentTime += i;
                            this._currentTime += r / this._durations[this.currentFrame]
                        } else this._currentTime += t;
                        this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : r !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < r || this.animationSpeed < 0 && this.currentFrame > r) && this.onLoop(), this.updateTexture())
                    }
                    updateTexture() {
                        const e = this.currentFrame;
                        this._previousFrame !== e && (this._previousFrame = e, this._texture = this._textures[e], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame))
                    }
                    destroy(e) {
                        this.stop(), super.destroy(e), this.onComplete = null, this.onFrameChange = null, this.onLoop = null
                    }
                    static fromFrames(e) {
                        const t = [];
                        for (let r = 0; r < e.length; ++r) t.push(i.Texture.from(e[r]));
                        return new n(t)
                    }
                    static fromImages(e) {
                        const t = [];
                        for (let r = 0; r < e.length; ++r) t.push(i.Texture.from(e[r]));
                        return new n(t)
                    }
                    get totalFrames() {
                        return this._textures.length
                    }
                    get textures() {
                        return this._textures
                    }
                    set textures(e) {
                        if (e[0] instanceof i.Texture) this._textures = e, this._durations = null;
                        else {
                            this._textures = [], this._durations = [];
                            for (let t = 0; t < e.length; t++) this._textures.push(e[t].texture), this._durations.push(e[t].time)
                        }
                        this._previousFrame = null, this.gotoAndStop(0), this.updateTexture()
                    }
                    get currentFrame() {
                        let e = Math.floor(this._currentTime) % this._textures.length;
                        return e < 0 && (e += this._textures.length), e
                    }
                    set currentFrame(e) {
                        if (e < 0 || e > this.totalFrames - 1) throw new Error(`[AnimatedSprite]: Invalid frame index value ${e}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
                        const t = this.currentFrame;
                        this._currentTime = e, t !== this.currentFrame && this.updateTexture()
                    }
                    get playing() {
                        return this._playing
                    }
                    get autoUpdate() {
                        return this._autoUpdate
                    }
                    set autoUpdate(e) {
                        e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (i.Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (i.Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0))
                    }
                }
                t.AnimatedSprite = n
            },
            9189: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(8932);
                t.AnimatedSprite = i.AnimatedSprite
            },
            7103: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(2517);
                const n = new i.Point;
                class o extends s.Sprite {
                    constructor(e, t = 100, r = 100) {
                        super(e), this.tileTransform = new i.Transform, this._width = t, this._height = r, this.uvMatrix = this.texture.uvMatrix || new i.TextureMatrix(e), this.pluginName = "tilingSprite", this.uvRespectAnchor = !1
                    }
                    get clampMargin() {
                        return this.uvMatrix.clampMargin
                    }
                    set clampMargin(e) {
                        this.uvMatrix.clampMargin = e, this.uvMatrix.update(!0)
                    }
                    get tileScale() {
                        return this.tileTransform.scale
                    }
                    set tileScale(e) {
                        this.tileTransform.scale.copyFrom(e)
                    }
                    get tilePosition() {
                        return this.tileTransform.position
                    }
                    set tilePosition(e) {
                        this.tileTransform.position.copyFrom(e)
                    }
                    _onTextureUpdate() {
                        this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215
                    }
                    _render(e) {
                        const t = this._texture;
                        t && t.valid && (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this))
                    }
                    _calculateBounds() {
                        const e = this._width * -this._anchor._x,
                            t = this._height * -this._anchor._y,
                            r = this._width * (1 - this._anchor._x),
                            i = this._height * (1 - this._anchor._y);
                        this._bounds.addFrame(this.transform, e, t, r, i)
                    }
                    getLocalBounds(e) {
                        return 0 === this.children.length ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new i.Rectangle), e = this._localBoundsRect), this._bounds.getRectangle(e)) : super.getLocalBounds.call(this, e)
                    }
                    containsPoint(e) {
                        this.worldTransform.applyInverse(e, n);
                        const t = this._width,
                            r = this._height,
                            i = -t * this.anchor._x;
                        if (n.x >= i && n.x < i + t) {
                            const e = -r * this.anchor._y;
                            if (n.y >= e && n.y < e + r) return !0
                        }
                        return !1
                    }
                    destroy(e) {
                        super.destroy(e), this.tileTransform = null, this.uvMatrix = null
                    }
                    static from(e, t) {
                        const r = e instanceof i.Texture ? e : i.Texture.from(e, t);
                        return new o(r, t.width, t.height)
                    }
                    get width() {
                        return this._width
                    }
                    set width(e) {
                        this._width = e
                    }
                    get height() {
                        return this._height
                    }
                    set height(e) {
                        this._height = e
                    }
                }
                t.TilingSprite = o
            },
            4494: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(4794),
                    n = r(2526),
                    o = r(5941),
                    a = r(4910),
                    h = r(7545);
                const l = new i.Matrix;
                class u extends i.ObjectRenderer {
                    constructor(e) {
                        super(e), e.runners.contextChange.add(this), this.quad = new i.QuadUv, this.state = i.State.for2d()
                    }
                    contextChange() {
                        const e = this.renderer,
                            t = {
                                globals: e.globalUniforms
                            };
                        this.simpleShader = i.Shader.from(a.default, h.default, t), this.shader = e.context.webGLVersion > 1 ? i.Shader.from(n.default, s.default, t) : i.Shader.from(a.default, o.default, t)
                    }
                    render(e) {
                        const t = this.renderer,
                            r = this.quad;
                        let s = r.vertices;
                        s[0] = s[6] = e._width * -e.anchor.x, s[1] = s[3] = e._height * -e.anchor.y, s[2] = s[4] = e._width * (1 - e.anchor.x), s[5] = s[7] = e._height * (1 - e.anchor.y);
                        const n = e.uvRespectAnchor ? e.anchor.x : 0,
                            o = e.uvRespectAnchor ? e.anchor.y : 0;
                        s = r.uvs, s[0] = s[6] = -n, s[1] = s[3] = -o, s[2] = s[4] = 1 - n, s[5] = s[7] = 1 - o, r.invalidate();
                        const a = e._texture,
                            h = a.baseTexture,
                            u = h.alphaMode > 0,
                            c = e.tileTransform.localTransform,
                            d = e.uvMatrix;
                        let p = h.isPowerOfTwo && a.frame.width === h.width && a.frame.height === h.height;
                        p && (h._glTextures[t.CONTEXT_UID] ? p = h.wrapMode !== i.WRAP_MODES.CLAMP : h.wrapMode === i.WRAP_MODES.CLAMP && (h.wrapMode = i.WRAP_MODES.REPEAT));
                        const f = p ? this.simpleShader : this.shader,
                            m = a.width,
                            g = a.height,
                            y = e._width,
                            _ = e._height;
                        l.set(c.a * m / y, c.b * m / _, c.c * g / y, c.d * g / _, c.tx / y, c.ty / _), l.invert(), p ? l.prepend(d.mapCoord) : (f.uniforms.uMapCoord = d.mapCoord.toArray(!0), f.uniforms.uClampFrame = d.uClampFrame, f.uniforms.uClampOffset = d.uClampOffset), f.uniforms.uTransform = l.toArray(!0), f.uniforms.uColor = i.Color.shared.setValue(e.tint).premultiply(e.worldAlpha, u).toArray(f.uniforms.uColor), f.uniforms.translationMatrix = e.transform.worldTransform.toArray(!0), f.uniforms.uSampler = a, t.shader.bind(f), t.geometry.bind(r), this.state.blendMode = i.utils.correctBlendMode(e.blendMode, u), t.state.set(this.state), t.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0)
                    }
                }
                u.extension = {
                    name: "tilingSprite",
                    type: i.ExtensionType.RendererPlugin
                }, i.extensions.add(u), t.TilingSpriteRenderer = u
            },
            1198: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7103),
                    s = r(4494);
                t.TilingSprite = i.TilingSprite, t.TilingSpriteRenderer = s.TilingSpriteRenderer
            },
            5941: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "#version 100\n#ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n#endif\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    #ifdef GL_EXT_shader_texture_lod\n        vec4 texSample = unclamped == coord\n            ? texture2D(uSampler, coord) \n            : texture2DLodEXT(uSampler, coord, 0);\n    #else\n        vec4 texSample = texture2D(uSampler, coord);\n    #endif\n\n    gl_FragColor = texSample * uColor;\n}\n"
            },
            4910: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "#version 100\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n"
            },
            7545: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "#version 100\n#define SHADER_NAME Tiling-Sprite-Simple-100\n\nprecision lowp float;\n\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\n    gl_FragColor = texSample * uColor;\n}\n"
            },
            4794: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-100\n\nprecision lowp float;\n\nin vec2 vTextureCoord;\n\nout vec4 fragmentColor;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    vec2 unclamped = coord;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0\n\n    fragmentColor = texSample * uColor;\n}\n"
            },
            2526: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "#version 300 es\n#define SHADER_NAME Tiling-Sprite-300\n\nprecision lowp float;\n\nin vec2 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nout vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n"
            },
            7124: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(2781);
                const n = new i.Point,
                    o = new Uint16Array([0, 1, 2, 0, 2, 3]);
                class a extends s.Container {
                    constructor(e) {
                        super(), this._anchor = new i.ObservablePoint(this._onAnchorUpdate, this, e ? e.defaultAnchor.x : 0, e ? e.defaultAnchor.y : 0), this._texture = null, this._width = 0, this._height = 0, this._tintColor = new i.Color(16777215), this._tintRGB = null, this.tint = 16777215, this.blendMode = i.BLEND_MODES.NORMAL, this._cachedTint = 16777215, this.uvs = null, this.texture = e || i.Texture.EMPTY, this.vertexData = new Float32Array(8), this.vertexTrimmedData = null, this._transformID = -1, this._textureID = -1, this._transformTrimmedID = -1, this._textureTrimmedID = -1, this.indices = o, this.pluginName = "batch", this.isSprite = !0, this._roundPixels = i.settings.ROUND_PIXELS
                    }
                    _onTextureUpdate() {
                        this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = i.utils.sign(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = i.utils.sign(this.scale.y) * this._height / this._texture.orig.height)
                    }
                    _onAnchorUpdate() {
                        this._transformID = -1, this._transformTrimmedID = -1
                    }
                    calculateVertices() {
                        const e = this._texture;
                        if (this._transformID === this.transform._worldID && this._textureID === e._updateID) return;
                        this._textureID !== e._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = e._updateID;
                        const t = this.transform.worldTransform,
                            r = t.a,
                            s = t.b,
                            n = t.c,
                            o = t.d,
                            a = t.tx,
                            h = t.ty,
                            l = this.vertexData,
                            u = e.trim,
                            c = e.orig,
                            d = this._anchor;
                        let p = 0,
                            f = 0,
                            m = 0,
                            g = 0;
                        if (u ? (f = u.x - d._x * c.width, p = f + u.width, g = u.y - d._y * c.height, m = g + u.height) : (f = -d._x * c.width, p = f + c.width, g = -d._y * c.height, m = g + c.height), l[0] = r * f + n * g + a, l[1] = o * g + s * f + h, l[2] = r * p + n * g + a, l[3] = o * g + s * p + h, l[4] = r * p + n * m + a, l[5] = o * m + s * p + h, l[6] = r * f + n * m + a, l[7] = o * m + s * f + h, this._roundPixels) {
                            const e = i.settings.RESOLUTION;
                            for (let t = 0; t < l.length; ++t) l[t] = Math.round(l[t] * e) / e
                        }
                    }
                    calculateTrimmedVertices() {
                        if (this.vertexTrimmedData) {
                            if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) return
                        } else this.vertexTrimmedData = new Float32Array(8);
                        this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
                        const e = this._texture,
                            t = this.vertexTrimmedData,
                            r = e.orig,
                            i = this._anchor,
                            s = this.transform.worldTransform,
                            n = s.a,
                            o = s.b,
                            a = s.c,
                            h = s.d,
                            l = s.tx,
                            u = s.ty,
                            c = -i._x * r.width,
                            d = c + r.width,
                            p = -i._y * r.height,
                            f = p + r.height;
                        t[0] = n * c + a * p + l, t[1] = h * p + o * c + u, t[2] = n * d + a * p + l, t[3] = h * p + o * d + u, t[4] = n * d + a * f + l, t[5] = h * f + o * d + u, t[6] = n * c + a * f + l, t[7] = h * f + o * c + u
                    }
                    _render(e) {
                        this.calculateVertices(), e.batch.setObjectRenderer(e.plugins[this.pluginName]), e.plugins[this.pluginName].render(this)
                    }
                    _calculateBounds() {
                        const e = this._texture.trim,
                            t = this._texture.orig;
                        !e || e.width === t.width && e.height === t.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData))
                    }
                    getLocalBounds(e) {
                        return 0 === this.children.length ? (this._localBounds || (this._localBounds = new s.Bounds), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), e || (this._localBoundsRect || (this._localBoundsRect = new i.Rectangle), e = this._localBoundsRect), this._localBounds.getRectangle(e)) : super.getLocalBounds.call(this, e)
                    }
                    containsPoint(e) {
                        this.worldTransform.applyInverse(e, n);
                        const t = this._texture.orig.width,
                            r = this._texture.orig.height,
                            i = -t * this.anchor.x;
                        let s = 0;
                        return n.x >= i && n.x < i + t && (s = -r * this.anchor.y, n.y >= s && n.y < s + r)
                    }
                    destroy(e) {
                        if (super.destroy(e), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null, "boolean" == typeof e ? e : e?.texture) {
                            const t = "boolean" == typeof e ? e : e?.baseTexture;
                            this._texture.destroy(!!t)
                        }
                        this._texture = null
                    }
                    static from(e, t) {
                        const r = e instanceof i.Texture ? e : i.Texture.from(e, t);
                        return new a(r)
                    }
                    set roundPixels(e) {
                        this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e
                    }
                    get roundPixels() {
                        return this._roundPixels
                    }
                    get width() {
                        return Math.abs(this.scale.x) * this._texture.orig.width
                    }
                    set width(e) {
                        const t = i.utils.sign(this.scale.x) || 1;
                        this.scale.x = t * e / this._texture.orig.width, this._width = e
                    }
                    get height() {
                        return Math.abs(this.scale.y) * this._texture.orig.height
                    }
                    set height(e) {
                        const t = i.utils.sign(this.scale.y) || 1;
                        this.scale.y = t * e / this._texture.orig.height, this._height = e
                    }
                    get anchor() {
                        return this._anchor
                    }
                    set anchor(e) {
                        this._anchor.copyFrom(e)
                    }
                    get tint() {
                        return this._tintColor.value
                    }
                    set tint(e) {
                        this._tintColor.setValue(e), this._tintRGB = this._tintColor.toLittleEndianNumber()
                    }
                    get tintValue() {
                        return this._tintColor.toNumber()
                    }
                    get texture() {
                        return this._texture
                    }
                    set texture(e) {
                        this._texture !== e && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = e || i.Texture.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, e && (e.baseTexture.valid ? this._onTextureUpdate() : e.once("update", this._onTextureUpdate, this)))
                    }
                }
                t.Sprite = a
            },
            2517: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7124);
                t.Sprite = i.Sprite
            },
            285: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                const s = class {
                    constructor(e, t, r = null) {
                        this.linkedSheets = [], this._texture = e instanceof i.Texture ? e : null, this.baseTexture = e instanceof i.BaseTexture ? e : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = t;
                        const s = this.baseTexture.resource;
                        this.resolution = this._updateResolution(r || (s ? s.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null
                    }
                    _updateResolution(e = null) {
                        const {
                            scale: t
                        } = this.data.meta;
                        let r = i.utils.getResolutionOfUrl(e, null);
                        return null === r && (r = parseFloat(t ?? "1")), 1 !== r && this.baseTexture.setResolution(r), r
                    }
                    parse() {
                        return new Promise((e => {
                            this._callback = e, this._batchIndex = 0, this._frameKeys.length <= s.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch()
                        }))
                    }
                    _processFrames(e) {
                        let t = e;
                        const r = s.BATCH_SIZE;
                        for (; t - e < r && t < this._frameKeys.length;) {
                            const e = this._frameKeys[t],
                                r = this._frames[e],
                                s = r.frame;
                            if (s) {
                                let t = null,
                                    n = null;
                                const o = !1 !== r.trimmed && r.sourceSize ? r.sourceSize : r.frame,
                                    a = new i.Rectangle(0, 0, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution);
                                t = r.rotated ? new i.Rectangle(Math.floor(s.x) / this.resolution, Math.floor(s.y) / this.resolution, Math.floor(s.h) / this.resolution, Math.floor(s.w) / this.resolution) : new i.Rectangle(Math.floor(s.x) / this.resolution, Math.floor(s.y) / this.resolution, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution), !1 !== r.trimmed && r.spriteSourceSize && (n = new i.Rectangle(Math.floor(r.spriteSourceSize.x) / this.resolution, Math.floor(r.spriteSourceSize.y) / this.resolution, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution)), this.textures[e] = new i.Texture(this.baseTexture, t, a, n, r.rotated ? 2 : 0, r.anchor, r.borders), i.Texture.addToCache(this.textures[e], e)
                            }
                            t++
                        }
                    }
                    _processAnimations() {
                        const e = this.data.animations || {};
                        for (const t in e) {
                            this.animations[t] = [];
                            for (let r = 0; r < e[t].length; r++) {
                                const i = e[t][r];
                                this.animations[t].push(this.textures[i])
                            }
                        }
                    }
                    _parseComplete() {
                        const e = this._callback;
                        this._callback = null, this._batchIndex = 0, e.call(this, this.textures)
                    }
                    _nextBatch() {
                        this._processFrames(this._batchIndex * s.BATCH_SIZE), this._batchIndex++, setTimeout((() => {
                            this._batchIndex * s.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete())
                        }), 0)
                    }
                    destroy(e = !1) {
                        for (const e in this.textures) this.textures[e].destroy();
                        this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, e && (this._texture?.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = []
                    }
                };
                let n = s;
                n.BATCH_SIZE = 1e3, t.Spritesheet = n
            },
            7551: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(285),
                    s = r(5700);
                t.Spritesheet = i.Spritesheet, t.spritesheetAsset = s.spritesheetAsset
            },
            5700: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(4645),
                    s = r(7163),
                    n = r(285);
                const o = ["jpg", "png", "jpeg", "avif", "webp"];

                function a(e, t, r) {
                    const i = {};
                    if (e.forEach((e => {
                            i[e] = t
                        })), Object.keys(t.textures).forEach((e => {
                            i[e] = t.textures[e]
                        })), !r) {
                        const r = s.utils.path.dirname(e[0]);
                        t.linkedSheets.forEach(((e, s) => {
                            const n = a([`${r}/${t.data.meta.related_multi_packs[s]}`], e, !0);
                            Object.assign(i, n)
                        }))
                    }
                    return i
                }
                const h = {
                    extension: s.ExtensionType.Asset,
                    cache: {
                        test: e => e instanceof n.Spritesheet,
                        getCacheableAssets: (e, t) => a(e, t, !1)
                    },
                    resolver: {
                        test: e => {
                            const t = e.split("?")[0].split("."),
                                r = t.pop(),
                                i = t.pop();
                            return "json" === r && o.includes(i)
                        },
                        parse: e => {
                            const t = e.split(".");
                            return {
                                resolution: parseFloat(s.settings.RETINA_PREFIX.exec(e)?.[1] ?? "1"),
                                format: t[t.length - 2],
                                src: e
                            }
                        }
                    },
                    loader: {
                        name: "spritesheetLoader",
                        extension: {
                            type: s.ExtensionType.LoadParser,
                            priority: i.LoaderParserPriority.Normal
                        },
                        testParse: async (e, t) => ".json" === s.utils.path.extname(t.src).toLowerCase() && !!e.frames,
                        async parse(e, t, r) {
                            let o = s.utils.path.dirname(t.src);
                            o && o.lastIndexOf("/") !== o.length - 1 && (o += "/");
                            let a = o + e.meta.image;
                            a = i.copySearchParams(a, t.src);
                            const h = (await r.load([a]))[a],
                                l = new n.Spritesheet(h.baseTexture, e, t.src);
                            await l.parse();
                            const u = e?.meta?.related_multi_packs;
                            if (Array.isArray(u)) {
                                const e = [];
                                for (const s of u) {
                                    if ("string" != typeof s) continue;
                                    let n = o + s;
                                    t.data?.ignoreMultiPack || (n = i.copySearchParams(n, t.src), e.push(r.load({
                                        src: n,
                                        data: {
                                            ignoreMultiPack: !0
                                        }
                                    })))
                                }
                                const s = await Promise.all(e);
                                l.linkedSheets = s, s.forEach((e => {
                                    e.linkedSheets = [l].concat(l.linkedSheets.filter((t => t !== e)))
                                }))
                            }
                            return l
                        },
                        unload(e) {
                            e.destroy(!0)
                        }
                    }
                };
                s.extensions.add(h), t.spritesheetAsset = h
            },
            1416: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(1418),
                    n = r(1855),
                    o = r(6315);
                r(9713);
                var a = r(5420),
                    h = r(4191),
                    l = r(7068);
                const u = class {
                    constructor(e, t, r) {
                        const [s] = e.info, [n] = e.common, [o] = e.page, [a] = e.distanceField, h = i.utils.getResolutionOfUrl(o.file), l = {};
                        this._ownsTextures = r, this.font = s.face, this.size = s.size, this.lineHeight = n.lineHeight / h, this.chars = {}, this.pageTextures = l;
                        for (let r = 0; r < e.page.length; r++) {
                            const {
                                id: s,
                                file: n
                            } = e.page[r];
                            l[s] = t instanceof Array ? t[r] : t[n], a?.fieldType && "none" !== a.fieldType && (l[s].baseTexture.alphaMode = i.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA, l[s].baseTexture.mipmap = i.MIPMAP_MODES.OFF)
                        }
                        for (let t = 0; t < e.char.length; t++) {
                            const {
                                id: r,
                                page: s
                            } = e.char[t];
                            let {
                                x: n,
                                y: o,
                                width: a,
                                height: u,
                                xoffset: c,
                                yoffset: d,
                                xadvance: p
                            } = e.char[t];
                            n /= h, o /= h, a /= h, u /= h, c /= h, d /= h, p /= h;
                            const f = new i.Rectangle(n + l[s].frame.x / h, o + l[s].frame.y / h, a, u);
                            this.chars[r] = {
                                xOffset: c,
                                yOffset: d,
                                xAdvance: p,
                                kerning: {},
                                texture: new i.Texture(l[s].baseTexture, f),
                                page: s
                            }
                        }
                        for (let t = 0; t < e.kerning.length; t++) {
                            let {
                                first: r,
                                second: i,
                                amount: s
                            } = e.kerning[t];
                            r /= h, i /= h, s /= h, this.chars[i] && (this.chars[i].kerning[r] = s)
                        }
                        this.distanceFieldRange = a?.distanceRange, this.distanceFieldType = a?.fieldType?.toLowerCase() ?? "none"
                    }
                    destroy() {
                        for (const e in this.chars) this.chars[e].texture.destroy(), this.chars[e].texture = null;
                        for (const e in this.pageTextures) this._ownsTextures && this.pageTextures[e].destroy(!0), this.pageTextures[e] = null;
                        this.chars = null, this.pageTextures = null
                    }
                    static install(e, t, r) {
                        let s;
                        if (e instanceof n.BitmapFontData) s = e;
                        else {
                            const t = o.autoDetectFormat(e);
                            if (!t) throw new Error("Unrecognized data format for font.");
                            s = t.parse(e)
                        }
                        t instanceof i.Texture && (t = [t]);
                        const a = new u(s, t, r);
                        return u.available[a.font] = a, a
                    }
                    static uninstall(e) {
                        const t = u.available[e];
                        if (!t) throw new Error(`No font found named '${e}'`);
                        t.destroy(), delete u.available[e]
                    }
                    static from(e, t, r) {
                        if (!e) throw new Error("[BitmapFont] Property `name` is required.");
                        const {
                            chars: o,
                            padding: c,
                            resolution: d,
                            textureWidth: p,
                            textureHeight: f,
                            ...m
                        } = Object.assign({}, u.defaultOptions, r), g = a.resolveCharacters(o), y = t instanceof s.TextStyle ? t : new s.TextStyle(t), _ = p, v = new n.BitmapFontData;
                        v.info[0] = {
                            face: y.fontFamily,
                            size: y.fontSize
                        }, v.common[0] = {
                            lineHeight: y.fontSize
                        };
                        let S, T, b, E = 0,
                            x = 0,
                            w = 0;
                        const O = [],
                            A = [];
                        for (let e = 0; e < g.length; e++) {
                            S || (S = i.settings.ADAPTER.createCanvas(), S.width = p, S.height = f, T = S.getContext("2d"), b = new i.BaseTexture(S, {
                                resolution: d,
                                ...m
                            }), O.push(b), A.push(new i.Texture(b)), v.page.push({
                                id: A.length - 1,
                                file: ""
                            }));
                            const t = g[e],
                                r = s.TextMetrics.measureText(t, y, !1, S),
                                n = r.width,
                                o = Math.ceil(r.height),
                                a = Math.ceil(("italic" === y.fontStyle ? 2 : 1) * n);
                            if (x >= f - o * d) {
                                if (0 === x) throw new Error(`[BitmapFont] textureHeight ${f}px is too small (fontFamily: '${y.fontFamily}', fontSize: ${y.fontSize}px, char: '${t}')`);
                                --e, S = null, T = null, b = null, x = 0, E = 0, w = 0;
                                continue
                            }
                            if (w = Math.max(o + r.fontProperties.descent, w), a * d + E >= _) {
                                if (0 === E) throw new Error(`[BitmapFont] textureWidth ${p}px is too small (fontFamily: '${y.fontFamily}', fontSize: ${y.fontSize}px, char: '${t}')`);
                                --e, x += w * d, x = Math.ceil(x), E = 0, w = 0;
                                continue
                            }
                            h.drawGlyph(S, T, r, E, x, d, y);
                            const u = l.extractCharCode(r.text);
                            v.char.push({
                                id: u,
                                page: A.length - 1,
                                x: E / d,
                                y: x / d,
                                width: a,
                                height: o,
                                xoffset: 0,
                                yoffset: 0,
                                xadvance: n - (y.dropShadow ? y.dropShadowDistance : 0) - (y.stroke ? y.strokeThickness : 0)
                            }), E += (a + 2 * c) * d, E = Math.ceil(E)
                        }
                        for (let e = 0, t = g.length; e < t; e++) {
                            const r = g[e];
                            for (let e = 0; e < t; e++) {
                                const t = g[e],
                                    i = T.measureText(r).width,
                                    s = T.measureText(t).width,
                                    n = T.measureText(r + t).width - (i + s);
                                n && v.kerning.push({
                                    first: l.extractCharCode(r),
                                    second: l.extractCharCode(t),
                                    amount: n
                                })
                            }
                        }
                        const P = new u(v, A, !0);
                        return void 0 !== u.available[e] && u.uninstall(e), u.available[e] = P, P
                    }
                };
                let c = u;
                c.ALPHA = [
                    ["a", "z"],
                    ["A", "Z"], " "
                ], c.NUMERIC = [
                    ["0", "9"]
                ], c.ALPHANUMERIC = [
                    ["a", "z"],
                    ["A", "Z"],
                    ["0", "9"], " "
                ], c.ASCII = [
                    [" ", "~"]
                ], c.defaultOptions = {
                    resolution: 1,
                    textureWidth: 512,
                    textureHeight: 512,
                    padding: 4,
                    chars: u.ALPHANUMERIC
                }, c.available = {}, t.BitmapFont = c
            },
            1855: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.BitmapFontData = class {
                    constructor() {
                        this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = []
                    }
                }
            },
            3751: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(2781),
                    n = r(1917),
                    o = r(1416),
                    a = r(7783),
                    h = r(8396);
                r(9713);
                var l = r(1560),
                    u = r(7068);
                const c = [],
                    d = [],
                    p = [],
                    f = class extends s.Container {
                        constructor(e, t = {}) {
                            super();
                            const {
                                align: r,
                                tint: s,
                                maxWidth: n,
                                letterSpacing: a,
                                fontName: h,
                                fontSize: l
                            } = Object.assign({}, f.styleDefaults, t);
                            if (!o.BitmapFont.available[h]) throw new Error(`Missing BitmapFont "${h}"`);
                            this._activePagesMeshData = [], this._textWidth = 0, this._textHeight = 0, this._align = r, this._tintColor = new i.Color(s), this._font = void 0, this._fontName = h, this._fontSize = l, this.text = e, this._maxWidth = n, this._maxLineHeight = 0, this._letterSpacing = a, this._anchor = new i.ObservablePoint((() => {
                                this.dirty = !0
                            }), this, 0, 0), this._roundPixels = i.settings.ROUND_PIXELS, this.dirty = !0, this._resolution = i.settings.RESOLUTION, this._autoResolution = !0, this._textureCache = {}
                        }
                        updateText() {
                            const e = o.BitmapFont.available[this._fontName],
                                t = this.fontSize,
                                r = t / e.size,
                                s = new i.Point,
                                f = [],
                                m = [],
                                g = [],
                                y = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ",
                                _ = l.splitTextToCharacters(y),
                                v = this._maxWidth * e.size / t,
                                S = "none" === e.distanceFieldType ? c : d;
                            let T = null,
                                b = 0,
                                E = 0,
                                x = 0,
                                w = -1,
                                O = 0,
                                A = 0,
                                P = 0,
                                M = 0;
                            for (let t = 0; t < _.length; t++) {
                                const r = _[t],
                                    n = u.extractCharCode(r);
                                if (/(?:\s)/.test(r) && (w = t, O = b, M++), "\r" === r || "\n" === r) {
                                    m.push(b), g.push(-1), E = Math.max(E, b), ++x, ++A, s.x = 0, s.y += e.lineHeight, T = null, M = 0;
                                    continue
                                }
                                const o = e.chars[n];
                                if (!o) continue;
                                T && o.kerning[T] && (s.x += o.kerning[T]);
                                const a = p.pop() || {
                                    texture: i.Texture.EMPTY,
                                    line: 0,
                                    charCode: 0,
                                    prevSpaces: 0,
                                    position: new i.Point
                                };
                                a.texture = o.texture, a.line = x, a.charCode = n, a.position.x = Math.round(s.x + o.xOffset + this._letterSpacing / 2), a.position.y = Math.round(s.y + o.yOffset), a.prevSpaces = M, f.push(a), b = a.position.x + Math.max(o.xAdvance - o.xOffset, o.texture.orig.width), s.x += o.xAdvance + this._letterSpacing, P = Math.max(P, o.yOffset + o.texture.height), T = n, -1 !== w && v > 0 && s.x > v && (++A, i.utils.removeItems(f, 1 + w - A, 1 + t - w), t = w, w = -1, m.push(O), g.push(f.length > 0 ? f[f.length - 1].prevSpaces : 0), E = Math.max(E, O), x++, s.x = 0, s.y += e.lineHeight, T = null, M = 0)
                            }
                            const C = _[_.length - 1];
                            "\r" !== C && "\n" !== C && (/(?:\s)/.test(C) && (b = O), m.push(b), E = Math.max(E, b), g.push(-1));
                            const R = [];
                            for (let e = 0; e <= x; e++) {
                                let t = 0;
                                "right" === this._align ? t = E - m[e] : "center" === this._align ? t = (E - m[e]) / 2 : "justify" === this._align && (t = g[e] < 0 ? 0 : (E - m[e]) / g[e]), R.push(t)
                            }
                            const I = f.length,
                                B = {},
                                D = [],
                                H = this._activePagesMeshData;
                            S.push(...H);
                            for (let t = 0; t < I; t++) {
                                const r = f[t].texture,
                                    s = r.baseTexture.uid;
                                if (!B[s]) {
                                    let t = S.pop();
                                    if (!t) {
                                        const r = new n.MeshGeometry;
                                        let s, o;
                                        "none" === e.distanceFieldType ? (s = new n.MeshMaterial(i.Texture.EMPTY), o = i.BLEND_MODES.NORMAL) : (s = new n.MeshMaterial(i.Texture.EMPTY, {
                                            program: i.Program.from(h.default, a.default),
                                            uniforms: {
                                                uFWidth: 0
                                            }
                                        }), o = i.BLEND_MODES.NORMAL_NPM);
                                        const l = new n.Mesh(r, s);
                                        l.blendMode = o, t = {
                                            index: 0,
                                            indexCount: 0,
                                            vertexCount: 0,
                                            uvsCount: 0,
                                            total: 0,
                                            mesh: l,
                                            vertices: null,
                                            uvs: null,
                                            indices: null
                                        }
                                    }
                                    t.index = 0, t.indexCount = 0, t.vertexCount = 0, t.uvsCount = 0, t.total = 0;
                                    const {
                                        _textureCache: o
                                    } = this;
                                    o[s] = o[s] || new i.Texture(r.baseTexture), t.mesh.texture = o[s], t.mesh.tint = this._tintColor.value, D.push(t), B[s] = t
                                }
                                B[s].total++
                            }
                            for (let e = 0; e < H.length; e++) D.includes(H[e]) || this.removeChild(H[e].mesh);
                            for (let e = 0; e < D.length; e++) D[e].mesh.parent !== this && this.addChild(D[e].mesh);
                            this._activePagesMeshData = D;
                            for (const e in B) {
                                const t = B[e],
                                    r = t.total;
                                if (!(t.indices?.length > 6 * r) || t.vertices.length < 2 * n.Mesh.BATCHABLE_SIZE) t.vertices = new Float32Array(8 * r), t.uvs = new Float32Array(8 * r), t.indices = new Uint16Array(6 * r);
                                else {
                                    const e = t.total,
                                        r = t.vertices;
                                    for (let t = 4 * e * 2; t < r.length; t++) r[t] = 0
                                }
                                t.mesh.size = 6 * r
                            }
                            for (let e = 0; e < I; e++) {
                                const t = f[e];
                                let i = t.position.x + R[t.line] * ("justify" === this._align ? t.prevSpaces : 1);
                                this._roundPixels && (i = Math.round(i));
                                const s = i * r,
                                    n = t.position.y * r,
                                    o = t.texture,
                                    a = B[o.baseTexture.uid],
                                    h = o.frame,
                                    l = o._uvs,
                                    u = a.index++;
                                a.indices[6 * u + 0] = 0 + 4 * u, a.indices[6 * u + 1] = 1 + 4 * u, a.indices[6 * u + 2] = 2 + 4 * u, a.indices[6 * u + 3] = 0 + 4 * u, a.indices[6 * u + 4] = 2 + 4 * u, a.indices[6 * u + 5] = 3 + 4 * u, a.vertices[8 * u + 0] = s, a.vertices[8 * u + 1] = n, a.vertices[8 * u + 2] = s + h.width * r, a.vertices[8 * u + 3] = n, a.vertices[8 * u + 4] = s + h.width * r, a.vertices[8 * u + 5] = n + h.height * r, a.vertices[8 * u + 6] = s, a.vertices[8 * u + 7] = n + h.height * r, a.uvs[8 * u + 0] = l.x0, a.uvs[8 * u + 1] = l.y0, a.uvs[8 * u + 2] = l.x1, a.uvs[8 * u + 3] = l.y1, a.uvs[8 * u + 4] = l.x2, a.uvs[8 * u + 5] = l.y2, a.uvs[8 * u + 6] = l.x3, a.uvs[8 * u + 7] = l.y3
                            }
                            this._textWidth = E * r, this._textHeight = (s.y + e.lineHeight) * r;
                            for (const e in B) {
                                const t = B[e];
                                if (0 !== this.anchor.x || 0 !== this.anchor.y) {
                                    let e = 0;
                                    const r = this._textWidth * this.anchor.x,
                                        i = this._textHeight * this.anchor.y;
                                    for (let s = 0; s < t.total; s++) t.vertices[e++] -= r, t.vertices[e++] -= i, t.vertices[e++] -= r, t.vertices[e++] -= i, t.vertices[e++] -= r, t.vertices[e++] -= i, t.vertices[e++] -= r, t.vertices[e++] -= i
                                }
                                this._maxLineHeight = P * r;
                                const i = t.mesh.geometry.getBuffer("aVertexPosition"),
                                    s = t.mesh.geometry.getBuffer("aTextureCoord"),
                                    n = t.mesh.geometry.getIndex();
                                i.data = t.vertices, s.data = t.uvs, n.data = t.indices, i.update(), s.update(), n.update()
                            }
                            for (let e = 0; e < f.length; e++) p.push(f[e]);
                            this._font = e, this.dirty = !1
                        }
                        updateTransform() {
                            this.validate(), this.containerUpdateTransform()
                        }
                        _render(e) {
                            this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0);
                            const {
                                distanceFieldRange: t,
                                distanceFieldType: r,
                                size: i
                            } = o.BitmapFont.available[this._fontName];
                            if ("none" !== r) {
                                const {
                                    a: r,
                                    b: s,
                                    c: n,
                                    d: o
                                } = this.worldTransform, a = Math.sqrt(r * r + s * s), h = Math.sqrt(n * n + o * o), l = (Math.abs(a) + Math.abs(h)) / 2, u = this.fontSize / i, c = e._view.resolution;
                                for (const e of this._activePagesMeshData) e.mesh.shader.uniforms.uFWidth = l * t * u * c
                            }
                            super._render(e)
                        }
                        getLocalBounds() {
                            return this.validate(), super.getLocalBounds()
                        }
                        validate() {
                            const e = o.BitmapFont.available[this._fontName];
                            if (!e) throw new Error(`Missing BitmapFont "${this._fontName}"`);
                            this._font !== e && (this.dirty = !0), this.dirty && this.updateText()
                        }
                        get tint() {
                            return this._tintColor.value
                        }
                        set tint(e) {
                            if (this.tint !== e) {
                                this._tintColor.setValue(e);
                                for (let t = 0; t < this._activePagesMeshData.length; t++) this._activePagesMeshData[t].mesh.tint = e
                            }
                        }
                        get align() {
                            return this._align
                        }
                        set align(e) {
                            this._align !== e && (this._align = e, this.dirty = !0)
                        }
                        get fontName() {
                            return this._fontName
                        }
                        set fontName(e) {
                            if (!o.BitmapFont.available[e]) throw new Error(`Missing BitmapFont "${e}"`);
                            this._fontName !== e && (this._fontName = e, this.dirty = !0)
                        }
                        get fontSize() {
                            return this._fontSize ?? o.BitmapFont.available[this._fontName].size
                        }
                        set fontSize(e) {
                            this._fontSize !== e && (this._fontSize = e, this.dirty = !0)
                        }
                        get anchor() {
                            return this._anchor
                        }
                        set anchor(e) {
                            "number" == typeof e ? this._anchor.set(e) : this._anchor.copyFrom(e)
                        }
                        get text() {
                            return this._text
                        }
                        set text(e) {
                            e = String(null == e ? "" : e), this._text !== e && (this._text = e, this.dirty = !0)
                        }
                        get maxWidth() {
                            return this._maxWidth
                        }
                        set maxWidth(e) {
                            this._maxWidth !== e && (this._maxWidth = e, this.dirty = !0)
                        }
                        get maxLineHeight() {
                            return this.validate(), this._maxLineHeight
                        }
                        get textWidth() {
                            return this.validate(), this._textWidth
                        }
                        get letterSpacing() {
                            return this._letterSpacing
                        }
                        set letterSpacing(e) {
                            this._letterSpacing !== e && (this._letterSpacing = e, this.dirty = !0)
                        }
                        get roundPixels() {
                            return this._roundPixels
                        }
                        set roundPixels(e) {
                            e !== this._roundPixels && (this._roundPixels = e, this.dirty = !0)
                        }
                        get textHeight() {
                            return this.validate(), this._textHeight
                        }
                        get resolution() {
                            return this._resolution
                        }
                        set resolution(e) {
                            this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0)
                        }
                        destroy(e) {
                            const {
                                _textureCache: t
                            } = this, r = "none" === o.BitmapFont.available[this._fontName].distanceFieldType ? c : d;
                            r.push(...this._activePagesMeshData);
                            for (const e of this._activePagesMeshData) this.removeChild(e.mesh);
                            this._activePagesMeshData = [], r.filter((e => t[e.mesh.texture.baseTexture.uid])).forEach((e => {
                                e.mesh.texture = i.Texture.EMPTY
                            }));
                            for (const e in t) t[e].destroy(), delete t[e];
                            this._font = null, this._tintColor = null, this._textureCache = null, super.destroy(e)
                        }
                    };
                let m = f;
                m.styleDefaults = {
                    align: "left",
                    tint: 16777215,
                    maxWidth: 0,
                    letterSpacing: 0
                }, t.BitmapText = m
            },
            2068: () => {},
            5859: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(1855);
                t.TextFormat = class {
                    static test(e) {
                        return "string" == typeof e && e.startsWith("info face=")
                    }
                    static parse(e) {
                        const t = e.match(/^[a-z]+\s+.+$/gm),
                            r = {
                                info: [],
                                common: [],
                                page: [],
                                char: [],
                                chars: [],
                                kerning: [],
                                kernings: [],
                                distanceField: []
                            };
                        for (const e in t) {
                            const i = t[e].match(/^[a-z]+/gm)[0],
                                s = t[e].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),
                                n = {};
                            for (const e in s) {
                                const t = s[e].split("="),
                                    r = t[0],
                                    i = t[1].replace(/"/gm, ""),
                                    o = parseFloat(i),
                                    a = isNaN(o) ? i : o;
                                n[r] = a
                            }
                            r[i].push(n)
                        }
                        const s = new i.BitmapFontData;
                        return r.info.forEach((e => s.info.push({
                            face: e.face,
                            size: parseInt(e.size, 10)
                        }))), r.common.forEach((e => s.common.push({
                            lineHeight: parseInt(e.lineHeight, 10)
                        }))), r.page.forEach((e => s.page.push({
                            id: parseInt(e.id, 10),
                            file: e.file
                        }))), r.char.forEach((e => s.char.push({
                            id: parseInt(e.id, 10),
                            page: parseInt(e.page, 10),
                            x: parseInt(e.x, 10),
                            y: parseInt(e.y, 10),
                            width: parseInt(e.width, 10),
                            height: parseInt(e.height, 10),
                            xoffset: parseInt(e.xoffset, 10),
                            yoffset: parseInt(e.yoffset, 10),
                            xadvance: parseInt(e.xadvance, 10)
                        }))), r.kerning.forEach((e => s.kerning.push({
                            first: parseInt(e.first, 10),
                            second: parseInt(e.second, 10),
                            amount: parseInt(e.amount, 10)
                        }))), r.distanceField.forEach((e => s.distanceField.push({
                            distanceRange: parseInt(e.distanceRange, 10),
                            fieldType: e.fieldType
                        }))), s
                    }
                }
            },
            5882: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(1855);
                t.XMLFormat = class {
                    static test(e) {
                        const t = e;
                        return "getElementsByTagName" in t && t.getElementsByTagName("page").length && null !== t.getElementsByTagName("info")[0].getAttribute("face")
                    }
                    static parse(e) {
                        const t = new i.BitmapFontData,
                            r = e.getElementsByTagName("info"),
                            s = e.getElementsByTagName("common"),
                            n = e.getElementsByTagName("page"),
                            o = e.getElementsByTagName("char"),
                            a = e.getElementsByTagName("kerning"),
                            h = e.getElementsByTagName("distanceField");
                        for (let e = 0; e < r.length; e++) t.info.push({
                            face: r[e].getAttribute("face"),
                            size: parseInt(r[e].getAttribute("size"), 10)
                        });
                        for (let e = 0; e < s.length; e++) t.common.push({
                            lineHeight: parseInt(s[e].getAttribute("lineHeight"), 10)
                        });
                        for (let e = 0; e < n.length; e++) t.page.push({
                            id: parseInt(n[e].getAttribute("id"), 10) || 0,
                            file: n[e].getAttribute("file")
                        });
                        for (let e = 0; e < o.length; e++) {
                            const r = o[e];
                            t.char.push({
                                id: parseInt(r.getAttribute("id"), 10),
                                page: parseInt(r.getAttribute("page"), 10) || 0,
                                x: parseInt(r.getAttribute("x"), 10),
                                y: parseInt(r.getAttribute("y"), 10),
                                width: parseInt(r.getAttribute("width"), 10),
                                height: parseInt(r.getAttribute("height"), 10),
                                xoffset: parseInt(r.getAttribute("xoffset"), 10),
                                yoffset: parseInt(r.getAttribute("yoffset"), 10),
                                xadvance: parseInt(r.getAttribute("xadvance"), 10)
                            })
                        }
                        for (let e = 0; e < a.length; e++) t.kerning.push({
                            first: parseInt(a[e].getAttribute("first"), 10),
                            second: parseInt(a[e].getAttribute("second"), 10),
                            amount: parseInt(a[e].getAttribute("amount"), 10)
                        });
                        for (let e = 0; e < h.length; e++) t.distanceField.push({
                            fieldType: h[e].getAttribute("fieldType"),
                            distanceRange: parseInt(h[e].getAttribute("distanceRange"), 10)
                        });
                        return t
                    }
                }
            },
            8861: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(5882);
                t.XMLStringFormat = class {
                    static test(e) {
                        return !("string" != typeof e || !e.includes("<font>")) && s.XMLFormat.test(i.settings.ADAPTER.parseXML(e))
                    }
                    static parse(e) {
                        return s.XMLFormat.parse(i.settings.ADAPTER.parseXML(e))
                    }
                }
            },
            6315: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(5859),
                    s = r(5882),
                    n = r(8861);
                const o = [i.TextFormat, s.XMLFormat, n.XMLStringFormat];
                t.TextFormat = i.TextFormat, t.XMLFormat = s.XMLFormat, t.XMLStringFormat = n.XMLStringFormat, t.autoDetectFormat = function(e) {
                    for (let t = 0; t < o.length; t++)
                        if (o[t].test(e)) return o[t];
                    return null
                }
            },
            138: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(1416),
                    s = r(1855),
                    n = r(3751);
                r(2068);
                var o = r(6315),
                    a = r(8321),
                    h = r(5859),
                    l = r(5882),
                    u = r(8861);
                t.BitmapFont = i.BitmapFont, t.BitmapFontData = s.BitmapFontData, t.BitmapText = n.BitmapText, t.autoDetectFormat = o.autoDetectFormat, t.loadBitmapFont = a.loadBitmapFont, t.TextFormat = h.TextFormat, t.XMLFormat = l.XMLFormat, t.XMLStringFormat = u.XMLStringFormat
            },
            8321: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(4645),
                    s = r(7163),
                    n = r(1416);
                r(6315);
                var o = r(5859),
                    a = r(8861);
                const h = [".xml", ".fnt"],
                    l = {
                        extension: {
                            type: s.ExtensionType.LoadParser,
                            priority: i.LoaderParserPriority.Normal
                        },
                        name: "loadBitmapFont",
                        test: e => h.includes(s.utils.path.extname(e).toLowerCase()),
                        testParse: async e => o.TextFormat.test(e) || a.XMLStringFormat.test(e),
                        async parse(e, t, r) {
                            const h = o.TextFormat.test(e) ? o.TextFormat.parse(e) : a.XMLStringFormat.parse(e),
                                {
                                    src: l
                                } = t,
                                {
                                    page: u
                                } = h,
                                c = [];
                            for (let e = 0; e < u.length; ++e) {
                                const t = u[e].file;
                                let r = s.utils.path.join(s.utils.path.dirname(l), t);
                                r = i.copySearchParams(r, l), c.push(r)
                            }
                            const d = await r.load(c),
                                p = c.map((e => d[e]));
                            return n.BitmapFont.install(h, p, !0)
                        },
                        load: async (e, t) => (await s.settings.ADAPTER.fetch(e)).text(),
                        unload(e) {
                            e.destroy()
                        }
                    };
                s.extensions.add(l), t.loadBitmapFont = l
            },
            7783: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor = texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median = texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median = min(median, texColor.a);\r\n\r\n  float screenPxDistance = uFWidth * (median - 0.5);\r\n  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median < 0.01) {\r\n    alpha = 0.0;\r\n  } else if (median > 0.99) {\r\n    alpha = 1.0;\r\n  }\r\n\r\n  // Gamma correction for coverage-like alpha\r\n  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r\n  float gamma = mix(1.0, 1.0 / 2.2, luma);\r\n  float coverage = pow(uColor.a * alpha, gamma);  \r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor = vec4(uColor.rgb, coverage);\r\n}\r\n"
            },
            8396: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = "// Mesh material default fragment\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n"
            },
            4191: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(4375);
                t.drawGlyph = function(e, t, r, n, o, a, h) {
                    const l = r.text,
                        u = r.fontProperties;
                    t.translate(n, o), t.scale(a, a);
                    const c = h.strokeThickness / 2,
                        d = -h.strokeThickness / 2;
                    if (t.font = h.toFontString(), t.lineWidth = h.strokeThickness, t.textBaseline = h.textBaseline, t.lineJoin = h.lineJoin, t.miterLimit = h.miterLimit, t.fillStyle = s.generateFillStyle(e, t, h, a, [l], r), t.strokeStyle = h.stroke, h.dropShadow) {
                        const e = h.dropShadowColor,
                            r = h.dropShadowBlur * a,
                            s = h.dropShadowDistance * a;
                        t.shadowColor = i.Color.shared.setValue(e).setAlpha(h.dropShadowAlpha).toRgbaString(), t.shadowBlur = r, t.shadowOffsetX = Math.cos(h.dropShadowAngle) * s, t.shadowOffsetY = Math.sin(h.dropShadowAngle) * s
                    } else t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;
                    h.stroke && h.strokeThickness && t.strokeText(l, c, d + r.lineHeight - u.descent), h.fill && t.fillText(l, c, d + r.lineHeight - u.descent), t.setTransform(1, 0, 0, 1, 0, 0), t.fillStyle = "rgba(0, 0, 0, 0)"
                }
            },
            7068: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.extractCharCode = function(e) {
                    return e.codePointAt ? e.codePointAt(0) : e.charCodeAt(0)
                }
            },
            4375: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(1418);
                t.generateFillStyle = function(e, t, r, s, n, o) {
                    const a = r.fill;
                    if (!Array.isArray(a)) return a;
                    if (1 === a.length) return a[0];
                    let h;
                    const l = r.dropShadow ? r.dropShadowDistance : 0,
                        u = r.padding || 0,
                        c = e.width / s - l - 2 * u,
                        d = e.height / s - l - 2 * u,
                        p = a.slice(),
                        f = r.fillGradientStops.slice();
                    if (!f.length) {
                        const e = p.length + 1;
                        for (let t = 1; t < e; ++t) f.push(t / e)
                    }
                    if (p.unshift(a[0]), f.unshift(0), p.push(a[a.length - 1]), f.push(1), r.fillGradientType === i.TEXT_GRADIENT.LINEAR_VERTICAL) {
                        h = t.createLinearGradient(c / 2, u, c / 2, d + u);
                        let e = 0;
                        const i = (o.fontProperties.fontSize + r.strokeThickness) / d;
                        for (let t = 0; t < n.length; t++) {
                            const r = o.lineHeight * t;
                            for (let t = 0; t < p.length; t++) {
                                let s = 0;
                                s = "number" == typeof f[t] ? f[t] : t / p.length;
                                const n = r / d + s * i;
                                let o = Math.max(e, n);
                                o = Math.min(o, 1), h.addColorStop(o, p[t]), e = o
                            }
                        }
                    } else {
                        h = t.createLinearGradient(u, d / 2, c + u, d / 2);
                        const e = p.length + 1;
                        let r = 1;
                        for (let t = 0; t < p.length; t++) {
                            let i;
                            i = "number" == typeof f[t] ? f[t] : r / e, h.addColorStop(i, p[t]), r++
                        }
                    }
                    return h
                }
            },
            9713: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(4191),
                    s = r(7068),
                    n = r(4375),
                    o = r(5420),
                    a = r(1560);
                t.drawGlyph = i.drawGlyph, t.extractCharCode = s.extractCharCode, t.generateFillStyle = n.generateFillStyle, t.resolveCharacters = o.resolveCharacters, t.splitTextToCharacters = a.splitTextToCharacters
            },
            5420: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(1560);
                t.resolveCharacters = function(e) {
                    "string" == typeof e && (e = [e]);
                    const t = [];
                    for (let r = 0, s = e.length; r < s; r++) {
                        const s = e[r];
                        if (Array.isArray(s)) {
                            if (2 !== s.length) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${s.length}.`);
                            const e = s[0].charCodeAt(0),
                                r = s[1].charCodeAt(0);
                            if (r < e) throw new Error("[BitmapFont]: Invalid character range.");
                            for (let i = e, s = r; i <= s; i++) t.push(String.fromCharCode(i))
                        } else t.push(...i.splitTextToCharacters(s))
                    }
                    if (0 === t.length) throw new Error("[BitmapFont]: Empty set when resolving characters.");
                    return t
                }
            },
            1560: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.splitTextToCharacters = function(e) {
                    return Array.from ? Array.from(e) : e.split("")
                }
            },
            3863: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(2517),
                    n = r(1418),
                    o = r(20);
                const a = class extends s.Sprite {
                    constructor(e = "", t = {}) {
                        super(i.Texture.EMPTY), this._text = null, this._style = null, this._autoResolution = !0, this._loading = !1, this.localStyleID = -1, this.dirty = !1, this.ownsStyle = !1;
                        const r = new Image,
                            s = i.Texture.from(r, {
                                scaleMode: i.settings.SCALE_MODE,
                                resourceOptions: {
                                    autoLoad: !1
                                }
                            });
                        s.orig = new i.Rectangle, s.trim = new i.Rectangle, this.texture = s;
                        const n = "http://www.w3.org/2000/svg",
                            o = "http://www.w3.org/1999/xhtml",
                            h = document.createElementNS(n, "svg"),
                            l = document.createElementNS(n, "foreignObject"),
                            u = document.createElementNS(o, "div"),
                            c = document.createElementNS(o, "style");
                        l.setAttribute("width", "10000"), l.setAttribute("height", "10000"), l.style.overflow = "hidden", h.appendChild(l), this.maxWidth = a.defaultMaxWidth, this.maxHeight = a.defaultMaxHeight, this._domElement = u, this._styleElement = c, this._svgRoot = h, this._foreignObject = l, this._foreignObject.appendChild(c), this._foreignObject.appendChild(u), this._image = r, this._loadImage = new Image, this._autoResolution = a.defaultAutoResolution, this._resolution = a.defaultResolution ?? i.settings.RESOLUTION, this.text = e, this.style = t
                    }
                    measureText(e) {
                        const {
                            text: t,
                            style: r,
                            resolution: i
                        } = Object.assign({
                            text: this._text,
                            style: this._style,
                            resolution: this._resolution
                        }, e);
                        Object.assign(this._domElement, {
                            innerHTML: t,
                            style: r.toCSS(i)
                        }), this._styleElement.textContent = r.toGlobalCSS(), document.body.appendChild(this._svgRoot);
                        const s = this._domElement.getBoundingClientRect();
                        this._svgRoot.remove();
                        const n = Math.min(this.maxWidth, Math.ceil(s.width)),
                            o = Math.min(this.maxHeight, Math.ceil(s.height));
                        return this._svgRoot.setAttribute("width", n.toString()), this._svgRoot.setAttribute("height", o.toString()), t !== this._text && (this._domElement.innerHTML = this._text), r !== this._style && (Object.assign(this._domElement, {
                            style: this._style?.toCSS(i)
                        }), this._styleElement.textContent = this._style?.toGlobalCSS()), {
                            width: n + 2 * r.padding,
                            height: o + 2 * r.padding
                        }
                    }
                    async updateText(e = !0) {
                        const {
                            style: t,
                            _image: r,
                            _loadImage: i
                        } = this;
                        if (this.localStyleID !== t.styleID && (this.dirty = !0, this.localStyleID = t.styleID), !this.dirty && e) return;
                        const {
                            width: s,
                            height: n
                        } = this.measureText();
                        r.width = i.width = Math.ceil(Math.max(1, s)), r.height = i.height = Math.ceil(Math.max(1, n)), this._loading || (this._loading = !0, await new Promise((e => {
                            i.onload = async () => {
                                await t.onBeforeDraw(), this._loading = !1, r.src = i.src, i.onload = null, i.src = "", this.updateTexture(), e()
                            };
                            const s = (new XMLSerializer).serializeToString(this._svgRoot);
                            i.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(s)}`
                        })))
                    }
                    get source() {
                        return this._image
                    }
                    updateTexture() {
                        const {
                            style: e,
                            texture: t,
                            _image: r,
                            resolution: i
                        } = this, {
                            padding: s
                        } = e, {
                            baseTexture: n
                        } = t;
                        t.trim.width = t._frame.width = r.width / i, t.trim.height = t._frame.height = r.height / i, t.trim.x = -s, t.trim.y = -s, t.orig.width = t._frame.width - 2 * s, t.orig.height = t._frame.height - 2 * s, this._onTextureUpdate(), n.setRealSize(r.width, r.height, i), this.dirty = !1
                    }
                    _render(e) {
                        this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), super._render(e)
                    }
                    _renderCanvas(e) {
                        this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), super._renderCanvas(e)
                    }
                    getLocalBounds(e) {
                        return this.updateText(!0), super.getLocalBounds(e)
                    }
                    _calculateBounds() {
                        this.updateText(!0), this.calculateVertices(), this._bounds.addQuad(this.vertexData)
                    }
                    _onStyleChange() {
                        this.dirty = !0
                    }
                    destroy(e) {
                        "boolean" == typeof e && (e = {
                            children: e
                        }), e = Object.assign({}, a.defaultDestroyOptions, e), super.destroy(e);
                        const t = null;
                        this.ownsStyle && this._style?.cleanFonts(), this._style = t, this._svgRoot?.remove(), this._svgRoot = t, this._domElement?.remove(), this._domElement = t, this._foreignObject?.remove(), this._foreignObject = t, this._styleElement?.remove(), this._styleElement = t, this._loadImage.src = "", this._loadImage.onload = null, this._loadImage = t, this._image.src = "", this._image = t
                    }
                    get width() {
                        return this.updateText(!0), Math.abs(this.scale.x) * this._image.width / this.resolution
                    }
                    set width(e) {
                        this.updateText(!0);
                        const t = i.utils.sign(this.scale.x) || 1;
                        this.scale.x = t * e / this._image.width / this.resolution, this._width = e
                    }
                    get height() {
                        return this.updateText(!0), Math.abs(this.scale.y) * this._image.height / this.resolution
                    }
                    set height(e) {
                        this.updateText(!0);
                        const t = i.utils.sign(this.scale.y) || 1;
                        this.scale.y = t * e / this._image.height / this.resolution, this._height = e
                    }
                    get style() {
                        return this._style
                    }
                    set style(e) {
                        this._style !== e && ((e = e || {}) instanceof o.HTMLTextStyle ? (this.ownsStyle = !1, this._style = e) : e instanceof n.TextStyle ? (console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle"), this.ownsStyle = !0, this._style = o.HTMLTextStyle.from(e)) : (this.ownsStyle = !0, this._style = new o.HTMLTextStyle(e)), this.localStyleID = -1, this.dirty = !0)
                    }
                    get text() {
                        return this._text
                    }
                    set text(e) {
                        e = String("" === e || null == e ? " " : e), e = this.sanitiseText(e), this._text !== e && (this._text = e, this.dirty = !0)
                    }
                    get resolution() {
                        return this._resolution
                    }
                    set resolution(e) {
                        this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0)
                    }
                    sanitiseText(e) {
                        return e.replace(/<br>/gi, "<br/>").replace(/<hr>/gi, "<hr/>").replace(/&nbsp;/gi, "&#160;")
                    }
                };
                let h = a;
                h.defaultDestroyOptions = {
                    texture: !0,
                    children: !1,
                    baseTexture: !0
                }, h.defaultMaxWidth = 2024, h.defaultMaxHeight = 2024, h.defaultAutoResolution = !0, t.HTMLText = h
            },
            20: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(1418);
                const n = class extends s.TextStyle {
                    constructor() {
                        super(...arguments), this._fonts = [], this._overrides = [], this._stylesheet = "", this.fontsDirty = !1
                    }
                    static from(e) {
                        return new n(Object.keys(n.defaultOptions).reduce(((t, r) => ({
                            ...t,
                            [r]: e[r]
                        })), {}))
                    }
                    cleanFonts() {
                        this._fonts.length > 0 && (this._fonts.forEach((e => {
                            URL.revokeObjectURL(e.src), e.refs--, 0 === e.refs && (e.fontFace && document.fonts.delete(e.fontFace), delete n.availableFonts[e.originalUrl])
                        })), this.fontFamily = "Arial", this._fonts.length = 0, this.styleID++, this.fontsDirty = !0)
                    }
                    loadFont(e, t = {}) {
                        const {
                            availableFonts: r
                        } = n;
                        if (r[e]) {
                            const t = r[e];
                            return this._fonts.push(t), t.refs++, this.styleID++, this.fontsDirty = !0, Promise.resolve()
                        }
                        return i.settings.ADAPTER.fetch(e).then((e => e.blob())).then((async e => new Promise(((t, r) => {
                            const i = URL.createObjectURL(e),
                                s = new FileReader;
                            s.onload = () => t([i, s.result]), s.onerror = r, s.readAsDataURL(e)
                        })))).then((async ([s, n]) => {
                            const o = Object.assign({
                                family: i.utils.path.basename(e, i.utils.path.extname(e)),
                                weight: "normal",
                                style: "normal",
                                src: s,
                                dataSrc: n,
                                refs: 1,
                                originalUrl: e,
                                fontFace: null
                            }, t);
                            r[e] = o, this._fonts.push(o), this.styleID++;
                            const a = new FontFace(o.family, `url(${o.src})`, {
                                weight: o.weight,
                                style: o.style
                            });
                            o.fontFace = a, await a.load(), document.fonts.add(a), await document.fonts.ready, this.styleID++, this.fontsDirty = !0
                        }))
                    }
                    addOverride(...e) {
                        const t = e.filter((e => !this._overrides.includes(e)));
                        t.length > 0 && (this._overrides.push(...t), this.styleID++)
                    }
                    removeOverride(...e) {
                        const t = e.filter((e => this._overrides.includes(e)));
                        t.length > 0 && (this._overrides = this._overrides.filter((e => !t.includes(e))), this.styleID++)
                    }
                    toCSS(e) {
                        return [`transform: scale(${e})`, "transform-origin: top left", "display: inline-block", `color: ${this.normalizeColor(this.fill)}`, `font-size: ${this.fontSize}px`, `font-family: ${this.fontFamily}`, `font-weight: ${this.fontWeight}`, `font-style: ${this.fontStyle}`, `font-variant: ${this.fontVariant}`, `letter-spacing: ${this.letterSpacing}px`, `text-align: ${this.align}`, `padding: ${this.padding}px`, `white-space: ${this.whiteSpace}`, ...this.lineHeight ? [`line-height: ${this.lineHeight}px`] : [], ...this.wordWrap ? ["word-wrap: " + (this.breakWords ? "break-all" : "break-word"), `max-width: ${this.wordWrapWidth}px`] : [], ...this.strokeThickness ? [`-webkit-text-stroke-width: ${this.strokeThickness}px`, `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`, `text-stroke-width: ${this.strokeThickness}px`, `text-stroke-color: ${this.normalizeColor(this.stroke)}`, "paint-order: stroke"] : [], ...this.dropShadow ? [this.dropShadowToCSS()] : [], ...this._overrides].join(";")
                    }
                    toGlobalCSS() {
                        return this._fonts.reduce(((e, t) => `${e}\n            @font-face {\n                font-family: "${t.family}";\n                src: url('${t.dataSrc}');\n                font-weight: ${t.weight};\n                font-style: ${t.style}; \n            }`), this._stylesheet)
                    }
                    get stylesheet() {
                        return this._stylesheet
                    }
                    set stylesheet(e) {
                        this._stylesheet !== e && (this._stylesheet = e, this.styleID++)
                    }
                    normalizeColor(e) {
                        return Array.isArray(e) && (e = i.utils.rgb2hex(e)), "number" == typeof e ? i.utils.hex2string(e) : e
                    }
                    dropShadowToCSS() {
                        let e = this.normalizeColor(this.dropShadowColor);
                        const t = this.dropShadowAlpha,
                            r = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance),
                            i = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
                        e.startsWith("#") && t < 1 && (e += (255 * t | 0).toString(16).padStart(2, "0"));
                        const s = `${r}px ${i}px`;
                        return this.dropShadowBlur > 0 ? `text-shadow: ${s} ${this.dropShadowBlur}px ${e}` : `text-shadow: ${s} ${e}`
                    }
                    reset() {
                        Object.assign(this, n.defaultOptions)
                    }
                    onBeforeDraw() {
                        const {
                            fontsDirty: e
                        } = this;
                        return this.fontsDirty = !1, this.isSafari && this._fonts.length > 0 && e ? new Promise((e => setTimeout(e, 100))) : Promise.resolve()
                    }
                    get isSafari() {
                        const {
                            userAgent: e
                        } = i.settings.ADAPTER.getNavigator();
                        return /^((?!chrome|android).)*safari/i.test(e)
                    }
                    set fillGradientStops(e) {
                        console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText")
                    }
                    get fillGradientStops() {
                        return super.fillGradientStops
                    }
                    set fillGradientType(e) {
                        console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText")
                    }
                    get fillGradientType() {
                        return super.fillGradientType
                    }
                    set miterLimit(e) {
                        console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText")
                    }
                    get miterLimit() {
                        return super.miterLimit
                    }
                    set trim(e) {
                        console.warn("[HTMLTextStyle] trim is not supported by HTMLText")
                    }
                    get trim() {
                        return super.trim
                    }
                    set textBaseline(e) {
                        console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText")
                    }
                    get textBaseline() {
                        return super.textBaseline
                    }
                    set leading(e) {
                        console.warn("[HTMLTextStyle] leading is not supported by HTMLText")
                    }
                    get leading() {
                        return super.leading
                    }
                    set lineJoin(e) {
                        console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText")
                    }
                    get lineJoin() {
                        return super.lineJoin
                    }
                };
                let o = n;
                o.availableFonts = {}, o.defaultOptions = {
                    align: "left",
                    breakWords: !1,
                    dropShadow: !1,
                    dropShadowAlpha: 1,
                    dropShadowAngle: Math.PI / 6,
                    dropShadowBlur: 0,
                    dropShadowColor: "black",
                    dropShadowDistance: 5,
                    fill: "black",
                    fontFamily: "Arial",
                    fontSize: 26,
                    fontStyle: "normal",
                    fontVariant: "normal",
                    fontWeight: "normal",
                    letterSpacing: 0,
                    lineHeight: 0,
                    padding: 0,
                    stroke: "black",
                    strokeThickness: 0,
                    whiteSpace: "normal",
                    wordWrap: !1,
                    wordWrapWidth: 100
                }, t.HTMLTextStyle = o
            },
            3826: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(3863),
                    s = r(20);
                t.HTMLText = i.HTMLText, t.HTMLTextStyle = s.HTMLTextStyle
            },
            8381: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163),
                    s = r(2517),
                    n = r(3528),
                    o = r(6424),
                    a = r(4639);
                const h = {
                        texture: !0,
                        children: !1,
                        baseTexture: !0
                    },
                    l = class extends s.Sprite {
                        constructor(e, t, r) {
                            let s = !1;
                            r || (r = i.settings.ADAPTER.createCanvas(), s = !0), r.width = 3, r.height = 3;
                            const n = i.Texture.from(r);
                            n.orig = new i.Rectangle, n.trim = new i.Rectangle, super(n), this._ownCanvas = s, this.canvas = r, this.context = r.getContext("2d", {
                                willReadFrequently: !0
                            }), this._resolution = l.defaultResolution ?? i.settings.RESOLUTION, this._autoResolution = l.defaultAutoResolution, this._text = null, this._style = null, this._styleListener = null, this._font = "", this.text = e, this.style = t, this.localStyleID = -1
                        }
                        static get experimentalLetterSpacing() {
                            return o.TextMetrics.experimentalLetterSpacing
                        }
                        static set experimentalLetterSpacing(e) {
                            i.utils.deprecation("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing"), o.TextMetrics.experimentalLetterSpacing = e
                        }
                        updateText(e) {
                            const t = this._style;
                            if (this.localStyleID !== t.styleID && (this.dirty = !0, this.localStyleID = t.styleID), !this.dirty && e) return;
                            this._font = this._style.toFontString();
                            const r = this.context,
                                s = o.TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas),
                                n = s.width,
                                a = s.height,
                                h = s.lines,
                                l = s.lineHeight,
                                u = s.lineWidths,
                                c = s.maxLineWidth,
                                d = s.fontProperties;
                            let p, f;
                            this.canvas.width = Math.ceil(Math.ceil(Math.max(1, n) + 2 * t.padding) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, a) + 2 * t.padding) * this._resolution), r.scale(this._resolution, this._resolution), r.clearRect(0, 0, this.canvas.width, this.canvas.height), r.font = this._font, r.lineWidth = t.strokeThickness, r.textBaseline = t.textBaseline, r.lineJoin = t.lineJoin, r.miterLimit = t.miterLimit;
                            const m = t.dropShadow ? 2 : 1;
                            for (let e = 0; e < m; ++e) {
                                const n = t.dropShadow && 0 === e,
                                    o = n ? Math.ceil(Math.max(1, a) + 2 * t.padding) : 0,
                                    m = o * this._resolution;
                                if (n) {
                                    r.fillStyle = "black", r.strokeStyle = "black";
                                    const e = t.dropShadowColor,
                                        s = t.dropShadowBlur * this._resolution,
                                        n = t.dropShadowDistance * this._resolution;
                                    r.shadowColor = i.Color.shared.setValue(e).setAlpha(t.dropShadowAlpha).toRgbaString(), r.shadowBlur = s, r.shadowOffsetX = Math.cos(t.dropShadowAngle) * n, r.shadowOffsetY = Math.sin(t.dropShadowAngle) * n + m
                                } else r.fillStyle = this._generateFillStyle(t, h, s), r.strokeStyle = t.stroke, r.shadowColor = "black", r.shadowBlur = 0, r.shadowOffsetX = 0, r.shadowOffsetY = 0;
                                let g = (l - d.fontSize) / 2;
                                l - d.fontSize < 0 && (g = 0);
                                for (let e = 0; e < h.length; e++) p = t.strokeThickness / 2, f = t.strokeThickness / 2 + e * l + d.ascent + g, "right" === t.align ? p += c - u[e] : "center" === t.align && (p += (c - u[e]) / 2), t.stroke && t.strokeThickness && this.drawLetterSpacing(h[e], p + t.padding, f + t.padding - o, !0), t.fill && this.drawLetterSpacing(h[e], p + t.padding, f + t.padding - o)
                            }
                            this.updateTexture()
                        }
                        drawLetterSpacing(e, t, r, i = !1) {
                            const s = this._style.letterSpacing;
                            let n = !1;
                            if (o.TextMetrics.experimentalLetterSpacingSupported && (o.TextMetrics.experimentalLetterSpacing ? (this.context.letterSpacing = `${s}px`, this.context.textLetterSpacing = `${s}px`, n = !0) : (this.context.letterSpacing = "0px", this.context.textLetterSpacing = "0px")), 0 === s || n) return void(i ? this.context.strokeText(e, t, r) : this.context.fillText(e, t, r));
                            let a = t;
                            const h = o.TextMetrics.graphemeSegmenter(e);
                            let l = this.context.measureText(e).width,
                                u = 0;
                            for (let e = 0; e < h.length; ++e) {
                                const t = h[e];
                                i ? this.context.strokeText(t, a, r) : this.context.fillText(t, a, r);
                                let n = "";
                                for (let t = e + 1; t < h.length; ++t) n += h[t];
                                u = this.context.measureText(n).width, a += l - u + s, l = u
                            }
                        }
                        updateTexture() {
                            const e = this.canvas;
                            if (this._style.trim) {
                                const t = i.utils.trimCanvas(e);
                                t.data && (e.width = t.width, e.height = t.height, this.context.putImageData(t.data, 0, 0))
                            }
                            const t = this._texture,
                                r = this._style,
                                s = r.trim ? 0 : r.padding,
                                n = t.baseTexture;
                            t.trim.width = t._frame.width = e.width / this._resolution, t.trim.height = t._frame.height = e.height / this._resolution, t.trim.x = -s, t.trim.y = -s, t.orig.width = t._frame.width - 2 * s, t.orig.height = t._frame.height - 2 * s, this._onTextureUpdate(), n.setRealSize(e.width, e.height, this._resolution), t.updateUvs(), this.dirty = !1
                        }
                        _render(e) {
                            this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), super._render(e)
                        }
                        updateTransform() {
                            this.updateText(!0), super.updateTransform()
                        }
                        getBounds(e, t) {
                            return this.updateText(!0), -1 === this._textureID && (e = !1), super.getBounds(e, t)
                        }
                        getLocalBounds(e) {
                            return this.updateText(!0), super.getLocalBounds.call(this, e)
                        }
                        _calculateBounds() {
                            this.calculateVertices(), this._bounds.addQuad(this.vertexData)
                        }
                        _generateFillStyle(e, t, r) {
                            const i = e.fill;
                            if (!Array.isArray(i)) return i;
                            if (1 === i.length) return i[0];
                            let s;
                            const o = e.dropShadow ? e.dropShadowDistance : 0,
                                a = e.padding || 0,
                                h = this.canvas.width / this._resolution - o - 2 * a,
                                l = this.canvas.height / this._resolution - o - 2 * a,
                                u = i.slice(),
                                c = e.fillGradientStops.slice();
                            if (!c.length) {
                                const e = u.length + 1;
                                for (let t = 1; t < e; ++t) c.push(t / e)
                            }
                            if (u.unshift(i[0]), c.unshift(0), u.push(i[i.length - 1]), c.push(1), e.fillGradientType === n.TEXT_GRADIENT.LINEAR_VERTICAL) {
                                s = this.context.createLinearGradient(h / 2, a, h / 2, l + a);
                                const i = r.fontProperties.fontSize + e.strokeThickness;
                                for (let e = 0; e < t.length; e++) {
                                    const n = r.lineHeight * (e - 1) + i,
                                        o = r.lineHeight * e;
                                    let a = o;
                                    e > 0 && n > o && (a = (o + n) / 2);
                                    const h = o + i,
                                        d = r.lineHeight * (e + 1);
                                    let p = h;
                                    e + 1 < t.length && d < h && (p = (h + d) / 2);
                                    const f = (p - a) / l;
                                    for (let e = 0; e < u.length; e++) {
                                        let t = 0;
                                        t = "number" == typeof c[e] ? c[e] : e / u.length;
                                        let r = Math.min(1, Math.max(0, a / l + t * f));
                                        r = Number(r.toFixed(5)), s.addColorStop(r, u[e])
                                    }
                                }
                            } else {
                                s = this.context.createLinearGradient(a, l / 2, h + a, l / 2);
                                const e = u.length + 1;
                                let t = 1;
                                for (let r = 0; r < u.length; r++) {
                                    let i;
                                    i = "number" == typeof c[r] ? c[r] : t / e, s.addColorStop(i, u[r]), t++
                                }
                            }
                            return s
                        }
                        destroy(e) {
                            "boolean" == typeof e && (e = {
                                children: e
                            }), e = Object.assign({}, h, e), super.destroy(e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null
                        }
                        get width() {
                            return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width
                        }
                        set width(e) {
                            this.updateText(!0);
                            const t = i.utils.sign(this.scale.x) || 1;
                            this.scale.x = t * e / this._texture.orig.width, this._width = e
                        }
                        get height() {
                            return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height
                        }
                        set height(e) {
                            this.updateText(!0);
                            const t = i.utils.sign(this.scale.y) || 1;
                            this.scale.y = t * e / this._texture.orig.height, this._height = e
                        }
                        get style() {
                            return this._style
                        }
                        set style(e) {
                            (e = e || {}) instanceof a.TextStyle ? this._style = e : this._style = new a.TextStyle(e), this.localStyleID = -1, this.dirty = !0
                        }
                        get text() {
                            return this._text
                        }
                        set text(e) {
                            e = String(null == e ? "" : e), this._text !== e && (this._text = e, this.dirty = !0)
                        }
                        get resolution() {
                            return this._resolution
                        }
                        set resolution(e) {
                            this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0)
                        }
                    };
                let u = l;
                u.defaultAutoResolution = !0, t.Text = u
            },
            6424: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7163);
                const s = {
                        willReadFrequently: !0
                    },
                    n = class {
                        static get experimentalLetterSpacingSupported() {
                            let e = n._experimentalLetterSpacingSupported;
                            if (void 0 !== e) {
                                const t = i.settings.ADAPTER.getCanvasRenderingContext2D().prototype;
                                e = n._experimentalLetterSpacingSupported = "letterSpacing" in t || "textLetterSpacing" in t
                            }
                            return e
                        }
                        constructor(e, t, r, i, s, n, o, a, h) {
                            this.text = e, this.style = t, this.width = r, this.height = i, this.lines = s, this.lineWidths = n, this.lineHeight = o, this.maxLineWidth = a, this.fontProperties = h
                        }
                        static measureText(e, t, r, i = n._canvas) {
                            r = null == r ? t.wordWrap : r;
                            const o = t.toFontString(),
                                a = n.measureFont(o);
                            0 === a.fontSize && (a.fontSize = t.fontSize, a.ascent = t.fontSize);
                            const h = i.getContext("2d", s);
                            h.font = o;
                            const l = (r ? n.wordWrap(e, t, i) : e).split(/(?:\r\n|\r|\n)/),
                                u = new Array(l.length);
                            let c = 0;
                            for (let e = 0; e < l.length; e++) {
                                const r = n._measureText(l[e], t.letterSpacing, h);
                                u[e] = r, c = Math.max(c, r)
                            }
                            let d = c + t.strokeThickness;
                            t.dropShadow && (d += t.dropShadowDistance);
                            const p = t.lineHeight || a.fontSize + t.strokeThickness;
                            let f = Math.max(p, a.fontSize + 2 * t.strokeThickness) + (l.length - 1) * (p + t.leading);
                            return t.dropShadow && (f += t.dropShadowDistance), new n(e, t, d, f, l, u, p + t.leading, c, a)
                        }
                        static _measureText(e, t, r) {
                            let i = !1;
                            n.experimentalLetterSpacingSupported && (n.experimentalLetterSpacing ? (r.letterSpacing = `${t}px`, r.textLetterSpacing = `${t}px`, i = !0) : (r.letterSpacing = "0px", r.textLetterSpacing = "0px"));
                            let s = r.measureText(e).width;
                            return s > 0 && (i ? s -= t : s += (n.graphemeSegmenter(e).length - 1) * t), s
                        }
                        static wordWrap(e, t, r = n._canvas) {
                            const i = r.getContext("2d", s);
                            let o = 0,
                                a = "",
                                h = "";
                            const l = Object.create(null),
                                {
                                    letterSpacing: u,
                                    whiteSpace: c
                                } = t,
                                d = n.collapseSpaces(c),
                                p = n.collapseNewlines(c);
                            let f = !d;
                            const m = t.wordWrapWidth + u,
                                g = n.tokenize(e);
                            for (let e = 0; e < g.length; e++) {
                                let r = g[e];
                                if (n.isNewline(r)) {
                                    if (!p) {
                                        h += n.addLine(a), f = !d, a = "", o = 0;
                                        continue
                                    }
                                    r = " "
                                }
                                if (d) {
                                    const e = n.isBreakingSpace(r),
                                        t = n.isBreakingSpace(a[a.length - 1]);
                                    if (e && t) continue
                                }
                                const s = n.getFromCache(r, u, l, i);
                                if (s > m)
                                    if ("" !== a && (h += n.addLine(a), a = "", o = 0), n.canBreakWords(r, t.breakWords)) {
                                        const e = n.wordWrapSplit(r);
                                        for (let s = 0; s < e.length; s++) {
                                            let c = e[s],
                                                d = c,
                                                p = 1;
                                            for (; e[s + p];) {
                                                const i = e[s + p];
                                                if (n.canBreakChars(d, i, r, s, t.breakWords)) break;
                                                c += i, d = i, p++
                                            }
                                            s += p - 1;
                                            const g = n.getFromCache(c, u, l, i);
                                            g + o > m && (h += n.addLine(a), f = !1, a = "", o = 0), a += c, o += g
                                        }
                                    } else {
                                        a.length > 0 && (h += n.addLine(a), a = "", o = 0);
                                        const t = e === g.length - 1;
                                        h += n.addLine(r, !t), f = !1, a = "", o = 0
                                    }
                                else s + o > m && (f = !1, h += n.addLine(a), a = "", o = 0), (a.length > 0 || !n.isBreakingSpace(r) || f) && (a += r, o += s)
                            }
                            return h += n.addLine(a, !1), h
                        }
                        static addLine(e, t = !0) {
                            return e = n.trimRight(e), t ? `${e}\n` : e
                        }
                        static getFromCache(e, t, r, i) {
                            let s = r[e];
                            return "number" != typeof s && (s = n._measureText(e, t, i) + t, r[e] = s), s
                        }
                        static collapseSpaces(e) {
                            return "normal" === e || "pre-line" === e
                        }
                        static collapseNewlines(e) {
                            return "normal" === e
                        }
                        static trimRight(e) {
                            if ("string" != typeof e) return "";
                            for (let t = e.length - 1; t >= 0; t--) {
                                const r = e[t];
                                if (!n.isBreakingSpace(r)) break;
                                e = e.slice(0, -1)
                            }
                            return e
                        }
                        static isNewline(e) {
                            return "string" == typeof e && n._newlines.includes(e.charCodeAt(0))
                        }
                        static isBreakingSpace(e, t) {
                            return "string" == typeof e && n._breakingSpaces.includes(e.charCodeAt(0))
                        }
                        static tokenize(e) {
                            const t = [];
                            let r = "";
                            if ("string" != typeof e) return t;
                            for (let i = 0; i < e.length; i++) {
                                const s = e[i],
                                    o = e[i + 1];
                                n.isBreakingSpace(s, o) || n.isNewline(s) ? ("" !== r && (t.push(r), r = ""), t.push(s)) : r += s
                            }
                            return "" !== r && t.push(r), t
                        }
                        static canBreakWords(e, t) {
                            return t
                        }
                        static canBreakChars(e, t, r, i, s) {
                            return !0
                        }
                        static wordWrapSplit(e) {
                            return n.graphemeSegmenter(e)
                        }
                        static measureFont(e) {
                            if (n._fonts[e]) return n._fonts[e];
                            const t = {
                                    ascent: 0,
                                    descent: 0,
                                    fontSize: 0
                                },
                                r = n._canvas,
                                i = n._context;
                            i.font = e;
                            const s = n.METRICS_STRING + n.BASELINE_SYMBOL,
                                o = Math.ceil(i.measureText(s).width);
                            let a = Math.ceil(i.measureText(n.BASELINE_SYMBOL).width);
                            const h = Math.ceil(n.HEIGHT_MULTIPLIER * a);
                            if (a = a * n.BASELINE_MULTIPLIER | 0, 0 === o || 0 === h) return n._fonts[e] = t, t;
                            r.width = o, r.height = h, i.fillStyle = "#f00", i.fillRect(0, 0, o, h), i.font = e, i.textBaseline = "alphabetic", i.fillStyle = "#000", i.fillText(s, 0, a);
                            const l = i.getImageData(0, 0, o, h).data,
                                u = l.length,
                                c = 4 * o;
                            let d = 0,
                                p = 0,
                                f = !1;
                            for (d = 0; d < a; ++d) {
                                for (let e = 0; e < c; e += 4)
                                    if (255 !== l[p + e]) {
                                        f = !0;
                                        break
                                    } if (f) break;
                                p += c
                            }
                            for (t.ascent = a - d, p = u - c, f = !1, d = h; d > a; --d) {
                                for (let e = 0; e < c; e += 4)
                                    if (255 !== l[p + e]) {
                                        f = !0;
                                        break
                                    } if (f) break;
                                p -= c
                            }
                            return t.descent = d - a, t.fontSize = t.ascent + t.descent, n._fonts[e] = t, t
                        }
                        static clearMetrics(e = "") {
                            e ? delete n._fonts[e] : n._fonts = {}
                        }
                        static get _canvas() {
                            if (!n.__canvas) {
                                let e;
                                try {
                                    const t = new OffscreenCanvas(0, 0),
                                        r = t.getContext("2d", s);
                                    if (r?.measureText) return n.__canvas = t, t;
                                    e = i.settings.ADAPTER.createCanvas()
                                } catch (t) {
                                    e = i.settings.ADAPTER.createCanvas()
                                }
                                e.width = e.height = 10, n.__canvas = e
                            }
                            return n.__canvas
                        }
                        static get _context() {
                            return n.__context || (n.__context = n._canvas.getContext("2d", s)), n.__context
                        }
                    };
                let o = n;
                o.METRICS_STRING = "|q", o.BASELINE_SYMBOL = "M", o.BASELINE_MULTIPLIER = 1.4, o.HEIGHT_MULTIPLIER = 2, o.graphemeSegmenter = (() => {
                    if ("function" == typeof Intl?.Segmenter) {
                        const e = new Intl.Segmenter;
                        return t => [...e.segment(t)].map((e => e.segment))
                    }
                    return e => [...e]
                })(), o.experimentalLetterSpacing = !1, o._fonts = {}, o._newlines = [10, 13], o._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288], t.TextMetrics = o
            },
            4639: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(3528),
                    s = r(7163);
                const n = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"],
                    o = class {
                        constructor(e) {
                            this.styleID = 0, this.reset(), l(this, e, e)
                        }
                        clone() {
                            const e = {};
                            return l(e, this, o.defaultStyle), new o(e)
                        }
                        reset() {
                            l(this, o.defaultStyle, o.defaultStyle)
                        }
                        get align() {
                            return this._align
                        }
                        set align(e) {
                            this._align !== e && (this._align = e, this.styleID++)
                        }
                        get breakWords() {
                            return this._breakWords
                        }
                        set breakWords(e) {
                            this._breakWords !== e && (this._breakWords = e, this.styleID++)
                        }
                        get dropShadow() {
                            return this._dropShadow
                        }
                        set dropShadow(e) {
                            this._dropShadow !== e && (this._dropShadow = e, this.styleID++)
                        }
                        get dropShadowAlpha() {
                            return this._dropShadowAlpha
                        }
                        set dropShadowAlpha(e) {
                            this._dropShadowAlpha !== e && (this._dropShadowAlpha = e, this.styleID++)
                        }
                        get dropShadowAngle() {
                            return this._dropShadowAngle
                        }
                        set dropShadowAngle(e) {
                            this._dropShadowAngle !== e && (this._dropShadowAngle = e, this.styleID++)
                        }
                        get dropShadowBlur() {
                            return this._dropShadowBlur
                        }
                        set dropShadowBlur(e) {
                            this._dropShadowBlur !== e && (this._dropShadowBlur = e, this.styleID++)
                        }
                        get dropShadowColor() {
                            return this._dropShadowColor
                        }
                        set dropShadowColor(e) {
                            const t = h(e);
                            this._dropShadowColor !== t && (this._dropShadowColor = t, this.styleID++)
                        }
                        get dropShadowDistance() {
                            return this._dropShadowDistance
                        }
                        set dropShadowDistance(e) {
                            this._dropShadowDistance !== e && (this._dropShadowDistance = e, this.styleID++)
                        }
                        get fill() {
                            return this._fill
                        }
                        set fill(e) {
                            const t = h(e);
                            this._fill !== t && (this._fill = t, this.styleID++)
                        }
                        get fillGradientType() {
                            return this._fillGradientType
                        }
                        set fillGradientType(e) {
                            this._fillGradientType !== e && (this._fillGradientType = e, this.styleID++)
                        }
                        get fillGradientStops() {
                            return this._fillGradientStops
                        }
                        set fillGradientStops(e) {
                            (function(e, t) {
                                if (!Array.isArray(e) || !Array.isArray(t)) return !1;
                                if (e.length !== t.length) return !1;
                                for (let r = 0; r < e.length; ++r)
                                    if (e[r] !== t[r]) return !1;
                                return !0
                            })(this._fillGradientStops, e) || (this._fillGradientStops = e, this.styleID++)
                        }
                        get fontFamily() {
                            return this._fontFamily
                        }
                        set fontFamily(e) {
                            this.fontFamily !== e && (this._fontFamily = e, this.styleID++)
                        }
                        get fontSize() {
                            return this._fontSize
                        }
                        set fontSize(e) {
                            this._fontSize !== e && (this._fontSize = e, this.styleID++)
                        }
                        get fontStyle() {
                            return this._fontStyle
                        }
                        set fontStyle(e) {
                            this._fontStyle !== e && (this._fontStyle = e, this.styleID++)
                        }
                        get fontVariant() {
                            return this._fontVariant
                        }
                        set fontVariant(e) {
                            this._fontVariant !== e && (this._fontVariant = e, this.styleID++)
                        }
                        get fontWeight() {
                            return this._fontWeight
                        }
                        set fontWeight(e) {
                            this._fontWeight !== e && (this._fontWeight = e, this.styleID++)
                        }
                        get letterSpacing() {
                            return this._letterSpacing
                        }
                        set letterSpacing(e) {
                            this._letterSpacing !== e && (this._letterSpacing = e, this.styleID++)
                        }
                        get lineHeight() {
                            return this._lineHeight
                        }
                        set lineHeight(e) {
                            this._lineHeight !== e && (this._lineHeight = e, this.styleID++)
                        }
                        get leading() {
                            return this._leading
                        }
                        set leading(e) {
                            this._leading !== e && (this._leading = e, this.styleID++)
                        }
                        get lineJoin() {
                            return this._lineJoin
                        }
                        set lineJoin(e) {
                            this._lineJoin !== e && (this._lineJoin = e, this.styleID++)
                        }
                        get miterLimit() {
                            return this._miterLimit
                        }
                        set miterLimit(e) {
                            this._miterLimit !== e && (this._miterLimit = e, this.styleID++)
                        }
                        get padding() {
                            return this._padding
                        }
                        set padding(e) {
                            this._padding !== e && (this._padding = e, this.styleID++)
                        }
                        get stroke() {
                            return this._stroke
                        }
                        set stroke(e) {
                            const t = h(e);
                            this._stroke !== t && (this._stroke = t, this.styleID++)
                        }
                        get strokeThickness() {
                            return this._strokeThickness
                        }
                        set strokeThickness(e) {
                            this._strokeThickness !== e && (this._strokeThickness = e, this.styleID++)
                        }
                        get textBaseline() {
                            return this._textBaseline
                        }
                        set textBaseline(e) {
                            this._textBaseline !== e && (this._textBaseline = e, this.styleID++)
                        }
                        get trim() {
                            return this._trim
                        }
                        set trim(e) {
                            this._trim !== e && (this._trim = e, this.styleID++)
                        }
                        get whiteSpace() {
                            return this._whiteSpace
                        }
                        set whiteSpace(e) {
                            this._whiteSpace !== e && (this._whiteSpace = e, this.styleID++)
                        }
                        get wordWrap() {
                            return this._wordWrap
                        }
                        set wordWrap(e) {
                            this._wordWrap !== e && (this._wordWrap = e, this.styleID++)
                        }
                        get wordWrapWidth() {
                            return this._wordWrapWidth
                        }
                        set wordWrapWidth(e) {
                            this._wordWrapWidth !== e && (this._wordWrapWidth = e, this.styleID++)
                        }
                        toFontString() {
                            const e = "number" == typeof this.fontSize ? `${this.fontSize}px` : this.fontSize;
                            let t = this.fontFamily;
                            Array.isArray(this.fontFamily) || (t = this.fontFamily.split(","));
                            for (let e = t.length - 1; e >= 0; e--) {
                                let r = t[e].trim();
                                /([\"\'])[^\'\"]+\1/.test(r) || n.includes(r) || (r = `"${r}"`), t[e] = r
                            }
                            return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${e} ${t.join(",")}`
                        }
                    };
                let a = o;

                function h(e) {
                    const t = s.Color.shared;
                    return Array.isArray(e) ? e.map((e => t.setValue(e).toHex())) : t.setValue(e).toHex()
                }

                function l(e, t, r) {
                    for (const i in r) Array.isArray(t[i]) ? e[i] = t[i].slice() : e[i] = t[i]
                }
                a.defaultStyle = {
                    align: "left",
                    breakWords: !1,
                    dropShadow: !1,
                    dropShadowAlpha: 1,
                    dropShadowAngle: Math.PI / 6,
                    dropShadowBlur: 0,
                    dropShadowColor: "black",
                    dropShadowDistance: 5,
                    fill: "black",
                    fillGradientType: i.TEXT_GRADIENT.LINEAR_VERTICAL,
                    fillGradientStops: [],
                    fontFamily: "Arial",
                    fontSize: 26,
                    fontStyle: "normal",
                    fontVariant: "normal",
                    fontWeight: "normal",
                    leading: 0,
                    letterSpacing: 0,
                    lineHeight: 0,
                    lineJoin: "miter",
                    miterLimit: 10,
                    padding: 0,
                    stroke: "black",
                    strokeThickness: 0,
                    textBaseline: "alphabetic",
                    trim: !1,
                    whiteSpace: "pre",
                    wordWrap: !1,
                    wordWrapWidth: 100
                }, t.TextStyle = a
            },
            3528: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = (e => (e[e.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", e[e.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL", e))(r || {});
                t.TEXT_GRADIENT = r
            },
            1418: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(3528),
                    s = r(8381),
                    n = r(6424),
                    o = r(4639);
                t.TEXT_GRADIENT = i.TEXT_GRADIENT, t.Text = s.Text, t.TextMetrics = n.TextMetrics, t.TextStyle = o.TextStyle
            },
            6265: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(4144),
                    s = r(1591);
                const n = class {
                    constructor() {
                        this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new s.TickerListener(null, null, 1 / 0), this.deltaMS = 1 / n.targetFPMS, this.elapsedMS = 1 / n.targetFPMS, this._tick = e => {
                            this._requestId = null, this.started && (this.update(e), this.started && null === this._requestId && this._head.next && (this._requestId = requestAnimationFrame(this._tick)))
                        }
                    }
                    _requestIfNeeded() {
                        null === this._requestId && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick))
                    }
                    _cancelIfNeeded() {
                        null !== this._requestId && (cancelAnimationFrame(this._requestId), this._requestId = null)
                    }
                    _startIfPossible() {
                        this.started ? this._requestIfNeeded() : this.autoStart && this.start()
                    }
                    add(e, t, r = i.UPDATE_PRIORITY.NORMAL) {
                        return this._addListener(new s.TickerListener(e, t, r))
                    }
                    addOnce(e, t, r = i.UPDATE_PRIORITY.NORMAL) {
                        return this._addListener(new s.TickerListener(e, t, r, !0))
                    }
                    _addListener(e) {
                        let t = this._head.next,
                            r = this._head;
                        if (t) {
                            for (; t;) {
                                if (e.priority > t.priority) {
                                    e.connect(r);
                                    break
                                }
                                r = t, t = t.next
                            }
                            e.previous || e.connect(r)
                        } else e.connect(r);
                        return this._startIfPossible(), this
                    }
                    remove(e, t) {
                        let r = this._head.next;
                        for (; r;) r = r.match(e, t) ? r.destroy() : r.next;
                        return this._head.next || this._cancelIfNeeded(), this
                    }
                    get count() {
                        if (!this._head) return 0;
                        let e = 0,
                            t = this._head;
                        for (; t = t.next;) e++;
                        return e
                    }
                    start() {
                        this.started || (this.started = !0, this._requestIfNeeded())
                    }
                    stop() {
                        this.started && (this.started = !1, this._cancelIfNeeded())
                    }
                    destroy() {
                        if (!this._protected) {
                            this.stop();
                            let e = this._head.next;
                            for (; e;) e = e.destroy(!0);
                            this._head.destroy(), this._head = null
                        }
                    }
                    update(e = performance.now()) {
                        let t;
                        if (e > this.lastTime) {
                            if (t = this.elapsedMS = e - this.lastTime, t > this._maxElapsedMS && (t = this._maxElapsedMS), t *= this.speed, this._minElapsedMS) {
                                const t = e - this._lastFrame | 0;
                                if (t < this._minElapsedMS) return;
                                this._lastFrame = e - t % this._minElapsedMS
                            }
                            this.deltaMS = t, this.deltaTime = this.deltaMS * n.targetFPMS;
                            const r = this._head;
                            let i = r.next;
                            for (; i;) i = i.emit(this.deltaTime);
                            r.next || this._cancelIfNeeded()
                        } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
                        this.lastTime = e
                    }
                    get FPS() {
                        return 1e3 / this.elapsedMS
                    }
                    get minFPS() {
                        return 1e3 / this._maxElapsedMS
                    }
                    set minFPS(e) {
                        const t = Math.min(this.maxFPS, e),
                            r = Math.min(Math.max(0, t) / 1e3, n.targetFPMS);
                        this._maxElapsedMS = 1 / r
                    }
                    get maxFPS() {
                        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
                    }
                    set maxFPS(e) {
                        if (0 === e) this._minElapsedMS = 0;
                        else {
                            const t = Math.max(this.minFPS, e);
                            this._minElapsedMS = 1 / (t / 1e3)
                        }
                    }
                    static get shared() {
                        if (!n._shared) {
                            const e = n._shared = new n;
                            e.autoStart = !0, e._protected = !0
                        }
                        return n._shared
                    }
                    static get system() {
                        if (!n._system) {
                            const e = n._system = new n;
                            e.autoStart = !0, e._protected = !0
                        }
                        return n._system
                    }
                };
                let o = n;
                o.targetFPMS = .06, t.Ticker = o
            },
            1591: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.TickerListener = class {
                    constructor(e, t = null, r = 0, i = !1) {
                        this.next = null, this.previous = null, this._destroyed = !1, this.fn = e, this.context = t, this.priority = r, this.once = i
                    }
                    match(e, t = null) {
                        return this.fn === e && this.context === t
                    }
                    emit(e) {
                        this.fn && (this.context ? this.fn.call(this.context, e) : this.fn(e));
                        const t = this.next;
                        return this.once && this.destroy(!0), this._destroyed && (this.next = null), t
                    }
                    connect(e) {
                        this.previous = e, e.next && (e.next.previous = this), this.next = e.next, e.next = this
                    }
                    destroy(e = !1) {
                        this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
                        const t = this.next;
                        return this.next = e ? null : t, this.previous = null, t
                    }
                }
            },
            2271: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7222),
                    s = r(4144),
                    n = r(6265);
                class o {
                    static init(e) {
                        e = Object.assign({
                            autoStart: !0,
                            sharedTicker: !1
                        }, e), Object.defineProperty(this, "ticker", {
                            set(e) {
                                this._ticker && this._ticker.remove(this.render, this), this._ticker = e, e && e.add(this.render, this, s.UPDATE_PRIORITY.LOW)
                            },
                            get() {
                                return this._ticker
                            }
                        }), this.stop = () => {
                            this._ticker.stop()
                        }, this.start = () => {
                            this._ticker.start()
                        }, this._ticker = null, this.ticker = e.sharedTicker ? n.Ticker.shared : new n.Ticker, e.autoStart && this.start()
                    }
                    static destroy() {
                        if (this._ticker) {
                            const e = this._ticker;
                            this.ticker = null, e.destroy()
                        }
                    }
                }
                o.extension = i.ExtensionType.Application, i.extensions.add(o), t.TickerPlugin = o
            },
            4144: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var r = (e => (e[e.INTERACTION = 50] = "INTERACTION", e[e.HIGH = 25] = "HIGH", e[e.NORMAL = 0] = "NORMAL", e[e.LOW = -25] = "LOW", e[e.UTILITY = -50] = "UTILITY", e))(r || {});
                t.UPDATE_PRIORITY = r
            },
            6763: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), r(833);
                var i = r(4144),
                    s = r(6265),
                    n = r(2271);
                t.UPDATE_PRIORITY = i.UPDATE_PRIORITY, t.Ticker = s.Ticker, t.TickerPlugin = n.TickerPlugin
            },
            833: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(6667),
                    s = r(6128),
                    n = r(6265);
                Object.defineProperties(i.settings, {
                    TARGET_FPMS: {
                        get: () => n.Ticker.targetFPMS,
                        set(e) {
                            s.deprecation("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"), n.Ticker.targetFPMS = e
                        }
                    }
                }), Object.defineProperty(t, "settings", {
                    enumerable: !0,
                    get: function() {
                        return i.settings
                    }
                })
            },
            5635: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(3057);
                t.sayHello = function() {
                    i.deprecation("7.0.0", 'sayHello is deprecated, please use Renderer\'s "hello" option')
                }, t.skipHello = function() {
                    i.deprecation("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello")
                }
            },
            8102: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), r(2893);
                var i = r(6667);
                let s;
                t.isWebGLSupported = function() {
                    return void 0 === s && (s = function() {
                        const e = {
                            stencil: !0,
                            failIfMajorPerformanceCaveat: i.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
                        };
                        try {
                            if (!i.settings.ADAPTER.getWebGLRenderingContext()) return !1;
                            const t = i.settings.ADAPTER.createCanvas();
                            let r = t.getContext("webgl", e) || t.getContext("experimental-webgl", e);
                            const s = !!r?.getContextAttributes()?.stencil;
                            if (r) {
                                const e = r.getExtension("WEBGL_lose_context");
                                e && e.loseContext()
                            }
                            return r = null, s
                        } catch (e) {
                            return !1
                        }
                    }()), s
                }
            },
            4677: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2264),
                    s = r(3057);
                t.hex2rgb = function(e, t = []) {
                    return s.deprecation("7.2.0", "utils.hex2rgb is deprecated, use Color#toRgbArray instead"), i.Color.shared.setValue(e).toRgbArray(t)
                }, t.hex2string = function(e) {
                    return s.deprecation("7.2.0", "utils.hex2string is deprecated, use Color#toHex instead"), i.Color.shared.setValue(e).toHex()
                }, t.rgb2hex = function(e) {
                    return s.deprecation("7.2.0", "utils.rgb2hex is deprecated, use Color#toNumber instead"), i.Color.shared.setValue(e).toNumber()
                }, t.string2hex = function(e) {
                    return s.deprecation("7.2.0", "utils.string2hex is deprecated, use Color#toNumber instead"), i.Color.shared.setValue(e).toNumber()
                }
            },
            4970: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(2264),
                    s = r(2386),
                    n = r(3057);
                const o = function() {
                    const e = [],
                        t = [];
                    for (let r = 0; r < 32; r++) e[r] = r, t[r] = r;
                    e[s.BLEND_MODES.NORMAL_NPM] = s.BLEND_MODES.NORMAL, e[s.BLEND_MODES.ADD_NPM] = s.BLEND_MODES.ADD, e[s.BLEND_MODES.SCREEN_NPM] = s.BLEND_MODES.SCREEN, t[s.BLEND_MODES.NORMAL] = s.BLEND_MODES.NORMAL_NPM, t[s.BLEND_MODES.ADD] = s.BLEND_MODES.ADD_NPM, t[s.BLEND_MODES.SCREEN] = s.BLEND_MODES.SCREEN_NPM;
                    const r = [];
                    return r.push(t), r.push(e), r
                }();
                t.correctBlendMode = function(e, t) {
                    return o[t ? 1 : 0][e]
                }, t.premultiplyBlendMode = o, t.premultiplyRgba = function(e, t, r, s = !0) {
                    return n.deprecation("7.2.0", "utils.premultiplyRgba has moved to Color.premultiply"), i.Color.shared.setValue(e).premultiply(t, s).toArray(r ?? new Float32Array(4))
                }, t.premultiplyTint = function(e, t) {
                    return n.deprecation("7.2.0", "utils.premultiplyTint has moved to Color.toPremultiplied"), i.Color.shared.setValue(e).toPremultiplied(t)
                }, t.premultiplyTintToRgba = function(e, t, r, s = !0) {
                    return n.deprecation("7.2.0", "utils.premultiplyTintToRgba has moved to Color.premultiply"), i.Color.shared.setValue(e).premultiply(t, s).toArray(r ?? new Float32Array(4))
                }
            },
            7309: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i
            },
            3520: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.createIndicesForQuads = function(e, t = null) {
                    const r = 6 * e;
                    if ((t = t || new Uint16Array(r)).length !== r) throw new Error(`Out buffer length is incorrect, got ${t.length} and expected ${r}`);
                    for (let e = 0, i = 0; e < r; e += 6, i += 4) t[e + 0] = i + 0, t[e + 1] = i + 1, t[e + 2] = i + 2, t[e + 3] = i + 0, t[e + 4] = i + 2, t[e + 5] = i + 3;
                    return t
                }
            },
            7344: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.getBufferType = function(e) {
                    if (4 === e.BYTES_PER_ELEMENT) return e instanceof Float32Array ? "Float32Array" : e instanceof Uint32Array ? "Uint32Array" : "Int32Array";
                    if (2 === e.BYTES_PER_ELEMENT) {
                        if (e instanceof Uint16Array) return "Uint16Array"
                    } else if (1 === e.BYTES_PER_ELEMENT && e instanceof Uint8Array) return "Uint8Array";
                    return null
                }
            },
            9662: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7344);
                const s = {
                    Float32Array,
                    Uint32Array,
                    Int32Array,
                    Uint8Array
                };
                t.interleaveTypedArrays = function(e, t) {
                    let r = 0,
                        n = 0;
                    const o = {};
                    for (let i = 0; i < e.length; i++) n += t[i], r += e[i].length;
                    const a = new ArrayBuffer(4 * r);
                    let h = null,
                        l = 0;
                    for (let r = 0; r < e.length; r++) {
                        const u = t[r],
                            c = e[r],
                            d = i.getBufferType(c);
                        o[d] || (o[d] = new s[d](a)), h = o[d];
                        for (let e = 0; e < c.length; e++) h[(e / u | 0) * n + l + e % u] = c[e];
                        l += u
                    }
                    return new Float32Array(a)
                }
            },
            3219: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.isPow2 = function(e) {
                    return !(e & e - 1 || !e)
                }, t.log2 = function(e) {
                    let t = (e > 65535 ? 1 : 0) << 4,
                        r = ((e >>>= t) > 255 ? 1 : 0) << 3;
                    return t |= r, r = ((e >>>= r) > 15 ? 1 : 0) << 2, t |= r, r = ((e >>>= r) > 3 ? 1 : 0) << 1, t |= r, t | (e >>>= r) >> 1
                }, t.nextPow2 = function(e) {
                    return e += 0 === e ? 1 : 0, --e, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, 1 + (e |= e >>> 16)
                }
            },
            8684: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.removeItems = function(e, t, r) {
                    const i = e.length;
                    let s;
                    if (t >= i || 0 === r) return;
                    const n = i - (r = t + r > i ? i - t : r);
                    for (s = t; s < n; ++s) e[s] = e[s + r];
                    e.length = n
                }
            },
            1129: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.sign = function(e) {
                    return 0 === e ? 0 : e < 0 ? -1 : 1
                }
            },
            2075: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                let r = 0;
                t.uid = function() {
                    return ++r
                }
            },
            6128: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), r(2893);
                var i = r(6667),
                    s = r(6729),
                    n = r(9187),
                    o = r(4521),
                    a = r(4172),
                    h = r(5635),
                    l = r(8102),
                    u = r(4677),
                    c = r(4970),
                    d = r(7309),
                    p = r(3520),
                    f = r(7344),
                    m = r(9662),
                    g = r(3219),
                    y = r(8684),
                    _ = r(1129),
                    v = r(2075),
                    S = r(3057),
                    T = r(4782),
                    b = r(7550),
                    E = r(6387),
                    x = r(7971),
                    w = r(3738),
                    O = r(784),
                    A = r(2902),
                    P = r(6281);

                function M(e) {
                    return e && "object" == typeof e && "default" in e ? e : {
                        default: e
                    }
                }
                r(6044);
                var C = M(s),
                    R = M(n);
                Object.defineProperty(t, "isMobile", {
                    enumerable: !0,
                    get: function() {
                        return i.isMobile
                    }
                }), Object.defineProperty(t, "EventEmitter", {
                    enumerable: !0,
                    get: function() {
                        return C.default
                    }
                }), Object.defineProperty(t, "earcut", {
                    enumerable: !0,
                    get: function() {
                        return R.default
                    }
                }), t.url = o.url, t.path = a.path, t.sayHello = h.sayHello, t.skipHello = h.skipHello, t.isWebGLSupported = l.isWebGLSupported, t.hex2rgb = u.hex2rgb, t.hex2string = u.hex2string, t.rgb2hex = u.rgb2hex, t.string2hex = u.string2hex, t.correctBlendMode = c.correctBlendMode, t.premultiplyBlendMode = c.premultiplyBlendMode, t.premultiplyRgba = c.premultiplyRgba, t.premultiplyTint = c.premultiplyTint, t.premultiplyTintToRgba = c.premultiplyTintToRgba, t.DATA_URI = d.DATA_URI, t.createIndicesForQuads = p.createIndicesForQuads, t.getBufferType = f.getBufferType, t.interleaveTypedArrays = m.interleaveTypedArrays, t.isPow2 = g.isPow2, t.log2 = g.log2, t.nextPow2 = g.nextPow2, t.removeItems = y.removeItems, t.sign = _.sign, t.uid = v.uid, t.deprecation = S.deprecation, t.BoundingBox = T.BoundingBox, t.BaseTextureCache = b.BaseTextureCache, t.ProgramCache = b.ProgramCache, t.TextureCache = b.TextureCache, t.clearTextureCache = b.clearTextureCache, t.destroyTextureCache = b.destroyTextureCache, t.CanvasRenderTarget = E.CanvasRenderTarget, t.getCanvasBoundingBox = x.getCanvasBoundingBox, t.trimCanvas = w.trimCanvas, t.decomposeDataUri = O.decomposeDataUri, t.determineCrossOrigin = A.determineCrossOrigin, t.getResolutionOfUrl = P.getResolutionOfUrl
            },
            3057: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const r = {};
                t.deprecation = function(e, t, i = 3) {
                    if (r[t]) return;
                    let s = (new Error).stack;
                    void 0 === s ? console.warn("PixiJS Deprecation Warning: ", `${t}\nDeprecated since v${e}`) : (s = s.split("\n").splice(i).join("\n"), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${t}\nDeprecated since v${e}`), console.warn(s), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${t}\nDeprecated since v${e}`), console.warn(s))), r[t] = !0
                }
            },
            4782: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const r = class {
                    constructor(e, t, r, i) {
                        this.left = e, this.top = t, this.right = r, this.bottom = i
                    }
                    get width() {
                        return this.right - this.left
                    }
                    get height() {
                        return this.bottom - this.top
                    }
                    isEmpty() {
                        return this.left === this.right || this.top === this.bottom
                    }
                };
                let i = r;
                i.EMPTY = new r(0, 0, 0, 0), t.BoundingBox = i
            },
            6387: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(6667);
                t.CanvasRenderTarget = class {
                    constructor(e, t, r) {
                        this._canvas = i.settings.ADAPTER.createCanvas(), this._context = this._canvas.getContext("2d"), this.resolution = r || i.settings.RESOLUTION, this.resize(e, t)
                    }
                    clear() {
                        this._checkDestroyed(), this._context.setTransform(1, 0, 0, 1, 0, 0), this._context.clearRect(0, 0, this._canvas.width, this._canvas.height)
                    }
                    resize(e, t) {
                        this._checkDestroyed(), this._canvas.width = Math.round(e * this.resolution), this._canvas.height = Math.round(t * this.resolution)
                    }
                    destroy() {
                        this._context = null, this._canvas = null
                    }
                    get width() {
                        return this._checkDestroyed(), this._canvas.width
                    }
                    set width(e) {
                        this._checkDestroyed(), this._canvas.width = Math.round(e)
                    }
                    get height() {
                        return this._checkDestroyed(), this._canvas.height
                    }
                    set height(e) {
                        this._checkDestroyed(), this._canvas.height = Math.round(e)
                    }
                    get canvas() {
                        return this._checkDestroyed(), this._canvas
                    }
                    get context() {
                        return this._checkDestroyed(), this._context
                    }
                    _checkDestroyed() {
                        if (null === this._canvas) throw new TypeError("The CanvasRenderTarget has already been destroyed")
                    }
                }
            },
            7550: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                const r = Object.create(null),
                    i = Object.create(null);
                t.BaseTextureCache = i, t.ProgramCache = {}, t.TextureCache = r, t.clearTextureCache = function() {
                    let e;
                    for (e in r) delete r[e];
                    for (e in i) delete i[e]
                }, t.destroyTextureCache = function() {
                    let e;
                    for (e in r) r[e].destroy();
                    for (e in i) i[e].destroy()
                }
            },
            7971: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(4782);

                function s(e, t, r) {
                    for (let i = 0, s = 4 * r * t; i < t; ++i, s += 4)
                        if (0 !== e[s + 3]) return !1;
                    return !0
                }

                function n(e, t, r, i, s) {
                    const n = 4 * t;
                    for (let t = i, o = i * n + 4 * r; t <= s; ++t, o += n)
                        if (0 !== e[o + 3]) return !1;
                    return !0
                }
                t.getCanvasBoundingBox = function(e) {
                    const {
                        width: t,
                        height: r
                    } = e, o = e.getContext("2d", {
                        willReadFrequently: !0
                    });
                    if (null === o) throw new TypeError("Failed to get canvas 2D context");
                    const a = o.getImageData(0, 0, t, r).data;
                    let h = 0,
                        l = 0,
                        u = t - 1,
                        c = r - 1;
                    for (; l < r && s(a, t, l);) ++l;
                    if (l === r) return i.BoundingBox.EMPTY;
                    for (; s(a, t, c);) --c;
                    for (; n(a, t, h, l, c);) ++h;
                    for (; n(a, t, u, l, c);) --u;
                    return ++u, ++c, new i.BoundingBox(h, l, u, c)
                }
            },
            3738: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7971);
                t.trimCanvas = function(e) {
                    const t = i.getCanvasBoundingBox(e),
                        {
                            width: r,
                            height: s
                        } = t;
                    let n = null;
                    if (!t.isEmpty()) {
                        const i = e.getContext("2d");
                        if (null === i) throw new TypeError("Failed to get canvas 2D context");
                        n = i.getImageData(t.left, t.top, r, s)
                    }
                    return {
                        width: r,
                        height: s,
                        data: n
                    }
                }
            },
            784: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(7309);
                t.decomposeDataUri = function(e) {
                    const t = i.DATA_URI.exec(e);
                    if (t) return {
                        mediaType: t[1] ? t[1].toLowerCase() : void 0,
                        subType: t[2] ? t[2].toLowerCase() : void 0,
                        charset: t[3] ? t[3].toLowerCase() : void 0,
                        encoding: t[4] ? t[4].toLowerCase() : void 0,
                        data: t[5]
                    }
                }
            },
            2902: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(4521);
                let s;
                t.determineCrossOrigin = function(e, t = globalThis.location) {
                    if (e.startsWith("data:")) return "";
                    t = t || globalThis.location, s || (s = document.createElement("a")), s.href = e;
                    const r = i.url.parse(s.href),
                        n = !r.port && "" === t.port || r.port === t.port;
                    return r.hostname === t.hostname && n && r.protocol === t.protocol ? "" : "anonymous"
                }
            },
            6281: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), r(2893);
                var i = r(6667);
                t.getResolutionOfUrl = function(e, t = 1) {
                    const r = i.settings.RETINA_PREFIX?.exec(e);
                    return r ? parseFloat(r[1]) : t
                }
            },
            4172: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(6667);

                function s(e) {
                    if ("string" != typeof e) throw new TypeError(`Path must be a string. Received ${JSON.stringify(e)}`)
                }

                function n(e) {
                    return e.split("?")[0].split("#")[0]
                }
                const o = {
                    toPosix: e => ("\\", "/", e.replace(new RegExp("\\".replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"), "/")),
                    isUrl(e) {
                        return /^https?:/.test(this.toPosix(e))
                    },
                    isDataUrl: e => /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(e),
                    hasProtocol(e) {
                        return /^[^/:]+:\//.test(this.toPosix(e))
                    },
                    getProtocol(e) {
                        s(e), e = this.toPosix(e);
                        let t = "";
                        const r = /^file:\/\/\//.exec(e),
                            i = /^[^/:]+:\/\//.exec(e),
                            n = /^[^/:]+:\//.exec(e);
                        if (r || i || n) {
                            const s = r?.[0] || i?.[0] || n?.[0];
                            t = s, e = e.slice(s.length)
                        }
                        return t
                    },
                    toAbsolute(e, t, r) {
                        if (this.isDataUrl(e)) return e;
                        const a = n(this.toPosix(t ?? i.settings.ADAPTER.getBaseUrl())),
                            h = n(this.toPosix(r ?? this.rootname(a)));
                        return s(e), (e = this.toPosix(e)).startsWith("/") ? o.join(h, e.slice(1)) : this.isAbsolute(e) ? e : this.join(a, e)
                    },
                    normalize(e) {
                        if (s(e = this.toPosix(e)), 0 === e.length) return ".";
                        let t = "";
                        const r = e.startsWith("/");
                        this.hasProtocol(e) && (t = this.rootname(e), e = e.slice(t.length));
                        const i = e.endsWith("/");
                        return (e = function(e, t) {
                            let r = "",
                                i = 0,
                                s = -1,
                                n = 0,
                                o = -1;
                            for (let t = 0; t <= e.length; ++t) {
                                if (t < e.length) o = e.charCodeAt(t);
                                else {
                                    if (47 === o) break;
                                    o = 47
                                }
                                if (47 === o) {
                                    if (s === t - 1 || 1 === n);
                                    else if (s !== t - 1 && 2 === n) {
                                        if (r.length < 2 || 2 !== i || 46 !== r.charCodeAt(r.length - 1) || 46 !== r.charCodeAt(r.length - 2))
                                            if (r.length > 2) {
                                                const e = r.lastIndexOf("/");
                                                if (e !== r.length - 1) {
                                                    -1 === e ? (r = "", i = 0) : (r = r.slice(0, e), i = r.length - 1 - r.lastIndexOf("/")), s = t, n = 0;
                                                    continue
                                                }
                                            } else if (2 === r.length || 1 === r.length) {
                                            r = "", i = 0, s = t, n = 0;
                                            continue
                                        }
                                    } else r.length > 0 ? r += `/${e.slice(s+1,t)}` : r = e.slice(s + 1, t), i = t - s - 1;
                                    s = t, n = 0
                                } else 46 === o && -1 !== n ? ++n : n = -1
                            }
                            return r
                        }(e)).length > 0 && i && (e += "/"), r ? `/${e}` : t + e
                    },
                    isAbsolute(e) {
                        return s(e), e = this.toPosix(e), !!this.hasProtocol(e) || e.startsWith("/")
                    },
                    join(...e) {
                        if (0 === e.length) return ".";
                        let t;
                        for (let r = 0; r < e.length; ++r) {
                            const i = e[r];
                            if (s(i), i.length > 0)
                                if (void 0 === t) t = i;
                                else {
                                    const s = e[r - 1] ?? "";
                                    this.extname(s) ? t += `/../${i}` : t += `/${i}`
                                }
                        }
                        return void 0 === t ? "." : this.normalize(t)
                    },
                    dirname(e) {
                        if (s(e), 0 === e.length) return ".";
                        let t = (e = this.toPosix(e)).charCodeAt(0);
                        const r = 47 === t;
                        let i = -1,
                            n = !0;
                        const o = this.getProtocol(e),
                            a = e;
                        for (let r = (e = e.slice(o.length)).length - 1; r >= 1; --r)
                            if (t = e.charCodeAt(r), 47 === t) {
                                if (!n) {
                                    i = r;
                                    break
                                }
                            } else n = !1;
                        return -1 === i ? r ? "/" : this.isUrl(a) ? o + e : o : r && 1 === i ? "//" : o + e.slice(0, i)
                    },
                    rootname(e) {
                        s(e);
                        let t = "";
                        if (t = (e = this.toPosix(e)).startsWith("/") ? "/" : this.getProtocol(e), this.isUrl(e)) {
                            const r = e.indexOf("/", t.length);
                            t = -1 !== r ? e.slice(0, r) : e, t.endsWith("/") || (t += "/")
                        }
                        return t
                    },
                    basename(e, t) {
                        s(e), t && s(t), e = n(this.toPosix(e));
                        let r, i = 0,
                            o = -1,
                            a = !0;
                        if (void 0 !== t && t.length > 0 && t.length <= e.length) {
                            if (t.length === e.length && t === e) return "";
                            let s = t.length - 1,
                                n = -1;
                            for (r = e.length - 1; r >= 0; --r) {
                                const h = e.charCodeAt(r);
                                if (47 === h) {
                                    if (!a) {
                                        i = r + 1;
                                        break
                                    }
                                } else - 1 === n && (a = !1, n = r + 1), s >= 0 && (h === t.charCodeAt(s) ? -1 == --s && (o = r) : (s = -1, o = n))
                            }
                            return i === o ? o = n : -1 === o && (o = e.length), e.slice(i, o)
                        }
                        for (r = e.length - 1; r >= 0; --r)
                            if (47 === e.charCodeAt(r)) {
                                if (!a) {
                                    i = r + 1;
                                    break
                                }
                            } else - 1 === o && (a = !1, o = r + 1);
                        return -1 === o ? "" : e.slice(i, o)
                    },
                    extname(e) {
                        s(e);
                        let t = -1,
                            r = 0,
                            i = -1,
                            o = !0,
                            a = 0;
                        for (let s = (e = n(this.toPosix(e))).length - 1; s >= 0; --s) {
                            const n = e.charCodeAt(s);
                            if (47 !== n) - 1 === i && (o = !1, i = s + 1), 46 === n ? -1 === t ? t = s : 1 !== a && (a = 1) : -1 !== t && (a = -1);
                            else if (!o) {
                                r = s + 1;
                                break
                            }
                        }
                        return -1 === t || -1 === i || 0 === a || 1 === a && t === i - 1 && t === r + 1 ? "" : e.slice(t, i)
                    },
                    parse(e) {
                        s(e);
                        const t = {
                            root: "",
                            dir: "",
                            base: "",
                            ext: "",
                            name: ""
                        };
                        if (0 === e.length) return t;
                        let r = (e = n(this.toPosix(e))).charCodeAt(0);
                        const i = this.isAbsolute(e);
                        let o;
                        t.root = this.rootname(e), o = i || this.hasProtocol(e) ? 1 : 0;
                        let a = -1,
                            h = 0,
                            l = -1,
                            u = !0,
                            c = e.length - 1,
                            d = 0;
                        for (; c >= o; --c)
                            if (r = e.charCodeAt(c), 47 !== r) - 1 === l && (u = !1, l = c + 1), 46 === r ? -1 === a ? a = c : 1 !== d && (d = 1) : -1 !== a && (d = -1);
                            else if (!u) {
                            h = c + 1;
                            break
                        }
                        return -1 === a || -1 === l || 0 === d || 1 === d && a === l - 1 && a === h + 1 ? -1 !== l && (t.base = t.name = 0 === h && i ? e.slice(1, l) : e.slice(h, l)) : (0 === h && i ? (t.name = e.slice(1, a), t.base = e.slice(1, l)) : (t.name = e.slice(h, a), t.base = e.slice(h, l)), t.ext = e.slice(a, l)), t.dir = this.dirname(e), t
                    },
                    sep: "/",
                    delimiter: ":"
                };
                t.path = o
            },
            2893: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(6667);
                i.settings.RETINA_PREFIX = /@([0-9\.]+)x/, i.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1, Object.defineProperty(t, "settings", {
                    enumerable: !0,
                    get: function() {
                        return i.settings
                    }
                })
            },
            6044: () => {},
            4521: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(8575);
                const s = {
                    parse: i.parse,
                    format: i.format,
                    resolve: i.resolve
                };
                t.url = s
            },
            2587: e => {
                "use strict";

                function t(e, t) {
                    return Object.prototype.hasOwnProperty.call(e, t)
                }
                e.exports = function(e, r, i, s) {
                    r = r || "&", i = i || "=";
                    var n = {};
                    if ("string" != typeof e || 0 === e.length) return n;
                    var o = /\+/g;
                    e = e.split(r);
                    var a = 1e3;
                    s && "number" == typeof s.maxKeys && (a = s.maxKeys);
                    var h = e.length;
                    a > 0 && h > a && (h = a);
                    for (var l = 0; l < h; ++l) {
                        var u, c, d, p, f = e[l].replace(o, "%20"),
                            m = f.indexOf(i);
                        m >= 0 ? (u = f.substr(0, m), c = f.substr(m + 1)) : (u = f, c = ""), d = decodeURIComponent(u), p = decodeURIComponent(c), t(n, d) ? Array.isArray(n[d]) ? n[d].push(p) : n[d] = [n[d], p] : n[d] = p
                    }
                    return n
                }
            },
            2361: e => {
                "use strict";
                var t = function(e) {
                    switch (typeof e) {
                        case "string":
                            return e;
                        case "boolean":
                            return e ? "true" : "false";
                        case "number":
                            return isFinite(e) ? e : "";
                        default:
                            return ""
                    }
                };
                e.exports = function(e, r, i, s) {
                    return r = r || "&", i = i || "=", null === e && (e = void 0), "object" == typeof e ? Object.keys(e).map((function(s) {
                        var n = encodeURIComponent(t(s)) + i;
                        return Array.isArray(e[s]) ? e[s].map((function(e) {
                            return n + encodeURIComponent(t(e))
                        })).join(r) : n + encodeURIComponent(t(e[s]))
                    })).join(r) : s ? encodeURIComponent(t(s)) + i + encodeURIComponent(t(e)) : ""
                }
            },
            7673: (e, t, r) => {
                "use strict";
                t.decode = t.parse = r(2587), t.encode = t.stringify = r(2361)
            },
            1258: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CollisionInfo = void 0;
                var i = r(5189),
                    s = t.CollisionInfo = function() {
                        function e(e, t, r, i, s, n, o) {
                            this.mask = e, this.width = t, this.height = r, this.minX = i, this.minY = s, this.maxX = n, this.maxY = o, this.lastUse = Date.now()
                        }
                        return e.prototype.updateDropTime = function(e) {
                            this.lastUse = e
                        }, e.prototype.isEmpty = function() {
                            return this.minX < 0 || this.minY < 0
                        }, e.prototype.readyToDrop = function(t) {
                            return t - this.lastUse > e.DROP_TIME
                        }, e.prototype.hit = function(e, t) {
                            return !(e < 0 || e >= this.width || t < 0 || t >= this.height || (e = e / i.CollisionManager.PIXEL_OFFSET | 0, t = t / i.CollisionManager.PIXEL_OFFSET | 0, 0 === this.mask[t * this.width + e]))
                        }, e.DROP_TIME = 1e4, e
                    }();
                window.CollisionInfo = s
            },
            5189: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CollisionManager = void 0;
                var i = r(655),
                    s = r(8232),
                    n = r(1258),
                    o = r(5348),
                    a = r(3466),
                    h = i.__importStar(r(8687)),
                    l = t.CollisionManager = function() {
                        function e() {
                            this.cache = {}, this.tempRect = new h.Rectangle, this.currentTime = Date.now(), this.canvas = document.createElement("canvas"), this.ctx = this.canvas.getContext("2d", {
                                willReadFrequently: !0
                            }), this.ctx.imageSmoothingEnabled = !1, this.debug = new a.CollisionManagerDebug
                        }
                        return e.prototype.tick = function(e) {
                            this.currentTime = Date.now(), this.cleanCache(), this.debug.draw(e, this.getCollisionObjectFrom.bind(this))
                        }, e.prototype.collisionId = function(e) {
                            if (e.type === s.HSObjectType.text) return "text_" + e.text;
                            var t = e.view.sprite.texture.baseTexture.resource,
                                r = t.url;
                            return r ? r.replace(/hsScale=\".\"/g, "") : t.svg
                        }, e.prototype.collisionInfo = function(e) {
                            var t = this.collisionId(e);
                            if (!t) return null;
                            if (this.cache[t]) return this.cache[t];
                            var r = e.view.sprite,
                                i = r.texture.baseTexture,
                                s = i.resource.source,
                                n = i.width,
                                o = i.height;
                            if (!s || !n || !o) return null;
                            var a = r.texture.baseTexture.resolution;
                            this.canvas.width = n, this.canvas.height = o, this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this.ctx.drawImage(s, 0, 0, n * a, o * a, 0, 0, n, o);
                            var h = this.createCollisionInfo();
                            return h ? (this.cache[t] = h, h) : null
                        }, e.prototype.createCollisionInfo = function() {
                            for (var t = this.canvas.width, r = this.canvas.height, i = this.ctx.getImageData(0, 0, t, r).data, s = Number.MAX_SAFE_INTEGER, o = Number.MAX_SAFE_INTEGER, a = Number.MIN_SAFE_INTEGER, h = Number.MIN_SAFE_INTEGER, l = e.PIXEL_OFFSET, u = new Uint8ClampedArray(t * r / l | 0), c = 3; c < i.length; c += 4 * l) {
                                var d = c / 4 | 0;
                                if (0 !== i[c]) {
                                    u[d / l | 0] = 255;
                                    var p = d % t,
                                        f = d / t | 0;
                                    p < s && (s = p), p > a && (a = p), f < o && (o = f), f > h && (h = f)
                                }
                            }
                            var m = new n.CollisionInfo(u, 0 | t, 0 | r, 0 | s, 0 | o, 0 | a, 0 | h);
                            return m.isEmpty() ? null : m
                        }, e.prototype.cleanCache = function() {
                            for (var e in this.cache) this.cache[e].readyToDrop(this.currentTime) && delete this.cache[e]
                        }, e.prototype.createCollisionObject = function(e) {
                            var t = this.collisionInfo(e);
                            if (t) {
                                t.updateDropTime(this.currentTime);
                                var r = e.view.sprite,
                                    i = new o.CollisionObject(r, t);
                                return e.collisionObject = i, i
                            }
                        }, e.prototype.areSpritesLoaded = function(e, t) {
                            return e.view.sprite.texture.baseTexture.valid && t.view.sprite.texture.baseTexture.valid
                        }, e.prototype.getCollisionObjectFrom = function(e) {
                            return e.collisionObject && this.cache[this.collisionId(e)] ? (e.collisionObject.info.updateDropTime(this.currentTime), e.collisionObject) : this.createCollisionObject(e)
                        }, e.prototype.existsCollisionBetweenStageObjects = function(e, t) {
                            if (!this.areSpritesLoaded(e, t)) return !1;
                            var r = this.getCollisionObjectFrom(e),
                                i = this.getCollisionObjectFrom(t);
                            return !(!r || !i) && this.existsCollisionBetween(r, i)
                        }, e.prototype.existsCollisionBetween = function(e, t) {
                            return e !== t && !! function(e, t) {
                                return u(e.sprite.getBounds(), t.sprite.getBounds())
                            }(e, t) && !! function(e, t) {
                                return u(e.getMaskBounds(), t.getMaskBounds())
                            }(e, t) && this.existsMaskCollision(e, t)
                        }, e.prototype.existsMaskCollision = function(e, t) {
                            var r, i, s, n, o, h, l, u = e.getMaskBounds(),
                                c = t.getMaskBounds(),
                                d = (r = u, i = c, s = this.tempRect, n = Math.max(r.x, i.x), o = Math.max(r.y, i.y), h = Math.min(r.x + r.width, i.x + i.width), l = Math.min(r.y + r.height, i.y + i.height), s.x = n, s.y = o, s.width = h - n, s.height = l - o, s),
                                p = 0 | d.x,
                                f = 0 | d.y,
                                m = p + d.width | 0,
                                g = f + d.height | 0;
                            return a.CollisionManagerDebug.ENABLED ? this.debug.checkCollision(e, t, p, f, m, g) : !!this.intersectionCoverMoreThan(.5, d, u, c) || this.checkCollision(e, t, p, f, m, g)
                        }, e.prototype.intersectionCoverMoreThan = function(e, t, r, i) {
                            var s = t.width * t.height,
                                n = r.width * r.height * e,
                                o = i.width * i.height * e;
                            return n > o ? s > n : s > o
                        }, e.prototype.checkCollision = function(e, t, r, i, s, n) {
                            for (var o = r; o < s; o++)
                                for (var a = i; a < n; a++)
                                    if (e.hit(o, a) && t.hit(o, a)) return !0;
                            return !1
                        }, e.PIXEL_OFFSET = 2, e
                    }();

                function u(e, t) {
                    return !(e.x >= t.x + t.width || t.x >= e.x + e.width || e.y >= t.y + t.height || t.y >= e.y + e.height)
                }
                window.CollisionManager = l
            },
            3466: (e, t) => {
                "use strict";

                function r(e, t, r, i, s, n) {
                    n.beginPath(), n.globalAlpha = .5, n.lineWidth = 2, n.strokeStyle = s, n.rect(e, t, r, i), n.stroke(), n.globalAlpha = 1, n.closePath()
                }
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CollisionManagerDebug = void 0, t.CollisionManagerDebug = function() {
                    function e() {
                        if (e.ENABLED) {
                            this.canvas = document.createElement("canvas"), this.ctx = this.canvas.getContext("2d");
                            var t = document.getElementsByName("foreground")[0];
                            this.canvas.width = t.width / window.devicePixelRatio, this.canvas.height = t.height / window.devicePixelRatio, this.canvas.style.position = "absolute", this.canvas.style.top = "0px", this.canvas.style.left = "0px", this.canvas.style.pointerEvents = "none", this.canvas.style.width = "100%", this.canvas.style.height = "100%", document.body.getElementsByTagName("hopscotch-player")[0].append(this.canvas)
                        }
                    }
                    return e.prototype.draw = function(t, r) {
                        var i = this;
                        e.ENABLED && (this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), t.forEach((function(e) {
                            if (e.view.sprite.texture.baseTexture.valid) {
                                var t = r(e);
                                t && i.drawCollisionObject(t)
                            }
                        })))
                    }, e.prototype.drawCollisionObject = function(t) {
                        var i, s, n;
                        e.ENABLED && (i = t, s = this.ctx, r((n = i.sprite.getBounds()).x, n.y, n.width, n.height, "#ffff00", s), function(e, t) {
                            var i = e.getMaskBounds();
                            r(i.x, i.y, i.width, i.height, "#ff0000", t)
                        }(t, this.ctx), function(e, t) {
                            t.fillStyle = "#0000ff", t.beginPath();
                            for (var r = e.sprite.getBounds(), i = r.left; i < r.right; i++)
                                for (var s = r.top; s < r.bottom; s++) e.hit(i, s) && t.rect(i, s, 1, 1);
                            t.fill(), t.closePath()
                        }(t, this.ctx))
                    }, e.prototype.checkCollision = function(t, i, s, n, o, a) {
                        return !!e.ENABLED && (r(s, n, o - s, a - n, "#0000ff", this.ctx), function(e, t, r, i, s, n, o) {
                            var a = !1;
                            e.fillStyle = "#00ff00", e.beginPath();
                            for (var h = i; h < n; h++)
                                for (var l = s; l < o; l++) t.hit(h, l) && r.hit(h, l) && (a = !0, e.rect(h, l, 1, 1));
                            return e.fill(), e.closePath(), a
                        }(this.ctx, t, i, s, n, o, a))
                    }, e.ENABLED = !1, e
                }()
            },
            5348: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.CollisionObject = void 0;
                var i = r(655).__importStar(r(8687)),
                    s = function() {
                        function e(e, t) {
                            this.sprite = e, this.info = t, this.localTempPoint = new i.Point, this.outputPoints = [new i.Point, new i.Point, new i.Point, new i.Point], this.tempPoints = [new i.Point, new i.Point, new i.Point, new i.Point], this.tempRect = new i.Rectangle, this.outputPoint = new i.Point
                        }
                        return e.prototype.hit = function(e, t) {
                            this.outputPoint.set(e, t);
                            var r = this.sprite.toLocal(this.outputPoint, this.sprite.parent, this.localTempPoint);
                            return r.x += (1 - this.sprite.anchor.x) * (this.sprite.width / Math.abs(this.sprite.scale.x)), r.y += (1 - this.sprite.anchor.y) * (this.sprite.height / this.sprite.scale.y), this.info.hit(r.x, r.y)
                        }, e.prototype.getMaskBounds = function() {
                            var e = this.sprite.getLocalBounds(),
                                t = e.left + this.info.minX,
                                r = e.top + this.info.minY,
                                i = e.right - (this.info.width - this.info.maxX),
                                s = e.bottom - (this.info.height - this.info.maxY);
                            this.tempPoints[0].set(t, r), this.tempPoints[1].set(i, r), this.tempPoints[2].set(i, s), this.tempPoints[3].set(t, s);
                            var n = [this.sprite.toGlobal(this.tempPoints[0], this.outputPoints[0]), this.sprite.toGlobal(this.tempPoints[1], this.outputPoints[1]), this.sprite.toGlobal(this.tempPoints[2], this.outputPoints[2]), this.sprite.toGlobal(this.tempPoints[3], this.outputPoints[3])],
                                o = Number.MAX_SAFE_INTEGER,
                                a = Number.MAX_SAFE_INTEGER,
                                h = Number.MIN_SAFE_INTEGER,
                                l = Number.MIN_SAFE_INTEGER;
                            n.forEach((function(e) {
                                var t = e.x,
                                    r = e.y;
                                t < o && (o = t), t > h && (h = t), r < a && (a = r), r > l && (l = r)
                            }));
                            var u = h - o,
                                c = l - a;
                            return this.tempRect.x = o, this.tempRect.y = a, this.tempRect.width = u, this.tempRect.height = c, this.tempRect
                        }, e
                    }();
                t.CollisionObject = s, window.CollisionObject = s
            },
            37: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSAccelerometerManager = void 0;
                var i = r(655),
                    s = r(9005),
                    n = i.__importDefault(r(7818)),
                    o = t.HSAccelerometerManager = function() {
                        function e() {}
                        return e.accelerometerFromIOSApp = function(e, t) {
                            this.listener(e), this.isShakingFromApp = t
                        }, e.listener = function(e) {
                            var t = e.accelerationIncludingGravity,
                                r = Math.hypot(t.x, t.y, t.z) || 9.8,
                                i = Math.round(100 * t.x / r),
                                n = Math.round(100 * t.y / r),
                                o = window.orientation;
                            null == o || -90 === o ? (this.tiltUp = i, this.tiltRight = n) : 90 === o ? (this.tiltUp = -i, this.tiltRight = -n) : 0 === o ? (this.tiltUp = -n, this.tiltRight = i) : (this.tiltUp = n, this.tiltRight = -i), (0, s.isIOSApp)() || this.updateShakeData(e.acceleration.x, e.acceleration.y, e.acceleration.z)
                        }, e.startAccelerometerUpdates = function() {
                            "DeviceMotionEvent" in window && !this.isListening && ("function" == typeof DeviceMotionEvent.requestPermission ? this.enableIOS13Accelerometer() : this.enableAccelerometer())
                        }, e.checkIfNeedsToOverrideKeyboardTilt = function() {
                            var e = this;
                            window.addEventListener("devicemotion", (function(t) {
                                e.shouldOverrideKeyboard || (e.shouldOverrideKeyboard = !!(t.rotationRate.alpha || t.rotationRate.beta || t.rotationRate.gamma))
                            }))
                        }, e.enableIOS13Accelerometer = function() {
                            this.isListening || (0, s.isIOSApp)() || window.addEventListener("touchend", e.deviceRequestPermissionIOS13)
                        }, e.enableAccelerometer = function() {
                            this.isListening || (this.isListening = !0, window.addEventListener("devicemotion", this.listener.bind(this), !1))
                        }, e.tiltUsingKeyboardIfNecessary = function() {
                            this.tiltHorizontalUsingKeyboard(3), this.tiltVerticalUsingKeyboard(3)
                        }, e.tiltHorizontalUsingKeyboard = function(e) {
                            var t = n.default.Key,
                                r = this.keyDownTime(e, t.LEFT, t.RIGHT);
                            null !== r && (this.tiltHorizontalKeyCount = this.tiltHorizontalKeyCount + r, this.keyboardTitlLeft = -1 * Math.floor(this.tiltHorizontalKeyCount), this.keyboardTitlRight = Math.floor(this.tiltHorizontalKeyCount))
                        }, e.keyDownTime = function(e, t, r) {
                            var i = n.default.shared;
                            return i.isPressed(t) ? -1 : i.isDown(t) ? -1 * Math.min(e, i.downTime(t)) : i.isPressed(r) ? 1 : i.isDown(r) ? Math.min(e, i.downTime(r)) : null
                        }, e.tiltVerticalUsingKeyboard = function(e) {
                            var t = n.default.Key,
                                r = this.keyDownTime(e, t.UP, t.DOWN);
                            null !== r && (this.tiltVerticalKeyCount = this.tiltVerticalKeyCount + r, this.keyboardTitlUp = -1 * Math.floor(this.tiltVerticalKeyCount), this.keyboardTitlDown = Math.floor(this.tiltVerticalKeyCount))
                        }, e.tiltDirection = function() {
                            return this.tiltUsingKeyboardIfNecessary(), this.tiltRight && this.tiltUp ? (0, s.hs_direction)(this.tiltRight, this.tiltUp, 30) : null
                        }, e.updateShakeData = function(t, r, i) {
                            this.xAccelerations.push(t), this.yAccelerations.push(r), this.zAccelerations.push(i), this.xAccelerations.length > e.SHAKE_MEMORY_COUNT && this.xAccelerations.shift(), this.yAccelerations.length > e.SHAKE_MEMORY_COUNT && this.yAccelerations.shift(), this.zAccelerations.length > e.SHAKE_MEMORY_COUNT && this.zAccelerations.shift()
                        }, e.isShaking = function() {
                            return !!this.wasSpaceKeyPressed || ((0, s.isIOSApp)() ? this.isShakingFromApp : [this.xAccelerations, this.yAccelerations, this.zAccelerations].some((function(t) {
                                return Math.abs((0, s.mean)(t)) < e.SUDDEN_ACCEL_THRESHOLD && (0, s.variance)(t) > e.SHAKE_SENSITIVITY
                            })))
                        }, e.clear = function() {
                            e.tiltUp = 0, e.keyboardTitlUp = 0, e.tiltDown = 0, e.keyboardTitlDown = 0, e.tiltLeft = 0, e.keyboardTitlLeft = 0, e.tiltRight = 0, e.keyboardTitlRight = 0, e.tiltHorizontalKeyCount = 0, e.tiltVerticalKeyCount = 0
                        }, Object.defineProperty(e, "wasSpaceKeyPressed", {
                            get: function() {
                                if (this.shouldOverrideKeyboard) return !1;
                                var e = n.default.Key;
                                return n.default.shared.isPressed(e.SPACE)
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e, "tiltUp", {
                            get: function() {
                                return this.shouldOverrideKeyboard ? this._tiltUp : a(this._tiltUp, this.keyboardTitlUp)
                            },
                            set: function(e) {
                                this._tiltUp = e, this._tiltDown = -e
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e, "tiltDown", {
                            get: function() {
                                return this.shouldOverrideKeyboard ? this._tiltDown : a(this._tiltDown, this.keyboardTitlDown)
                            },
                            set: function(e) {
                                this._tiltDown = e, this._tiltUp = -e
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e, "tiltLeft", {
                            get: function() {
                                return this.shouldOverrideKeyboard ? this._tiltLeft : a(this._tiltLeft, this.keyboardTitlLeft)
                            },
                            set: function(e) {
                                this._tiltLeft = e, this._tiltRight = -e
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e, "tiltRight", {
                            get: function() {
                                return this.shouldOverrideKeyboard ? this._tiltRight : a(this._tiltRight, this.keyboardTitlRight)
                            },
                            set: function(e) {
                                this._tiltRight = e, this._tiltLeft = -e
                            },
                            enumerable: !1,
                            configurable: !0
                        }), e.shouldOverrideKeyboard = !1, e.isListening = !1, e.isShakingFromApp = !1, e._tiltUp = 0, e._tiltDown = 0, e._tiltLeft = 0, e._tiltRight = 0, e.deviceRequestPermissionIOS13 = function() {
                            DeviceMotionEvent.requestPermission().then((function(t) {
                                "granted" === t && (e.enableAccelerometer(), window.removeEventListener("touchend", e.deviceRequestPermissionIOS13))
                            })).catch(console.error)
                        }, e.tiltHorizontalKeyCount = 0, e.tiltVerticalKeyCount = 0, e.keyboardTitlUp = 0, e.keyboardTitlDown = 0, e.keyboardTitlLeft = 0, e.keyboardTitlRight = 0, e.xAccelerations = [], e.yAccelerations = [], e.zAccelerations = [], e.SHAKE_MEMORY_COUNT = 10, e.SHAKE_SENSITIVITY = 60, e.SUDDEN_ACCEL_THRESHOLD = 2, e
                    }();

                function a(e, t) {
                    var r = e + t,
                        i = h(r + 100, 400) - 200 < 0 ? 1 : -1;
                    return (h(r + 100, 200) - 100) * i
                }

                function h(e, t) {
                    return (e % t + t) % t
                }
                window.HSAccelerometerManager = o
            },
            3372: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSMicrophoneManager = void 0;
                var i = r(655),
                    s = r(9005),
                    n = function() {
                        function e(e, t) {
                            var r, n = this;
                            this.volumeCallback = function() {
                                return !1
                            }, (0, s.isIOSApp)() || t && (null === (r = navigator.mediaDevices) || void 0 === r || r.getUserMedia({
                                audio: !0
                            }).then((function(t) {
                                var r = e.createMediaStreamSource(t),
                                    s = e.createAnalyser();
                                s.fftSize = 512, s.minDecibels = -127, s.maxDecibels = 0, s.smoothingTimeConstant = .4, r.connect(s);
                                var o = new Uint8Array(s.frequencyBinCount);
                                n.volumeCallback = function() {
                                    var e, t;
                                    s.getByteFrequencyData(o);
                                    var r = 0;
                                    try {
                                        for (var n = i.__values(o), a = n.next(); !a.done; a = n.next()) r += a.value
                                    } catch (t) {
                                        e = {
                                            error: t
                                        }
                                    } finally {
                                        try {
                                            a && !a.done && (t = n.return) && t.call(n)
                                        } finally {
                                            if (e) throw e.error
                                        }
                                    }
                                    return r / o.length * 100 / 127 > 45
                                }
                            })).catch((function(e) {
                                console.log("Could not access the microphone. ", e)
                            })))
                        }
                        return e.prototype.hasLoudNoise = function() {
                            return !(0, s.isIOSApp)() && this.volumeCallback()
                        }, e
                    }();
                t.HSMicrophoneManager = n, window.HSMicrophoneManager = n
            },
            8423: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSManagedObjectFactory = void 0;
                var i = r(2127),
                    s = r(3025),
                    n = r(1518),
                    o = r(9470),
                    a = r(662),
                    h = r(6642),
                    l = r(7069),
                    u = r(9751),
                    c = r(9002),
                    d = r(7351),
                    p = r(450),
                    f = r(8232),
                    m = r(445),
                    g = r(2983),
                    y = function() {
                        function e() {
                            this.context = new i.HSProjectContext, this.scene = this.buildScene(), this.project = new u.HSProject(this.context), this.project.scenes = [this.scene]
                        }
                        return e.prototype.buildDemoScene = function() {
                            this.buildObject(f.HSObjectType.octopus, "", 400, 200);
                            for (var e = this.buildObject(f.HSObjectType.chillanna, "", 400, 350), t = "Hello World \n", r = 0; r < 100; r++) t += "";
                            return this.buildObject(f.HSObjectType.text, t, 350, 200), this.buildOnStartRule(e), this.scene.parseJSON(), this.scene
                        }, e.prototype.buildScene = function() {
                            var e = new n.HSScene(this.context);
                            return e.parseJSON({}), e
                        }, e.prototype.buildObject = function(e, t, r, i) {
                            void 0 === e && (e = f.HSObjectType.monkey), void 0 === t && (t = ""), void 0 === r && (r = 750), void 0 === i && (i = 500);
                            var s = new h.HSObject(this.scene.context);
                            return s.type = e, s.text = t, s.x = r, s.y = i, s.objectID = Math.floor(Math.random() * Math.pow(2, 32)).toString(16), s
                        }, e.prototype.buildObjectWithRule = function() {
                            var e = this.buildObject();
                            return this.buildOnStartRule(e), e
                        }, e.prototype.buildOnStartRule = function(e, t) {
                            var r = this.context;
                            t || (t = this.buildScript()), e || (e = this.buildObject(f.HSObjectType.monkey));
                            var i = new a.HSRule(r);
                            i.script = t, e.addRule(i);
                            var s = new c.HSParameter(r),
                                n = new d.HSParameterBlock(r);
                            return n.type = m.HSBlockType.EventOperatorStart, s.childBlock = n, i.parameters = [s], i.parameters[0].childBlock.parameters[0] = new c.HSParameter(i.context), i.parameters[0].childBlock.parameters[0].childBlock = new d.HSParameterBlock(i.context), i
                        }, e.prototype.buildTapRule = function(e, t) {
                            return this.buildRule(m.HSBlockType.EventOperatorTap, e, t)
                        }, e.prototype.buildRule = function(e, t, r) {
                            var i = this.context;
                            r || (r = this.buildScript()), t || (t = this.buildObject(f.HSObjectType.monkey));
                            var s = new a.HSRule(i);
                            s.script = r, t.addRule(s);
                            var n = new c.HSParameter(i),
                                o = new d.HSParameterBlock(i);
                            return o.type = e, n.childBlock = o, s.parameters = [n], s
                        }, e.prototype.buildScript = function() {
                            return this.buildScript3()
                        }, e.prototype.buildRecursiveScript = function() {
                            var e = new o.HSScript(this.context);
                            return e.blocks = [this.buildControlBlock(m.HSBlockType.Ability, [""], e)], e
                        }, e.prototype.buildEmptyScript = function() {
                            var e = new o.HSScript(this.context);
                            return e.blocks = [], e
                        }, e.prototype.buildScript3 = function() {
                            var e = this.context,
                                t = new o.HSScript(e);
                            return t.blocks = [this.buildControlBlock(m.HSBlockType.Repeat, ["100"], this.buildScript4())], t
                        }, e.prototype.buildScript4 = function() {
                            var e = this.context,
                                t = new o.HSScript(e);
                            return t.blocks = [this.buildMethodBlock(m.HSBlockType.SetInvisibility, ["90"]), this.buildMethodBlock(m.HSBlockType.ChangeSpeed, ["1600"]), this.buildMethodBlock(m.HSBlockType.SetTrailColor, ["HSB(74, 100, 100)"]), this.buildMethodBlock(m.HSBlockType.SetTrailWidth, ["30"]), this.buildMethodBlock(m.HSBlockType.PenDown, []), this.buildMethodBlock(m.HSBlockType.Move, ["200"]), this.buildMethodBlock(m.HSBlockType.PenUp, []), this.buildMethodBlock(m.HSBlockType.Rotate, ["135"]), this.buildMethodBlock(m.HSBlockType.Move, ["200"]), this.buildMethodBlock(m.HSBlockType.Rotate, ["145"])], t
                        }, e.prototype.buildScript2 = function() {
                            var e = this.context,
                                t = new o.HSScript(e);
                            return t.blocks = [this.buildMethodBlock(m.HSBlockType.ChangeSpeed, ["1000"]), this.buildMethodBlock(m.HSBlockType.Move, ["100"]), this.buildMethodBlock(m.HSBlockType.Rotate, ["30"]), this.buildMethodBlock(m.HSBlockType.Move, ["150"]), this.buildMethodBlock(m.HSBlockType.ChangeSpeed, ["100"]), this.buildMethodBlock(m.HSBlockType.Rotate, ["60"]), this.buildMethodBlock(m.HSBlockType.Move, ["200"])], t
                        }, e.prototype.buildScript1 = function() {
                            var e = this.context,
                                t = new o.HSScript(e);
                            return t.blocks = [this.buildMethodBlock(m.HSBlockType.Grow, ["200"]), this.buildMethodBlock(m.HSBlockType.Shrink, ["50"])], t
                        }, e.prototype.buildScript0 = function() {
                            for (var e = this.context, t = new o.HSScript(e), r = [this.buildMethodBlock(m.HSBlockType.SetPosition, ["200", "200"])], i = 0; i < 50; i++) r.push(this.buildMethodBlock(m.HSBlockType.Move, ["200"]));
                            return r.push(this.buildMethodBlock(m.HSBlockType.SetSize, ["200"])), t.blocks = r, t
                        }, e.prototype.buildMethodBlock = function(e, t) {
                            void 0 === e && (e = m.HSBlockType.Move), void 0 === t && (t = []), this.context;
                            var r = this.parametersFromValues(t),
                                i = new p.HSMethodBlock(this.context);
                            return i.type = e, i.parameters = r, i
                        }, e.prototype.parametersFromValues = function(e) {
                            var t = this,
                                r = [];
                            return e.forEach((function(e, i, s) {
                                var n = new c.HSParameter(t.context);
                                e instanceof g.HSVariable ? n.childBlock = e : n.value = e, r.push(n)
                            })), r
                        }, e.prototype.buildControlBlock = function(e, t, r) {
                            void 0 === e && (e = m.HSBlockType.Repeat), void 0 === t && (t = []), r || (r = this.buildScript1());
                            var i = this.parametersFromValues(t),
                                s = new l.HSControlBlock(this.context);
                            return s.type = e, s.parameters = i, s.scripts = [r], s
                        }, e.prototype.buildConditionalControlBlock = function(e, t, r) {
                            void 0 === e && (e = m.HSBlockType.CheckOnceIf), void 0 === t && (t = []), r || (r = this.buildScript1());
                            var i = this.parametersFromValues(t),
                                n = new s.HSConditionalControl(this.context);
                            return n.type = e, n.parameters = i, n.scripts = [r], n
                        }, e
                    }();
                t.HSManagedObjectFactory = y, window.HSManagedObjectFactory = y
            },
            66: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.Vec2 = void 0;
                var r = Float32Array || Array,
                    i = function() {
                        function e(e, t) {
                            void 0 === e && (e = 0), void 0 === t && (t = 0), this.inner = new r(2), this.inner[0] = e, this.inner[1] = t
                        }
                        return Object.defineProperty(e.prototype, 0, {
                            get: function() {
                                return this.inner[0]
                            },
                            set: function(e) {
                                this.inner[0] = e
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e.prototype, 1, {
                            get: function() {
                                return this.inner[1]
                            },
                            set: function(e) {
                                this.inner[1] = e
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e.prototype, "x", {
                            get: function() {
                                return this.inner[0]
                            },
                            set: function(e) {
                                this.inner[0] = e
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e.prototype, "y", {
                            get: function() {
                                return this.inner[1]
                            },
                            set: function(e) {
                                this.inner[1] = e
                            },
                            enumerable: !1,
                            configurable: !0
                        }), e.subtract = function(e, t, r) {
                            return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e
                        }, e.prototype.subtract = function(t, r) {
                            return this.inner = e.subtract(this.inner, t.inner, r.inner), this
                        }, e.len = function(e) {
                            var t = e[0],
                                r = e[1];
                            return Math.sqrt(t * t + r * r)
                        }, e.prototype.len = function() {
                            return e.len(this.inner)
                        }, e.dot = function(e, t) {
                            return e[0] * t[0] + e[1] * t[1]
                        }, e.prototype.dot = function(t) {
                            return e.dot(this.inner, t.inner)
                        }, e.prototype.toString = function() {
                            return "Vec2(".concat(this.inner[0], ", ").concat(this.inner[1], ")")
                        }, e
                    }();
                t.Vec2 = i
            },
            8519: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSMain = t.hsCanLoadEmojis = t.main = void 0;
                var i = r(655),
                    s = r(2127),
                    n = r(37),
                    o = r(9005),
                    a = r(2277),
                    h = r(1925),
                    l = r(682),
                    u = r(3452),
                    c = r(9751),
                    d = r(1296),
                    p = r(445),
                    f = r(66);
                r(8423);
                var m = r(3466),
                    g = i.__importStar(r(8687)),
                    y = i.__importDefault(r(7818));

                function _(e) {
                    var t = new XMLHttpRequest;
                    t.open("GET", "https://d2j12ek52gvmx9.cloudfront.net/emojis/d83d-de0e.png", !0), t.onreadystatechange = function() {
                        4 === t.readyState && e(200 === t.status)
                    }, t.onerror = function() {
                        e(!1)
                    }, t.send(null)
                }
                window.addEventListener("load", (function() {
                    for (var e = document.querySelectorAll("hopscotch-player"), r = e.length; --r >= 0;) window.main = t.main = new v(e[r]), window.addEventListener("resize", (function() {
                        return o.HSApp.sendToApp("resize", "true")
                    }))
                })), t.hsCanLoadEmojis = _, window.addEventListener("error", (function(e) {
                    if (!(0, o.isIOSApp)()) return !1;
                    var r = t.main.projectData.uuid;
                    return console.error("ERROR", e, "uuid", r), o.HSApp.sendToApp("error", JSON.stringify(e) + ";uuid: " + r), !1
                }));
                var v = t.HSMain = function() {
                    function e(t) {
                        this.root = t, this.context = new s.HSProjectContext, this.isMaximized = !1, this.hasDrawn = !1, this.setiOSStageSizeIfNecessary();
                        var r = document.getElementById("project_data"),
                            i = t.dataset.projectJson || r && r.getAttribute("data");
                        i && (this.load(JSON.parse(i)), o.HSApp.sendToApp("playerState", "loaded")), y.default.shared.enable(), this.setSizeFromDataAttrs(), this.background = this.createCanvas("background"), this.drawing = this.createCanvas("drawing"), this.screenshot = this.createCanvas("screenshot"), this.foreground = this.createCanvas("foreground"), this.renderer = new g.Renderer({
                            height: h.HSStageScene.stageHeight,
                            width: h.HSStageScene.stageWidth,
                            resolution: e.dpi,
                            backgroundAlpha: 0,
                            view: this.foreground
                        }), this.screenshotRenderer = new g.Renderer({
                            height: h.HSStageScene.stageHeight,
                            width: h.HSStageScene.stageWidth,
                            resolution: e.dpi,
                            backgroundAlpha: 0,
                            view: this.screenshot
                        });
                        var n = document.getElementById("play_container");
                        n && (n.style.width = "100%", n.style.height = "100%");
                        try {
                            this.visualContext = new d.HSVisualContext(this.background, this.drawing)
                        } catch (e) {
                            console.log("No gl found in this context: ", e)
                        }
                    }
                    return e.getCurrentPlayerName = function() {
                        var e;
                        return ((null === (e = window.ACCOUNT) || void 0 === e ? void 0 : e.user) || {}).nickname || "Guest"
                    }, e.prototype.setSizeFromDataAttrs = function() {
                        this.resizeRoot(+this.root.getAttribute("width"), +this.root.getAttribute("height"))
                    }, e.prototype.createCanvas = function(e) {
                        var t = document.createElement("canvas");
                        return t.setAttribute("name", e), t.style.background = "transparent", t.style.position = "absolute", t.style.top = "0", t.style.left = "0", t.style.width = "100%", t.style.height = "100%", this.root.appendChild(t), t
                    }, e.prototype.toggleFullscreen = function() {
                        this.isFullscreen() ? this.exitFullscreen() : this.enterFullscreen(window.innerWidth, window.innerHeight)
                    }, e.prototype.isFullscreen = function() {
                        return !!document.fullscreenElement || !!document.webkitFullscreenElement || !!document.mozFullScreenElement || !!document.msFullScreenElement || this.isMaximized
                    }, e.prototype.enterFullscreen = function(e, t) {
                        m.CollisionManagerDebug.ENABLED || this.enterFullscreenAction(this.root, e, t)
                    }, e.prototype.enterFullscreenAction = function(e, t, r) {
                        var i = t || window.innerWidth,
                            s = r || window.innerHeight;
                        this.resizeRoot(i, s);
                        var n = e.parentElement;
                        if (n.requestFullscreen) n.requestFullscreen();
                        else if (n.mozRequestFullScreen) n.mozRequestFullScreen();
                        else if (n.webkitRequestFullscreen) n.webkitRequestFullscreen();
                        else if (n.msRequestFullscreen) n.parent.msRequestFullscreen();
                        else {
                            this.isMaximized = !0, this.resizeRoot(i, s), this.root.style.position = "absolute", this.centerOnScreen(i, s);
                            for (var o = 0; o < document.body.children.length; o++) document.body.children[o].style.visibility = "hidden";
                            document.body.style.backgroundColor = "black", this.root.style.visibility = "visible", document.dispatchEvent(new Event("fullscreenchange"))
                        }
                    }, e.prototype.exitFullscreen = function() {
                        if (this.setSizeFromDataAttrs(), document.exitFullscreen) document.exitFullscreen();
                        else if (document.msExitFullscreen) document.msExitFullscreen();
                        else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
                        else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                        else {
                            this.isMaximized = !1, this.root.style.position = "", this.root.style.top = "", this.root.style.left = "";
                            for (var e = 0; e < document.body.children.length; e++) document.body.children[e].style.visibility = "";
                            document.body.style.backgroundColor = "", this.root.style.visibility = "", document.dispatchEvent(new Event("fullscreenchange"))
                        }
                    }, e.prototype.resizeRoot = function(e, t) {
                        void 0 === e && (e = this._oldWidth), void 0 === t && (t = this._oldHeight), this._oldWidth = e, this._oldHeight = t;
                        var r = h.HSStageScene.stageWidth,
                            i = h.HSStageScene.stageHeight;
                        e || t ? e && !t ? t = e * i / r : !e && t && (e = t * r / i) : (e = window.innerWidth - 20, t = window.innerHeight - 250), r > i ? this.resizeRootLandscape(e, t, r, i) : this.resizeRootPortrait(e, t, r, i)
                    }, e.prototype.resizeRootLandscape = function(t, r, i, s) {
                        var n = Math.min(r / s, t / i),
                            o = Math.max(Math.floor(i * n), e.MIN_STAGE_WIDTH),
                            a = o * (s / i);
                        this.root.style.width = "".concat(Math.floor(o), "px"), this.root.style.height = "".concat(Math.floor(a), "px"), this.isMaximized && this.centerOnScreen(t, r)
                    }, e.prototype.resizeRootPortrait = function(e, t, r, i) {
                        var s = Math.min(t / i, e / r),
                            n = Math.floor(i * s),
                            o = n * (r / i);
                        this.root.style.width = "".concat(Math.floor(o), "px"), this.root.style.height = "".concat(Math.floor(n), "px"), this.isMaximized && this.centerOnScreen(e, t)
                    }, e.prototype.centerOnScreen = function(e, r) {
                        var i = e || window.innerWidth,
                            s = r || window.innerHeight;
                        this.root.style.top = Math.floor((s - t.main.root.offsetHeight) / 2) + "px", this.root.style.left = Math.floor((i - t.main.root.offsetWidth) / 2) + "px"
                    }, e.prototype.load = function(e) {
                        this.projectData = e, o.HSApp.initUserVariables(this.uuid, this.editedAt), this.context = new s.HSProjectContext, this.project = new c.HSProject(this.context, e), u.HSSoundManager.sharedInstance = new u.HSSoundManager(this.context.allSoundNames(), this.context.hasNoiseEvent())
                    }, e.prototype.mute = function() {
                        u.HSSoundManager.sharedInstance.mute()
                    }, e.prototype.unmute = function() {
                        u.HSSoundManager.sharedInstance.unmute()
                    }, e.prototype.isMuted = function() {
                        return u.HSSoundManager.sharedInstance.isMuted
                    }, e.prototype.setiOSStageSizeIfNecessary = function() {
                        if ("container" === this.root.getAttribute("stage-size")) {
                            var e = this.root.getBoundingClientRect();
                            h.HSStageScene.stageWidth = e.width, h.HSStageScene.stageHeight = e.height
                        }
                    }, e.prototype.willPlay = function(e) {
                        var t;
                        window.project_error && (window.project_error.style.display = "none"), e && this.load(e), h.HSStageScene.promptsToExecute = [], (0, o.isIOSApp)() || null === (t = document.querySelector("div.hs-popup")) || void 0 === t || t.remove(), this.stageProject = this.project.buildStageProject(), this.stageProject.stageScenes.flatMap((function(e) {
                            return e.stageObjects
                        })).forEach((function(e) {
                            return e.executeScripts()
                        })), this.stageProject.activateAllRulesForEventType(p.HSBlockType.EventOperatorStart), this.stageProject.executeAllActiveRules(), this.hasDrawn || this.prepareForFirstPlay(), this.registerEventCallbacks()
                    }, e.prototype.prepareForFirstPlay = function() {
                        var e = this,
                            t = [],
                            r = this.renderer;
                        this.stageProject.activeStageScene.stageObjects.forEach((function(e) {
                            var i = e.view.buildAllTextures().then((function(e) {
                                for (var t = 0; t < e.length; t++) r.bindTexture && r.bindTexture(e[t])
                            }));
                            t.push(i)
                        })), Promise.all(t).then((function() {
                            e.hasDrawn = !0, o.HSApp.sendToApp("playerState", "ready")
                        })).catch((function(e) {
                            setTimeout((function() {
                                throw "error building initial textures " + JSON.stringify(e)
                            }))
                        }))
                    }, e.prototype.startProject = function() {
                        o.HSApp.reset(), this.stageProject.shouldResetSceneVisuals = !0, petrichorAnimationTick()//this.animationTick()
                    }, e.prototype.play = function(t) {
                        var r = this;
                        _((function(i) {
                            i || (e.HS_EMOJI_HOST = location.protocol + "//d2j12ek52gvmx9.cloudfront.net/emojis"), r.resetStage(), r.willPlay(t), r.startProject()
                        }))
                    }, e.prototype.resetStage = function() {
                        this.animationFrameReq && (this.visualContext.drawingContext.clear(), window.cancelAnimationFrame(this.animationFrameReq), this.animationFrameReq = null)
                    }, e.prototype.renderFrameForBackgroundAndDrawing = function() {
                        var e = this;
                        if (l.DEBUG_DRAW_BOUNDING_BOXES) {
                            var t = this.drawing;
                            this.visualContext.drawingContext.dwContext.clearRect(0, 0, t.width, t.height)
                        }
                        this.stageProject.activeStageScene.stageObjects.forEach((function(t) {
                            t.shouldSetBackground && (e.visualContext.backgroundContext.setBackground(t.backgroundColor), t.shouldSetBackground = !1), t.shouldClear && (e.visualContext.drawingContext.clear(), t.shouldClear = !1), t.drawPath(e.visualContext.drawingContext)
                        }))
                    }, e.prototype.registerEventCallbacks = function() {
                        var e = this;
                        (this.project.context.hasAccelerometerEvent() || this.project.context.hasAccelerometerTrait()) && n.HSAccelerometerManager.startAccelerometerUpdates(), this.listeners && this.listeners.unregister(), this.listeners = (0, a.UIRegisterEventCallbacks)(this.root, {
                            pointerDown: function(t) {
                                e.stageProject && (e.stageProject.receiveClickEvent(t, e.visualContext.collisionContext), e.stageProject.receiveTouchDownEvent(t, e.visualContext.collisionContext))
                            },
                            pointerUp: function(t) {
                                e.stageProject && e.stageProject.receiveTouchUpEvent(t, e.visualContext.collisionContext)
                            },
                            pointerDrag: function(t) {
                                e.stageProject && e.stageProject.receiveTouchMoveEvent(t, e.visualContext.collisionContext)
                            },
                            pointerCancel: function(t) {
                                e.stageProject && e.stageProject.receiveTouchUpEvent(t, e.visualContext.collisionContext)
                            }
                        })
                    }, e.prototype.animationTick = function() {
                        // this.stageProject.animationTick(this.visualContext.collisionContext, this.visualContext)
						// /*PETRICHOR DEBUGGER MOD START*/
						// petrichorCurrentFrameStateStack.push({state: petrichorCurrentFrameStateStack.postFrame})
						// /*PETRICHOR DEBUGGER MOD END*/
						// this.renderer.render(this.stageProject.activeStageScene.container), this.renderFrameForBackgroundAndDrawing(), this.showPrompts(), this.requestNextFrame(), this.updateAndCleanKeyboardEvents()
						// /*PETRICHOR DEBUGGER MOD START*/
						// petrichorCurrentFrameStateStack.pop()
						/*PETRICHOR DEBUGGER MOD START*/
                    }, e.prototype.updateAndCleanKeyboardEvents = function() {
                        y.default.shared.update(.0166)
                    }, e.prototype.showPrompts = function() {
                        var e = h.HSStageScene.promptsToExecute[0];
                        null == e || e.execute(), (null == e ? void 0 : e.isDone) && h.HSStageScene.promptsToExecute.shift()
                    }, e.prototype.requestNextFrame = function() {
                        var e = this;
                        this.animationFrameReq = window.requestAnimationFrame((function(t) {
                            o.HSApp.isRunning ? petrichorStep() : e.requestNextFrame()
                        }))
                    }, e.prototype.takeScreenshot = function() {
                        this.screenshotRenderer.render(this.stageProject.activeStageScene.container), this.screenshot.style.zIndex = "99999", this.foreground.style.opacity = "0", this.screenshot.style.opacity = "1", setTimeout(o.HSApp.sendToApp.bind(void 0, "screenshot", "done"), 400)
                    }, e.prototype.releaseScreenshot = function() {
                        this.screenshot.style.zIndex = "-99999", this.foreground.style.opacity = "1", this.screenshot.style.opacity = "0"
                    }, Object.defineProperty(e.prototype, "uuid", {
                        get: function() {
                            return this.projectData.uuid || ""
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(e.prototype, "editedAt", {
                        get: function() {
                            return this.projectData.edited_at || ""
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.HS_EMOJI_HOST = "", e.currentPlayerName = e.getCurrentPlayerName(), e.MIN_STAGE_WIDTH = 210, e.dpi = Math.min(window.devicePixelRatio, 2), e
                }();
                window.HSMain = v, window.Vec2 = f.Vec2
            },
            4222: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSBlock = t.HSBlockClass = t.PARAMS_KEY = t.PARAMETERS_KEY = t.BLOCK_TYPE_KEY = void 0;
                var i, s = r(655),
                    n = r(4662),
                    o = r(9002),
                    a = r(3724),
                    h = r(445);
                t.BLOCK_TYPE_KEY = "type", t.PARAMETERS_KEY = "parameters", t.PARAMS_KEY = "params",
                    function(e) {
                        e[e.Method = 0] = "Method", e[e.Control = 1] = "Control", e[e.ConditionalControl = 2] = "ConditionalControl", e[e.Variable = 3] = "Variable"
                    }(i = t.HSBlockClass || (t.HSBlockClass = {}));
                var l = t.HSBlock = function(e) {
                    function r() {
                        var t = null !== e && e.apply(this, arguments) || this;
                        return t.parameters = [], t.isControl = !1, t
                    }
                    return s.__extends(r, e), r.prototype.parseJSON = function(e) {
                        var r = this;
                        /*PETRICHOR MOD START*/
                        this.PETRICHOR_BREAKPOINT_POSITION = e.PETRICHOR_BREAKPOINT_POSITION
                        /*PETRICHOR MOD END*/
                        void 0 === e && (e = {}), this.type = this.type || parseInt(e[t.BLOCK_TYPE_KEY]), (e[t.PARAMETERS_KEY] || e[t.PARAMS_KEY] || []).forEach((function(e) {
                            var t = new o.HSParameter(r.context);
                            t.parentNode = r, t.parseJSON(e), r.parameters.push(t)
                        }))
                    }, r.prototype.stageParameters = function(e) {
                        return this.parameters.map((function(t) {
                            return t.stageParameter(e)
                        }))
                    }, r.prototype.toString = function() {
                        return a.SourceFormatter.blockToSrc(this)
                    }, r.blockClassForDict = function(e) {
                        switch (void 0 === e && (e = {}), e[t.BLOCK_TYPE_KEY]) {
                            case h.HSBlockType.Repeat:
                            case h.HSBlockType.LeaveATrail:
                            case h.HSBlockType.RepeatForever:
                            case h.HSBlockType.Ability:
                                return i.Control;
                            case h.HSBlockType.CheckOnceIf:
                            case h.HSBlockType.CheckIfElse:
                                return i.ConditionalControl
                        }
                        return i.Method
                    }, r.key = "HSBlock", r
                }(n.HSManagedObject);
                window.HSBlockClass = i, window.HSBlock = l, window.BLOCK_TYPE_KEY = t.BLOCK_TYPE_KEY, window.PARAMETERS_KEY = t.PARAMETERS_KEY, window.PARAMS_KEY = t.PARAMS_KEY
            },
            445: (e, t) => {
                "use strict";
                var r, i;
                Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.blockTypeForLegacyEventType = t.HSEventType = t.HSBlockType = void 0,
                    function(e) {
                        e[e.WaitTilTimestamp = 19] = "WaitTilTimestamp", e[e.WaitUntilInputIsDone = 20] = "WaitUntilInputIsDone", e[e.None = 22] = "None", e[e.Move = 23] = "Move", e[e.Rotate = 24] = "Rotate", e[e.ChangeX = 27] = "ChangeX", e[e.ChangeY = 28] = "ChangeY", e[e.Scale = 29] = "Scale", e[e.Clear = 30] = "Clear", e[e.SetTrailWidth = 31] = "SetTrailWidth", e[e.SetTrailColor = 32] = "SetTrailColor", e[e.ChangeCostume = 33] = "ChangeCostume", e[e.ChangeSpeed = 34] = "ChangeSpeed", e[e.Wait = 35] = "Wait", e[e.SetOpacity = 36] = "SetOpacity", e[e.PenDown = 37] = "PenDown", e[e.PenUp = 38] = "PenUp", e[e.SetHeading = 39] = "SetHeading", e[e.SetText = 40] = "SetText", e[e.SetPosition = 41] = "SetPosition", e[e.SendToBack = 42] = "SendToBack", e[e.BringToFront = 43] = "BringToFront", e[e.ChangeVariable = 44] = "ChangeVariable", e[e.SetVariable = 45] = "SetVariable", e[e.MoveWithTrail = 46] = "MoveWithTrail", e[e.SetInvisibility = 47] = "SetInvisibility", e[e.Grow = 48] = "Grow", e[e.Shrink = 49] = "Shrink", e[e.Flip = 50] = "Flip", e[e.SetSize = 51] = "SetSize", e[e.PlaySound = 52] = "PlaySound", e[e.MakeAClone = 53] = "MakeAClone", e[e.SetColor = 54] = "SetColor", e[e.Destroy = 55] = "Destroy", e[e.SetImage = 56] = "SetImage", e[e.SetWidthAndHeight = 57] = "SetWidthAndHeight", e[e.SetZIndex = 58] = "SetZIndex", e[e.SetOriginXY = 59] = "SetOriginXY", e[e.SetCenterXY = 60] = "SetCenterXY", e[e.WaitSeconds = 61] = "WaitSeconds", e[e.PlaySoundSeconds = 62] = "PlaySoundSeconds", e[e.SaveInput = 63] = "SaveInput", e[e.SetTextToInput = 64] = "SetTextToInput", e[e.PlayNote = 65] = "PlayNote", e[e.SetTempo = 66] = "SetTempo", e[e.SetInstrument = 67] = "SetInstrument", e[e.OpenProject = 68] = "OpenProject", e[e.Comment = 69] = "Comment", e[e.SetBackground = 70] = "SetBackground", e[e.SetTrailCap = 71] = "SetTrailCap", e[e.ShowPopup = 72] = "ShowPopup", e[e.SetTrailOpacity = 73] = "SetTrailOpacity", e[e.LeaveATrail = 26] = "LeaveATrail", e[e.Repeat = 120] = "Repeat", e[e.RepeatForever = 121] = "RepeatForever", e[e.CheckOnceIf = 122] = "CheckOnceIf", e[e.Ability = 123] = "Ability", e[e.CheckIfElse = 124] = "CheckIfElse", e[e.ChangeScene = 125] = "ChangeScene", e[e.BroadcastMessage = 126] = "BroadcastMessage", e[e.RequestSeeds = 127] = "RequestSeeds", e[e.Random = 233] = "Random", e[e.XPos = 234] = "XPos", e[e.YPos = 235] = "YPos", e[e.Random110 = 236] = "Random110", e[e.Random1100 = 237] = "Random1100", e[e.Random11000 = 238] = "Random11000", e[e.Variable = 239] = "Variable", e[e.ConditionalOperatorEquals = 1e3] = "ConditionalOperatorEquals", e[e.ConditionalOperatorNotEquals = 1001] = "ConditionalOperatorNotEquals", e[e.ConditionalOperatorLessThan = 1002] = "ConditionalOperatorLessThan", e[e.ConditionalOperatorGreaterThan = 1003] = "ConditionalOperatorGreaterThan", e[e.ConditionalOperatorAnd = 1004] = "ConditionalOperatorAnd", e[e.ConditionalOperatorOr = 1005] = "ConditionalOperatorOr", e[e.ConditionalOperatorGreaterThanOrEqualTo = 1006] = "ConditionalOperatorGreaterThanOrEqualTo", e[e.ConditionalOperatorLessThanOrEqualTo = 1007] = "ConditionalOperatorLessThanOrEqualTo", e[e.ConditionalOperatorMatches = 1008] = "ConditionalOperatorMatches", e[e.ConditionalOperatorNot = 1009] = "ConditionalOperatorNot", e[e.ConditionalOperatorIsFlipped = 1010] = "ConditionalOperatorIsFlipped", e[e.HS_END_OF_CONDITIONAL_OPERATORS = 1011] = "HS_END_OF_CONDITIONAL_OPERATORS", e[e.TraitRotation = 2e3] = "TraitRotation", e[e.TraitXPosition = 2001] = "TraitXPosition", e[e.TraitYPosition = 2002] = "TraitYPosition", e[e.TraitInvisibility = 2003] = "TraitInvisibility", e[e.TraitSize = 2004] = "TraitSize", e[e.TraitSpeed = 2005] = "TraitSpeed", e[e.TraitCloneIndex = 2006] = "TraitCloneIndex", e[e.TraitTotalClones = 2007] = "TraitTotalClones", e[e.TraitWidth = 2008] = "TraitWidth", e[e.TraitHeight = 2009] = "TraitHeight", e[e.TraitZIndex = 2010] = "TraitZIndex", e[e.TraitOriginX = 2011] = "TraitOriginX", e[e.TraitOriginY = 2012] = "TraitOriginY", e[e.TraitCenterX = 2013] = "TraitCenterX", e[e.TraitCenterY = 2014] = "TraitCenterY", e[e.TraitText = 2015] = "TraitText", e[e.TraitTempo = 2016] = "TraitTempo", e[e.TraitInstrument = 2017] = "TraitInstrument", e[e.TraitObjectName = 2018] = "TraitObjectName", e[e.HS_END_OF_OBJECT_TRAITS = 2019] = "HS_END_OF_OBJECT_TRAITS", e[e.TraitUsername = 2500] = "TraitUsername", e[e.TraitTime = 2501] = "TraitTime", e[e.TraitYear = 2502] = "TraitYear", e[e.TraitMonth = 2503] = "TraitMonth", e[e.TraitDay = 2504] = "TraitDay", e[e.TraitHour = 2505] = "TraitHour", e[e.TraitMinute = 2506] = "TraitMinute", e[e.TraitSecond = 2507] = "TraitSecond", e[e.HS_END_OF_USER_TRAITS = 2508] = "HS_END_OF_USER_TRAITS", e[e.StageTraitWidth = 3e3] = "StageTraitWidth", e[e.StageTraitHeight = 3001] = "StageTraitHeight", e[e.StageTraitTiltUp = 3002] = "StageTraitTiltUp", e[e.StageTraitTiltDown = 3003] = "StageTraitTiltDown", e[e.StageTraitTiltLeft = 3004] = "StageTraitTiltLeft", e[e.StageTraitTiltRight = 3005] = "StageTraitTiltRight", e[e.StageTraitLastTouchX = 3006] = "StageTraitLastTouchX", e[e.StageTraitLastTouchY = 3007] = "StageTraitLastTouchY", e[e.StageTraitTotalObjects = 3008] = "StageTraitTotalObjects", e[e.HS_END_OF_STAGE_TRAITS = 3009] = "HS_END_OF_STAGE_TRAITS", e[e.MathOperatorAdd = 4e3] = "MathOperatorAdd", e[e.MathOperatorSubtract = 4001] = "MathOperatorSubtract", e[e.MathOperatorMultiply = 4002] = "MathOperatorMultiply", e[e.MathOperatorDivide = 4003] = "MathOperatorDivide", e[e.MathOperatorRandom = 4004] = "MathOperatorRandom", e[e.MathOperatorPower = 4005] = "MathOperatorPower", e[e.MathOperatorSquareRoot = 4006] = "MathOperatorSquareRoot", e[e.MathOperatorSine = 4007] = "MathOperatorSine", e[e.MathOperatorCosine = 4008] = "MathOperatorCosine", e[e.MathOperatorRound = 4009] = "MathOperatorRound", e[e.MathOperatorAbs = 4010] = "MathOperatorAbs", e[e.MathOperatorModulo = 4011] = "MathOperatorModulo", e[e.MathOperatorTangent = 4012] = "MathOperatorTangent", e[e.MathOperatorInverseSine = 4013] = "MathOperatorInverseSine", e[e.MathOperatorInverseCosine = 4014] = "MathOperatorInverseCosine", e[e.MathOperatorInverseTangent = 4015] = "MathOperatorInverseTangent", e[e.MathOperatorMaximum = 4016] = "MathOperatorMaximum", e[e.MathOperatorMinimum = 4017] = "MathOperatorMinimum", e[e.MathOperatorFloor = 4018] = "MathOperatorFloor", e[e.MathOperatorCeiling = 4019] = "MathOperatorCeiling", e[e.HS_END_OF_MATH_OPERATORS = 4020] = "HS_END_OF_MATH_OPERATORS", e[e.ColorOperatorRandom = 5e3] = "ColorOperatorRandom", e[e.ColorOperatorRGB = 5001] = "ColorOperatorRGB", e[e.ColorOperatorHSB = 5002] = "ColorOperatorHSB", e[e.HS_END_OF_COLOR_OPERATORS = 5003] = "HS_END_OF_COLOR_OPERATORS", e[e.Rule = 6e3] = "Rule", e[e.RulePreview = 6001] = "RulePreview", e[e.EventOperatorStart = 7e3] = "EventOperatorStart", e[e.EventOperatorTap = 7001] = "EventOperatorTap", e[e.EventOperatorIsTouching = 7002] = "EventOperatorIsTouching", e[e.EventOperatorHold = 7003] = "EventOperatorHold", e[e.EventOperatorTiltRight = 7004] = "EventOperatorTiltRight", e[e.EventOperatorTiltLeft = 7005] = "EventOperatorTiltLeft", e[e.EventOperatorTiltUp = 7006] = "EventOperatorTiltUp", e[e.EventOperatorTiltDown = 7007] = "EventOperatorTiltDown", e[e.EventOperatorLoudNoise = 7008] = "EventOperatorLoudNoise", e[e.EventOperatorShake = 7009] = "EventOperatorShake", e[e.EventOperatorBump = 7010] = "EventOperatorBump", e[e.EventOperatorSwipeRight = 7011] = "EventOperatorSwipeRight", e[e.EventOperatorSwipeLeft = 7012] = "EventOperatorSwipeLeft", e[e.EventOperatorSwipeUp = 7013] = "EventOperatorSwipeUp", e[e.EventOperatorSwipeDown = 7014] = "EventOperatorSwipeDown", e[e.EventOperatorEnterTheWorld = 7015] = "EventOperatorEnterTheWorld", e[e.EventOperatorTiltRightEditor = 7016] = "EventOperatorTiltRightEditor", e[e.EventOperatorTiltLeftEditor = 7017] = "EventOperatorTiltLeftEditor", e[e.EventOperatorTiltUpEditor = 7018] = "EventOperatorTiltUpEditor", e[e.EventOperatorTiltDownEditor = 7019] = "EventOperatorTiltDownEditor", e[e.EventOperatorNotPressed = 7020] = "EventOperatorNotPressed", e[e.EventOperatorGamePlaying = 7021] = "EventOperatorGamePlaying", e[e.EventOperatorTouchEnds = 7022] = "EventOperatorTouchEnds", e[e.EventOperatorHearMessage = 7023] = "EventOperatorHearMessage", e[e.EventOperatorMessageMatches = 7024] = "EventOperatorMessageMatches", e[e.EventOperatorIsNotTouching = 7025] = "EventOperatorIsNotTouching", e[e.HS_END_OF_EVENT_OPERATORS = 7026] = "HS_END_OF_EVENT_OPERATORS", e[e.Object = 8e3] = "Object", e[e.AnyObject = 8001] = "AnyObject", e[e.ScreenEdge = 8002] = "ScreenEdge", e[e.Game = 8003] = "Game", e[e.Self = 8004] = "Self", e[e.OriginalObject = 8005] = "OriginalObject", e[e.Local = 8006] = "Local", e[e.User = 8007] = "User", e[e.Product = 8008] = "Product", e[e.Scoped = 8009] = "Scoped", e[e.HS_END_OF_EVENT_PARAMETER_BLOCKS = 8010] = "HS_END_OF_EVENT_PARAMETER_BLOCKS", e[e.TextOperatorCharAtIndex = 9e3] = "TextOperatorCharAtIndex", e[e.TextOperatorCharsInRange = 9001] = "TextOperatorCharsInRange", e[e.TextOperatorLength = 9002] = "TextOperatorLength", e[e.TextOperatorJoin = 9003] = "TextOperatorJoin", e[e.HS_END_OF_TEXT_OPERATOR_BLOCKS = 9004] = "HS_END_OF_TEXT_OPERATOR_BLOCKS", e[e.SceneReferenceBlock = 1e4] = "SceneReferenceBlock", e[e.PreviousSceneParameter = 10001] = "PreviousSceneParameter", e[e.NextSceneParameter = 10002] = "NextSceneParameter", e[e.HS_END_OF_SCENE_REFERENCE_BLOCKS = 10003] = "HS_END_OF_SCENE_REFERENCE_BLOCKS"
                    }(r = t.HSBlockType || (t.HSBlockType = {})),
                    function(e) {
                        e[e.HSEventOnStart = 1239] = "HSEventOnStart", e[e.HSEventTouchedObject = 1240] = "HSEventTouchedObject", e[e.HSEventTapStage = 1241] = "HSEventTapStage", e[e.HSEventShake = 1242] = "HSEventShake", e[e.HSEventTiltRight = 1243] = "HSEventTiltRight", e[e.HSEventTiltLeft = 1244] = "HSEventTiltLeft", e[e.HSEventTiltDown = 1245] = "HSEventTiltDown", e[e.HSEventTiltUp = 1246] = "HSEventTiltUp", e[e.HSEventLoudNoise = 1247] = "HSEventLoudNoise", e[e.HSEventCollision = 1248] = "HSEventCollision", e[e.HSEventHeldObject = 1249] = "HSEventHeldObject", e[e.HSEventEnteredWorld = 1250] = "HSEventEnteredWorld"
                    }(i = t.HSEventType || (t.HSEventType = {})), t.blockTypeForLegacyEventType = function(e) {
                        switch (e) {
                            case i.HSEventOnStart:
                                return r.EventOperatorStart;
                            case i.HSEventShake:
                                return r.EventOperatorShake;
                            case i.HSEventTiltUp:
                                return r.EventOperatorTiltUp;
                            case i.HSEventTiltDown:
                                return r.EventOperatorTiltDown;
                            case i.HSEventTiltRight:
                                return r.EventOperatorTiltRight;
                            case i.HSEventTiltLeft:
                                return r.EventOperatorTiltLeft;
                            case i.HSEventTapStage:
                            case i.HSEventTouchedObject:
                                return r.EventOperatorTap;
                            case i.HSEventLoudNoise:
                                return r.EventOperatorLoudNoise;
                            case i.HSEventCollision:
                                return r.EventOperatorIsTouching;
                            case i.HSEventHeldObject:
                                return r.EventOperatorHold;
                            case i.HSEventEnteredWorld:
                                return r.EventOperatorEnterTheWorld
                        }
                        return r.EventOperatorStart
                    }, window.HSBlockType = r, window.HSEventType = i
            },
            3025: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSConditionalControl = t.FALSE_SCRIPT_KEY = void 0;
                var i = r(655),
                    s = r(662),
                    n = r(5291),
                    o = r(7069),
                    a = r(9470);
                t.FALSE_SCRIPT_KEY = "controlFalseScript";
                var h = t.HSConditionalControl = function(e) {
                    function r() {
                        return null !== e && e.apply(this, arguments) || this
                    }
                    return i.__extends(r, e), r.prototype.parseJSON = function(r) {
                        void 0 === r && (r = {}), e.prototype.parseJSON.call(this, r);
                        var i = (r[t.FALSE_SCRIPT_KEY] || [])[s.SCRIPT_ID_KEY] || "",
                            n = this.context.findWithObjectID("HSScript", i);
                        n && (n.parentNode = this), this.scripts.push(n || new a.HSScript(this.context))
                    }, r.prototype.stageBlock = function(e) {
                        var t = new n.HSStageControl(this.type, this.stageParameters(e), e),
                            r = this.trueScript().stageScript(t),
                            i = this.falseScript().stageScript(t);
                        return t.scripts = [r, i], t
                    }, r.prototype.trueScript = function() {
                        return this.scripts[0]
                    }, r.prototype.falseScript = function() {
                        return this.scripts[1]
                    }, r.key = "HSConditionalControl", r
                }(o.HSControlBlock);
                window.HSConditionalControl = h
            },
            7069: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSControlBlock = t.CONTROL_SCRIPT_KEY = void 0;
                var i = r(655),
                    s = r(662),
                    n = r(4222),
                    o = r(9470),
                    a = r(5291);
                t.CONTROL_SCRIPT_KEY = "controlScript";
                var h = t.HSControlBlock = function(e) {
                    function r() {
                        var t = null !== e && e.apply(this, arguments) || this;
                        return t.scripts = [], t.isControl = !0, t
                    }
                    return i.__extends(r, e), r.prototype.stageBlock = function(e) {
                        var t = new a.HSStageControl(this.type, this.stageParameters(e), e),
                            r = (this.scripts[0] || new o.HSScript(this.context)).stageScript(t);
                        /*PETRICHOR MOD START*/
                        t.PETRICHOR_BREAKPOINT_POSITION = this.PETRICHOR_BREAKPOINT_POSITION
                        /*PETRICHOR MOD END*/
                        return t.scripts = [r], t
                    }, r.prototype.parseJSON = function(r) {
                        void 0 === r && (r = {}), e.prototype.parseJSON.call(this, r);
                        var i = (r[t.CONTROL_SCRIPT_KEY] || [])[s.SCRIPT_ID_KEY] || "",
                            n = this.context.findWithObjectID("HSScript", i);
                        n && (n.parentNode = this), this.scripts.push(n || new o.HSScript(this.context))
                    }, r.key = "HSControlBlock", r
                }(n.HSBlock);
                window.HSControlBlock = h
            },
            1559: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSEventParameterBlock = t.EVENT_PARAMETER_OBJECT_KEY = t.EVENT_PARAMETER_TYPE_KEY = t.EVENT_PARAMETER_OBJECT_ID_KEY = void 0;
                var i = r(655),
                    s = r(6642),
                    n = r(7351);
                t.EVENT_PARAMETER_OBJECT_ID_KEY = "id", t.EVENT_PARAMETER_TYPE_KEY = "blockType", t.EVENT_PARAMETER_OBJECT_KEY = "objectID";
                var o = t.HSEventParameterBlock = function(e) {
                    function r() {
                        return null !== e && e.apply(this, arguments) || this
                    }
                    return i.__extends(r, e), r.prototype.parseJSON = function(r) {
                        void 0 === r && (r = {}), e.prototype.parseJSON.call(this, r), this.objectID = r[t.EVENT_PARAMETER_OBJECT_ID_KEY], this.type = r[t.EVENT_PARAMETER_TYPE_KEY];
                        var i = this.context.findWithObjectID(s.HSObject.key, r[t.EVENT_PARAMETER_OBJECT_KEY]);
                        this.object = i
                    }, r.key = "HSEventParameterBlock", r
                }(n.HSParameterBlock);
                window.HSEventParameterBlock = o
            },
            1477: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSLocalVariable = void 0;
                var i = r(655),
                    s = r(861),
                    n = r(9002),
                    o = r(7351),
                    a = r(1209),
                    h = function(e) {
                        function t() {
                            return null !== e && e.apply(this, arguments) || this
                        }
                        return i.__extends(t, e), t.prototype.parseJSON = function(t) {
                            void 0 === t && (t = {}), e.prototype.parseJSON.call(this, t), this.name = t.name, this.name || (this.name = this.context.findWithObjectID(s.HSVariablePrototype.key, t[n.VARIABLE_KEY]).name)
                        }, t.prototype.stageParameterBlock = function(e) {
                            return new a.HSStageLocalVariable(this.name, e)
                        }, t
                    }(o.HSParameterBlock);
                t.HSLocalVariable = h, window.HSLocalVariable = h
            },
            450: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSMethodBlock = void 0;
                var i = r(655),
                    s = r(781),
                    n = r(4222),
                    o = t.HSMethodBlock = function(e) {
                        function t() {
                            return null !== e && e.apply(this, arguments) || this
                        }
                        return i.__extends(t, e), t.prototype.stageBlock = function(e) {
                            /*PETRICHOR MOD START*/
                            const result = new s.HSStageMethod(this.type, this.stageParameters(e), e)
                            result.PETRICHOR_BREAKPOINT_POSITION = this.PETRICHOR_BREAKPOINT_POSITION
                            return result
                            /*PETRICHOR MOD END*/
                        }, t.key = "HSMethodBlock", t
                    }(n.HSBlock);
                window.HSMethodBlock = o
            },
            7351: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSParameterBlock = t.TRAIT_TYPE_KEY = t.TRAIT_ID_KEY = t.TRAIT_OBJECT_ID_KEY = void 0;
                var i = r(655),
                    s = r(4222),
                    n = r(6642),
                    o = r(1972);
                t.TRAIT_OBJECT_ID_KEY = "HSTraitObjectIDKey", t.TRAIT_ID_KEY = "HSTraitIDKey", t.TRAIT_TYPE_KEY = "HSTraitTypeKey";
                var a = t.HSParameterBlock = function(e) {
                    function r() {
                        return null !== e && e.apply(this, arguments) || this
                    }
                    return i.__extends(r, e), r.prototype.parseJSON = function(r) {
                        void 0 === r && (r = {}), e.prototype.parseJSON.call(this, r), r[t.TRAIT_ID_KEY] && this.parseTrait(r)
                    }, r.prototype.stageParameterBlock = function(e) {
                        var t = this.parameters.map((function(t) {
                            return t.stageParameter(e)
                        }));
                        return new o.HSStageParameterBlock(this.type, this.objectReferenceType, this.object, t, this.context, e, this.sceneID)
                    }, r.prototype.parseTrait = function(e) {
                        this.object = this.context.findWithObjectID(n.HSObject.key, e[t.TRAIT_OBJECT_ID_KEY]), this.objectID = e[t.TRAIT_ID_KEY], this.type = e[t.TRAIT_TYPE_KEY], this.objectReferenceType = e.HSTraitObjectParameterTypeKey
                    }, r.key = "HSParameterBlock", r
                }(s.HSBlock);
                window.HSParameterBlock = a
            },
            5136: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSSceneReferenceBlock = t.SCENE_REFERENCE_SCENE_KEY = t.SCENE_REFERENCE_TYPE_KEY = t.SCENE_REFERENCE_ID_KEY = void 0;
                var i = r(655),
                    s = r(7351);
                t.SCENE_REFERENCE_ID_KEY = "id", t.SCENE_REFERENCE_TYPE_KEY = "blockType", t.SCENE_REFERENCE_SCENE_KEY = "scene";
                var n = t.HSSceneReferenceBlock = function(e) {
                    function r() {
                        return null !== e && e.apply(this, arguments) || this
                    }
                    return i.__extends(r, e), r.prototype.parseJSON = function(r) {
                        void 0 === r && (r = {}), e.prototype.parseJSON.call(this, r), this.objectID = r[t.SCENE_REFERENCE_ID_KEY], this.type = r[t.SCENE_REFERENCE_TYPE_KEY], this.sceneID = r[t.SCENE_REFERENCE_SCENE_KEY]
                    }, r.key = "HSSceneReferenceBlock", r
                }(s.HSParameterBlock);
                window.HSSceneReferenceBlock = n
            },
            2983: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSVariable = t.HSStageVariable = void 0;
                var i = r(655),
                    s = r(6642),
                    n = r(9002),
                    o = r(861),
                    a = r(7351),
                    h = r(445),
                    l = r(9005),
                    u = r(1972),
                    c = "_hs_",
                    d = t.HSStageVariable = function(e) {
                        function t(t, r, i, n, o, a) {
                            var l = e.call(this, h.HSBlockType.Variable, r, o.findWithObjectID(s.HSObject.key, n), [], o, a) || this;
                            return l.name = t, l.blockType = r, l.objectID = i, l.associatedObjectID = n, l
                        }
                        return i.__extends(t, e), t.prototype.computedValue = function(e) {
                            if (this.blockType === h.HSBlockType.Product) return l.HSApp.initialUserVariables["_hs_product_" + this.objectID] || "0";
                            var t = this._object(e);
                            return t && t[this.name] || 0
                        }, t.prototype.computedNumberValue = function(e) {
                            return t.parseNumberFrom(this.computedValue(e))
                        }, t.prototype.setValue = function(e, t) {
                            this._object(t)[this.name] = e, this.storeUserValueIfNeeded(e.toString())
                        }, t.prototype.storeUserValueIfNeeded = function(e) {
                            this.blockType === h.HSBlockType.User && ((0, l.isIOSApp)() ? l.HSApp.sendToApp("setVariable", JSON.stringify({
                                variableValue: e,
                                variableName: this.name.replace(c, ""),
                                variableID: this.objectID
                            })) : l.HSApp.storeUserVar(this.objectID, e))
                        }, t.prototype._object = function(e) {
                            var r;
                            return this.blockType === h.HSBlockType.Game ? t.globalScope : this.blockType === h.HSBlockType.User ? t.userGlobalScope : this.blockType === h.HSBlockType.Object && this.object ? null === (r = this.object) || void 0 === r ? void 0 : r.allStageObjects()[0] : this.blockType === h.HSBlockType.OriginalObject ? e.parentObject.originalObject : e.parentObject
                        }, t.parseValue = function(e, t) {
                            var r = parseFloat(e);
                            return isNaN(r) || !/^\-?[0-9]+(e\+?[0-9]+)?(\.[0-9]+(e[\+\-]?[0-9]+)?)?$/.test(e) ? null == e ? 0 : e : (function(e) {
                                return e >= -l.MAX_FLOAT && e <= l.MAX_FLOAT
                            }(r) || (r = r < 0 ? -l.MAX_FLOAT : l.MAX_FLOAT), Number.isInteger(r) || t ? r : Math.round(1e6 * r) / 1e6)
                        }, t.parseNumberFrom = function(e) {
                            var r = t.parseValue(e, !0);
                            return "string" == typeof r ? 0 : r
                        }, t.prototype.getPublicName = function() {
                            return this.name.replace(c, "")
                        }, t.globalScope = {}, t.userGlobalScope = {}, t
                    }(u.HSStageParameterBlock),
                    p = t.HSVariable = function(e) {
                        function t(t) {
                            var r = e.call(this, t) || this;
                            return r.type = h.HSBlockType.Variable, r
                        }
                        return i.__extends(t, e), t.prototype.stageParameterBlock = function(e) {
                            return new d(this.name, this.blockType, this.objectID, this.associatedObjectID, this.context, e)
                        }, t.prototype.parseJSON = function(t) {
                            void 0 === t && (t = {}), e.prototype.parseJSON.call(this, t), this.blockType = t.type, this.associatedObjectID = t.object, this.type = h.HSBlockType.Variable, this.objectID = t[n.VARIABLE_KEY];
                            var r = this.context.findWithObjectID(o.HSVariablePrototype.key, this.objectID);
                            this.name = c + r.name, this.blockType === h.HSBlockType.User && (d.userGlobalScope[this.name] = r.initialValue)
                        }, t.key = "HSVariable", t
                    }(a.HSParameterBlock);
                window.HSVariable = p, window.HSStageVariable = d
            },
            482: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSCustomObject = void 0;
                var r = function() {
                    function e(e, t, r, i) {
                        this.fileName = e, this.width = t, this.height = r, this.updatedDate = 0, i && (this.updatedDate = new Date(i).getTime())
                    }
                    return e.prototype.computedValue = function() {
                        return 0
                    }, e.prototype.stageParameterBlock = function(e) {
                        return this
                    }, e
                }();
                t.HSCustomObject = r, window.HSCustomObject = r
            },
            4241: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSCustomRule = void 0;
                var i = r(655),
                    s = r(8084),
                    n = r(4662),
                    o = r(662),
                    a = t.HSCustomRule = function(e) {
                        function t() {
                            var t = null !== e && e.apply(this, arguments) || this;
                            return t.rules = [], t.customRules = [], t.script = null, t
                        }
                        return i.__extends(t, e), t.prototype.parseJSON = function(e) {
                            void 0 === e && (e = {}), this.name = e.name, this.objectID = e.id, this.addRulesFromJSON(e)
                        }, t.prototype.addRulesFromJSON = function(e) {
                            void 0 === e && (e = {});
                            var t = this.context,
                                r = [],
                                i = [];
                            e.rules.forEach((function(e) {
                                var n = t.findWithObjectID(o.HSRule.key, e);
                                n && r.push(n);
                                var a = t.findWithObjectID(s.HSCustomRuleInstance.key, e);
                                a && i.push(a)
                            })), this.rules = r, this.customRules = i
                        }, t.key = "HSCustomRule", t
                    }(n.HSManagedObject);
                window.HSCustomRule = a
            },
            8084: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSCustomRuleInstance = void 0;
                var i = r(655),
                    s = r(3339),
                    n = r(4517),
                    o = r(4222),
                    a = r(4241),
                    h = r(4662),
                    l = r(9002),
                    u = t.HSCustomRuleInstance = function(e) {
                        function t() {
                            var t = null !== e && e.apply(this, arguments) || this;
                            return t.parameters = [], t
                        }
                        return i.__extends(t, e), t.prototype.parseJSON = function(e) {
                            var t = this;
                            void 0 === e && (e = {}), this.objectID = e.id;
                            var r = e.customRuleID;
                            this.customRule = this.context.findWithObjectID(a.HSCustomRule.key, r), (e[o.PARAMETERS_KEY] || []).forEach((function(e) {
                                var r = new l.HSParameter(t.context);
                                r.parentNode = t.parentNode, r.parseJSON(e), t.parameters.push(r)
                            }))
                        }, t.prototype.name = function() {
                            var e;
                            return null === (e = this.customRule) || void 0 === e ? void 0 : e.name
                        }, t.prototype.script = function() {
                            var e;
                            return null === (e = this.customRule) || void 0 === e ? void 0 : e.script
                        }, t.prototype.rules = function() {
                            var e;
                            return (null === (e = this.customRule) || void 0 === e ? void 0 : e.rules) || []
                        }, t.prototype.customRules = function() {
                            var e;
                            return (null === (e = this.customRule) || void 0 === e ? void 0 : e.customRules) || []
                        }, t.prototype.stageCustomRule = function(e) {
                            var t = this.parameters.map((function(t) {
                                    return t.stageParameter(e)
                                })),
                                r = new s.HSStageCustomRule(e, this.name());
                            return r.ruleGroups = this.stageRuleGroups(e, r), r.parameters = t, r
                        }, t.prototype.stageRuleGroups = function(e, t) {
                            var r = [this.baseRuleGroup(e, t)],
                                i = this.objectID,
                                s = this.customRules().map((function(t) {
                                    if (t.objectID != i) {
                                        var r = new n.HSStageRuleGroup(e, e.parentObject, !0);
                                        return r.customRule = t.stageCustomRule(r), r
                                    }
                                })).filter((function(e) {
                                    return !!e
                                }));
                            return r.concat(s)
                        }, t.prototype.baseRuleGroup = function(e, t) {
                            var r, i = new n.HSStageRuleGroup(e, e.parentObject, !0);
                            return i.addRules(this.stageRules(i, t)), i.setScript(null === (r = this.script()) || void 0 === r ? void 0 : r.stageScript(i)), i
                        }, t.prototype.stageRules = function(e, t) {
                            var r = this;
                            return this.rules().reduce((function(i, s) {
                                if (s === r) return i;
                                var n = s.stageRules(e, t);
                                return i.concat(n)
                            }), [])
                        }, t.key = "HSCustomRuleInstance", t
                    }(h.HSManagedObject);
                window.HSCustomRuleInstance = u
            },
            5218: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSEnvironment = t.ScopeMode = void 0;
                var i, s = r(655);
                ! function(e) {
                    e[e.DynamicRoot = 0] = "DynamicRoot", e[e.Root = 1] = "Root", e[e.Own = 2] = "Own", e[e.Parent = 3] = "Parent"
                }(i = t.ScopeMode || (t.ScopeMode = {}));
                var n = function() {
                    function e(e) {
                        void 0 === e && (e = null), this.parentEnv = e, this.map = new Map
                    }
                    return e.environmentForNode = function(t) {
                        var r, s, n;
                        switch (t.scopeMode()) {
                            case i.Parent:
                                return null !== (s = null === (r = t.parentNode()) || void 0 === r ? void 0 : r.environment()) && void 0 !== s ? s : new e(null);
                            case i.Own:
                                return new e(null === (n = t.parentNode()) || void 0 === n ? void 0 : n.environment());
                            case i.Root:
                            case i.DynamicRoot:
                                return new e(null)
                        }
                    }, e.prototype.mapChain = function() {
                        var e;
                        return s.__spreadArray([this.map], s.__read((null === (e = this.parentEnv) || void 0 === e ? void 0 : e.mapChain()) || []), !1)
                    }, e.prototype.get = function(e) {
                        var t;
                        return null === (t = this.mapChain().find((function(t) {
                            return t.has(e)
                        }))) || void 0 === t ? void 0 : t.get(e)
                    }, e.prototype.set = function(e, t) {
                        (this.mapChain().find((function(t) {
                            return t.has(e)
                        })) || this.map).set(e, t)
                    }, e.prototype.replace = function(e) {
                        return this.map = new Map(e.map), this
                    }, e.prototype.clear = function() {
                        this.map.clear()
                    }, e
                }();
                t.HSEnvironment = n
            },
            471: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.preprocess_json_for_2_0 = void 0;
                var i = r(9005),
                    s = r(9751);

                function n(e) {
                    var t, r;
                    if (e[s.CUSTOM_RULES_KEY] && !e[s.CUSTOM_RULE_INSTANCES_KEY]) {
                        var n = null === (t = e[s.CUSTOM_RULES_KEY]) || void 0 === t ? void 0 : t.map((function(e) {
                                return e.id
                            })),
                            o = [];
                        null === (r = e[s.OBJECTS_KEY]) || void 0 === r || r.forEach((function(e) {
                            var t, r = [];
                            null === (t = e.rules) || void 0 === t || t.forEach((function(e) {
                                if (n.includes(e)) {
                                    var t = (s = e, {
                                        id: (0, i.generateUUID)(),
                                        customRuleID: s
                                    });
                                    o.push(t), r.push(t.id)
                                } else r.push(e);
                                var s
                            })), e.rules = r
                        })), e[s.CUSTOM_RULE_INSTANCES_KEY] = o
                    }
                }
                t.preprocess_json_for_2_0 = n, window.preprocess_json_for_2_0 = n
            },
            4662: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSManagedObject = void 0;
                var r = t.HSManagedObject = function() {
                    function e(e) {
                        this.context = e, this.description = this.constructor.name, e.insertObject(this)
                    }
                    return e.key = "HSManagedObject", e
                }();
                window.HSManagedObject = r
            },
            6642: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSObject = t.IMAGE_ID_KEY = t.TYPE_KEY = t.NAME_KEY = t.TEXT_KEY = t.Y_POSITION_KEY = t.X_POSITION_KEY = t.OBJECT_ID_KEY = void 0;
                var i = r(655),
                    s = r(4662),
                    n = r(2127),
                    o = r(682),
                    a = r(8935),
                    h = r(8232),
                    l = r(2983),
                    u = r(445),
                    c = r(4517);
                t.OBJECT_ID_KEY = "objectID", t.X_POSITION_KEY = "xPosition", t.Y_POSITION_KEY = "yPosition", t.TEXT_KEY = "text", t.NAME_KEY = "name", t.TYPE_KEY = "type", t.IMAGE_ID_KEY = "customObjectID";
                var d = t.HSObject = function(e) {
                    function r() {
                        var t = null !== e && e.apply(this, arguments) || this;
                        return t.rules = [], t.script = null, t.heading = 0, t.customObject = null, t.willChangeCostume = !1, t.customRules = [], t.headingInDegrees = 0, t._stageObjects = [], t
                    }
                    return i.__extends(r, e), r.prototype.stageObject = function() {
                        var e, t = new o.HSStageObject(this.x, this.y, this.text, this.name, this.type, this.context.baseObjectScale, this.context.fontSize, this.objectID, this.fileName(), this.willChangeCostume, this.width, this.height, this.headingInDegrees);
                        t.variables = this.stageVariables(t), this.latestCloneIndex = 0;
                        var r = new c.HSStageRuleGroup(t, t, !0),
                            i = this.rules.reduce((function(e, t) {
                                return t ? e.concat(t.stageRules(r)) : e
                            }), []);
                        r.addRules(i), r.setScript(null === (e = this.script) || void 0 === e ? void 0 : e.stageScript(t));
                        var s = this.customRules.map((function(e) {
                            var r = new c.HSStageRuleGroup(t, t);
                            return r.customRule = e.stageCustomRule(r), r.customRule.parameters = e.parameters.map((function(e) {
                                return e.stageParameter(r.parentObject)
                            })), r.populateEnvironment(), r
                        }));
                        return t.ruleGroups = [r].concat(s), this._stageObjects = [t], this.type === h.HSObjectType.text && (t.setText(this.text, "rgb(0,0,0)"), t.setWidth(t.width() * this.resizeScale), t.setHeight(t.height() * this.resizeScale)), t
                    }, r.prototype.stageVariables = function(e) {
                        return this.context.findAllForClassName(l.HSVariable.key).map((function(t) {
                            return t.stageParameterBlock(e)
                        })).filter((function(e) {
                            return e.objectReferenceType == u.HSBlockType.Self
                        }))
                    }, r.prototype.parseJSON = function(e) {
                        void 0 === e && (e = {}), this.x = parseFloat(e[t.X_POSITION_KEY]), this.y = parseFloat(e[t.Y_POSITION_KEY]), this.text = e[t.TEXT_KEY], this.type = e[t.TYPE_KEY], this.name = e[t.NAME_KEY], this.width = parseFloat(e.width), this.height = parseFloat(e.height), this.resizeScale = parseFloat(e.resizeScale), this.headingInDegrees = parseFloat(e.rotation) || 0, this.objectID = e[t.OBJECT_ID_KEY], this.customObject = n.HSProjectContext.customObjectMap.get(e[t.IMAGE_ID_KEY]), this.customObject && a.HSImageTextureFactory.instance.prefetchImage(this.customObject)
                    }, r.prototype.fileName = function() {
                        if (this.customObject) return this.customObject.fileName
                    }, r.prototype.addRule = function(e) {
                        this.rules.push(e)
                    }, r.prototype.allStageObjects = function() {
                        return this._stageObjects
                    }, r.prototype.addStageObject = function(e) {
                        this.latestCloneIndex++, this.allStageObjects().push(e), e.cloneIndex = this.latestCloneIndex
                    }, r.prototype.removeStageObject = function(e) {
                        this._stageObjects.remove(e)
                    }, r.prototype.canChangeCostume = function() {
                        return this.type !== h.HSObjectType.text && !(0, h.hsIsShapeType)(this.type) && this.type <= h.HSObjectType.HS_NUMBER_OF_OBJECTS
                    }, r.key = "HSObject", r
                }(s.HSManagedObject);
                window.HSObject = d
            },
            3193: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSOBJECT_SIZES = void 0;
                var i = r(8232);
                t.HSOBJECT_SIZES = {}, t.HSOBJECT_SIZES[i.HSObjectType.text] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.monkey] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.octopus] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.gorilla] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.cupcake] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.bear] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.dino] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.frog] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.greenman] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.mustache] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.spacepod] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.zombieBear] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.ghoulopus] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.bats] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.frankenrilla] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.jodyWitch] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.cauldron] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.pumpkin] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.broom] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.lantern] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.parrotFlying] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.mandrill] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.mosquito] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.missChief] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.venus] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.jeepers] = {
                    width: 390,
                    height: 390
                }, t.HSOBJECT_SIZES[i.HSObjectType.banyan] = {
                    width: 600,
                    height: 600
                }, t.HSOBJECT_SIZES[i.HSObjectType.stargirl] = {
                    width: 172.5,
                    height: 172.5
                }, t.HSOBJECT_SIZES[i.HSObjectType.astro] = {
                    width: 187.5,
                    height: 187.5
                }, t.HSOBJECT_SIZES[i.HSObjectType.chillanna] = {
                    width: 172.5,
                    height: 172.5
                }, t.HSOBJECT_SIZES[i.HSObjectType.robo] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.raccoon] = {
                    width: 172.5,
                    height: 172.5
                }, t.HSOBJECT_SIZES[i.HSObjectType.bird] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.square] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.circle] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.hexagon] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.triangle] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.rightTriangle] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.rectangle] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.heart] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.star] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.arch] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.parallelogram] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.squiggle] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.donut] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.tetrisZ] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.tetrisT] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.tetrisL] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.corner] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.flower] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.threeProngedBoomerang] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.squishedBox] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.bead] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.chevron] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.xShape] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.tetrisLine] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.toucan] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.anteater] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.crocodile] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.sloth] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.iguana] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.hut] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.penguin] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.winterQueen] = {
                    width: 225,
                    height: 225
                }, t.HSOBJECT_SIZES[i.HSObjectType.shyYeti] = {
                    width: 300,
                    height: 300
                }, t.HSOBJECT_SIZES[i.HSObjectType.deer] = {
                    width: 255,
                    height: 255
                }, t.HSOBJECT_SIZES[i.HSObjectType.elf] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.snowGlobe] = {
                    width: 450,
                    height: 450
                }, t.HSOBJECT_SIZES[i.HSObjectType.polarbear] = {
                    width: 300,
                    height: 300
                }, t.HSOBJECT_SIZES[i.HSObjectType.sleigh] = {
                    width: 300,
                    height: 300
                }, t.HSOBJECT_SIZES[i.HSObjectType.mistletoe] = {
                    width: 129,
                    height: 129
                }, t.HSOBJECT_SIZES[i.HSObjectType.snowMan] = {
                    width: 225,
                    height: 225
                }, t.HSOBJECT_SIZES[i.HSObjectType.snowflake] = {
                    width: 45,
                    height: 45
                }, t.HSOBJECT_SIZES[i.HSObjectType.tetrisTFullSize] = {
                    width: 150,
                    height: 100
                }, t.HSOBJECT_SIZES[i.HSObjectType.rectangleFullSize] = {
                    width: 150,
                    height: 112.5
                }, t.HSOBJECT_SIZES[i.HSObjectType.archFullSize] = {
                    width: 150,
                    height: 75
                }, t.HSOBJECT_SIZES[i.HSObjectType.rightTriangleFullSize] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.tetrisLFullSize] = {
                    width: 150,
                    height: 100
                }, t.HSOBJECT_SIZES[i.HSObjectType.roundedSquareFullSize] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.roundedRightTriangleFullSize] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.squishedBoxFullSize] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.starFullSize] = {
                    width: 150,
                    height: 142.66
                }, t.HSOBJECT_SIZES[i.HSObjectType.parallelogramTallFullSize] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.arrowRoundedFullSize] = {
                    width: 106.07,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.hexagonFullSize] = {
                    width: 150,
                    height: 129.9
                }, t.HSOBJECT_SIZES[i.HSObjectType.squiggleFullSize] = {
                    width: 150,
                    height: 69.64
                }, t.HSOBJECT_SIZES[i.HSObjectType.squareFullSize] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.chevronFullSize] = {
                    width: 150,
                    height: 129.9
                }, t.HSOBJECT_SIZES[i.HSObjectType.flowerFullSize] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.heartFullSize] = {
                    width: 150,
                    height: 126.77
                }, t.HSOBJECT_SIZES[i.HSObjectType.parallelogramWideFullSize] = {
                    width: 150,
                    height: 75
                }, t.HSOBJECT_SIZES[i.HSObjectType.beadFullSize] = {
                    width: 150,
                    height: 76.95
                }, t.HSOBJECT_SIZES[i.HSObjectType.triangleFullSize] = {
                    width: 150,
                    height: 129.9
                }, t.HSOBJECT_SIZES[i.HSObjectType.xFullSize] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.donutFullSize] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.tetrisZFullSize] = {
                    width: 150,
                    height: 100
                }, t.HSOBJECT_SIZES[i.HSObjectType.tetrisLineFullSize] = {
                    width: 200,
                    height: 50
                }, t.HSOBJECT_SIZES[i.HSObjectType.fanbladeFullSize] = {
                    width: 150,
                    height: 137.26
                }, t.HSOBJECT_SIZES[i.HSObjectType.cornerFullSize] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.circleFullSize] = {
                    width: 150,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.tetrisTV3] = {
                    width: 150,
                    height: 100
                }, t.HSOBJECT_SIZES[i.HSObjectType.rectangleV3] = {
                    width: 150,
                    height: 100
                }, t.HSOBJECT_SIZES[i.HSObjectType.archV3] = {
                    width: 150,
                    height: 75
                }, t.HSOBJECT_SIZES[i.HSObjectType.tetrisLV3] = {
                    width: 150,
                    height: 100
                }, t.HSOBJECT_SIZES[i.HSObjectType.starV3] = {
                    width: 150,
                    height: 143
                }, t.HSOBJECT_SIZES[i.HSObjectType.arrowRoundedV3] = {
                    width: 106,
                    height: 150
                }, t.HSOBJECT_SIZES[i.HSObjectType.hexagonV3] = {
                    width: 150,
                    height: 130
                }, t.HSOBJECT_SIZES[i.HSObjectType.squiggleV3] = {
                    width: 150,
                    height: 70
                }, t.HSOBJECT_SIZES[i.HSObjectType.chevronV3] = {
                    width: 150,
                    height: 130
                }, t.HSOBJECT_SIZES[i.HSObjectType.heartV3] = {
                    width: 150,
                    height: 127
                }, t.HSOBJECT_SIZES[i.HSObjectType.parallelogramWideV3] = {
                    width: 150,
                    height: 75
                }, t.HSOBJECT_SIZES[i.HSObjectType.beadV3] = {
                    width: 150,
                    height: 77
                }, t.HSOBJECT_SIZES[i.HSObjectType.triangleV3] = {
                    width: 150,
                    height: 130
                }, t.HSOBJECT_SIZES[i.HSObjectType.tetrisZV3] = {
                    width: 150,
                    height: 100
                }, t.HSOBJECT_SIZES[i.HSObjectType.fanbladeV3] = {
                    width: 150,
                    height: 137
                }, t.HSOBJECT_SIZES[i.HSObjectType.crocodileJaws] = {
                    width: 288,
                    height: 164
                }, t.HSOBJECT_SIZES[i.HSObjectType.lanternFullSize] = {
                    width: 48,
                    height: 84
                }, window.HSOBJECT_SIZES = t.HSOBJECT_SIZES
            },
            8232: (e, t) => {
                "use strict";
                var r;

                function i(e) {
                    return e >= r.roundedSquareFullSize && e < r.HS_END_OF_FULL_SIZE_SHAPES
                }
                Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.hsIsFullSizeShape = t.hsIsShapeType = t.HSObjectType = void 0,
                    function(e) {
                        e[e.monkey = 0] = "monkey", e[e.text = 1] = "text", e[e.octopus = 2] = "octopus", e[e.gorilla = 3] = "gorilla", e[e.cupcake = 4] = "cupcake", e[e.bear = 5] = "bear", e[e.dino = 6] = "dino", e[e.frog = 7] = "frog", e[e.greenman = 8] = "greenman", e[e.mustache = 9] = "mustache", e[e.spacepod = 10] = "spacepod", e[e.zombieBear = 11] = "zombieBear", e[e.ghoulopus = 12] = "ghoulopus", e[e.bats = 13] = "bats", e[e.frankenrilla = 14] = "frankenrilla", e[e.jodyWitch = 15] = "jodyWitch", e[e.cauldron = 16] = "cauldron", e[e.pumpkin = 17] = "pumpkin", e[e.broom = 18] = "broom", e[e.lantern = 19] = "lantern", e[e.parrotFlying = 20] = "parrotFlying", e[e.mandrill = 21] = "mandrill", e[e.mosquito = 22] = "mosquito", e[e.missChief = 23] = "missChief", e[e.venus = 24] = "venus", e[e.jeepers = 25] = "jeepers", e[e.banyan = 26] = "banyan", e[e.stargirl = 27] = "stargirl", e[e.astro = 28] = "astro", e[e.chillanna = 29] = "chillanna", e[e.robo = 30] = "robo", e[e.raccoon = 31] = "raccoon", e[e.bird = 32] = "bird", e[e.HS_END_OF_CHARACTERS = 33] = "HS_END_OF_CHARACTERS", e[e.square = 34] = "square", e[e.circle = 35] = "circle", e[e.hexagon = 36] = "hexagon", e[e.triangle = 37] = "triangle", e[e.rightTriangle = 38] = "rightTriangle", e[e.rectangle = 39] = "rectangle", e[e.heart = 40] = "heart", e[e.star = 41] = "star", e[e.arch = 42] = "arch", e[e.parallelogram = 43] = "parallelogram", e[e.squiggle = 44] = "squiggle", e[e.donut = 45] = "donut", e[e.tetrisZ = 46] = "tetrisZ", e[e.tetrisT = 47] = "tetrisT", e[e.tetrisL = 48] = "tetrisL", e[e.corner = 49] = "corner", e[e.flower = 50] = "flower", e[e.threeProngedBoomerang = 51] = "threeProngedBoomerang", e[e.squishedBox = 52] = "squishedBox", e[e.bead = 53] = "bead", e[e.chevron = 54] = "chevron", e[e.xShape = 55] = "xShape", e[e.tetrisLine = 56] = "tetrisLine", e[e.HS_END_OF_SHAPES = 57] = "HS_END_OF_SHAPES", e[e.toucan = 58] = "toucan", e[e.anteater = 59] = "anteater", e[e.crocodile = 60] = "crocodile", e[e.sloth = 61] = "sloth", e[e.iguana = 62] = "iguana", e[e.hut = 63] = "hut", e[e.penguin = 64] = "penguin", e[e.winterQueen = 65] = "winterQueen", e[e.shyYeti = 66] = "shyYeti", e[e.deer = 67] = "deer", e[e.elf = 68] = "elf", e[e.snowGlobe = 69] = "snowGlobe", e[e.polarbear = 70] = "polarbear", e[e.sleigh = 71] = "sleigh", e[e.mistletoe = 72] = "mistletoe", e[e.snowMan = 73] = "snowMan", e[e.snowflake = 74] = "snowflake", e[e.roundedSquareFullSize = 100] = "roundedSquareFullSize", e[e.squareFullSize = 101] = "squareFullSize", e[e.circleFullSize = 102] = "circleFullSize", e[e.hexagonFullSize = 103] = "hexagonFullSize", e[e.triangleFullSize = 104] = "triangleFullSize", e[e.rightTriangleFullSize = 105] = "rightTriangleFullSize", e[e.rectangleFullSize = 106] = "rectangleFullSize", e[e.heartFullSize = 107] = "heartFullSize", e[e.starFullSize = 108] = "starFullSize", e[e.archFullSize = 109] = "archFullSize", e[e.parallelogramTallFullSize = 110] = "parallelogramTallFullSize", e[e.squiggleFullSize = 111] = "squiggleFullSize", e[e.donutFullSize = 112] = "donutFullSize", e[e.tetrisZFullSize = 113] = "tetrisZFullSize", e[e.tetrisTFullSize = 114] = "tetrisTFullSize", e[e.tetrisLFullSize = 115] = "tetrisLFullSize", e[e.cornerFullSize = 116] = "cornerFullSize", e[e.flowerFullSize = 117] = "flowerFullSize", e[e.fanbladeFullSize = 118] = "fanbladeFullSize", e[e.squishedBoxFullSize = 119] = "squishedBoxFullSize", e[e.roundedRightTriangleFullSize = 120] = "roundedRightTriangleFullSize", e[e.arrowRoundedFullSize = 121] = "arrowRoundedFullSize", e[e.beadFullSize = 122] = "beadFullSize", e[e.parallelogramWideFullSize = 123] = "parallelogramWideFullSize", e[e.chevronFullSize = 124] = "chevronFullSize", e[e.xFullSize = 125] = "xFullSize", e[e.tetrisLineFullSize = 126] = "tetrisLineFullSize", e[e.hexagonV3 = 150] = "hexagonV3", e[e.triangleV3 = 151] = "triangleV3", e[e.rectangleV3 = 152] = "rectangleV3", e[e.heartV3 = 153] = "heartV3", e[e.starV3 = 154] = "starV3", e[e.archV3 = 155] = "archV3", e[e.squiggleV3 = 156] = "squiggleV3", e[e.tetrisZV3 = 157] = "tetrisZV3", e[e.tetrisTV3 = 158] = "tetrisTV3", e[e.tetrisLV3 = 159] = "tetrisLV3", e[e.fanbladeV3 = 160] = "fanbladeV3", e[e.arrowRoundedV3 = 161] = "arrowRoundedV3", e[e.beadV3 = 162] = "beadV3", e[e.parallelogramWideV3 = 163] = "parallelogramWideV3", e[e.chevronV3 = 164] = "chevronV3", e[e.HS_END_OF_FULL_SIZE_SHAPES = 165] = "HS_END_OF_FULL_SIZE_SHAPES", e[e.HS_NUMBER_OF_OBJECTS = 166] = "HS_NUMBER_OF_OBJECTS", e[e.image = 2e3] = "image", e[e.HS_START_OF_CHARACTERS2 = 3e3] = "HS_START_OF_CHARACTERS2", e[e.crocodileJaws = 3001] = "crocodileJaws", e[e.lanternFullSize = 3002] = "lanternFullSize", e[e.HS_END_OF_CHARACTERS2 = 3003] = "HS_END_OF_CHARACTERS2", e[e.nil = 1e4] = "nil", e[e.edgeOfScreen = 3e4] = "edgeOfScreen"
                    }(r = t.HSObjectType || (t.HSObjectType = {})), t.hsIsShapeType = function(e) {
                        var t = i(e);
                        return e > r.HS_END_OF_CHARACTERS && e < r.HS_END_OF_SHAPES || t
                    }, t.hsIsFullSizeShape = i, window.HSObjectType = r
            },
            9002: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSParameter = t.ID_KEY = t.PARAMETER_TYPE_KEY = t.VARIABLE_KEY = t.CHILD_BLOCK_KEY = t.VALUE_KEY = void 0;
                var i = r(655),
                    s = r(4662),
                    n = r(2127),
                    o = r(3724),
                    a = r(2983),
                    h = r(4925),
                    l = r(861),
                    u = r(1559),
                    c = r(7351),
                    d = r(8935),
                    p = r(3441),
                    f = r(445),
                    m = r(1477),
                    g = r(5136);
                t.VALUE_KEY = "value", t.CHILD_BLOCK_KEY = "datum", t.VARIABLE_KEY = "variable", t.PARAMETER_TYPE_KEY = "type", t.ID_KEY = "id";
                var y = t.HSParameter = function(e) {
                    function r() {
                        return null !== e && e.apply(this, arguments) || this
                    }
                    return i.__extends(r, e), r.prototype.stageParameter = function(e) {
                        return new h.HSStageParameter(this.value, e, this.stageParameterBlock(e), this.key)
                    }, r.prototype.stageParameterBlock = function(e) {
                        return this.childBlock ? this.childBlock.stageParameterBlock(e) : null
                    }, r.prototype.parseJSON = function(e) {
                        if (void 0 === e && (e = {}), this.key = e.key, this.value = e[t.VALUE_KEY], this.type = e[t.PARAMETER_TYPE_KEY], this.type === p.HSParameterType.Object && e[t.CHILD_BLOCK_KEY]) {
                            var r = e[t.CHILD_BLOCK_KEY];
                            if (r.customObject) {
                                var i = n.HSProjectContext.customObjectMap.get(r.customObject);
                                this.childBlock = i, d.HSImageTextureFactory.instance.prefetchImage(i)
                            }
                            this.value = r.text ? r.text : r.type
                        } else if (e[t.CHILD_BLOCK_KEY] && e[t.CHILD_BLOCK_KEY].type == f.HSBlockType.Scoped) {
                            var s = new m.HSLocalVariable(this.context);
                            s.parentNode = this, s.parseJSON(e[t.CHILD_BLOCK_KEY]), this.childBlock = s
                        } else if (e[t.CHILD_BLOCK_KEY] && e[t.CHILD_BLOCK_KEY].variable) this.setChildBlockToVariableIfPossible(e[t.CHILD_BLOCK_KEY]);
                        else if (e[t.CHILD_BLOCK_KEY] && e[t.CHILD_BLOCK_KEY].blockType > f.HSBlockType.HS_END_OF_TEXT_OPERATOR_BLOCKS && e[t.CHILD_BLOCK_KEY].blockType < f.HSBlockType.HS_END_OF_SCENE_REFERENCE_BLOCKS) this.setChildBlockToSceneReferenceBlockIfPossible(e[t.CHILD_BLOCK_KEY]);
                        else if (e[t.CHILD_BLOCK_KEY]) {
                            var o = new c.HSParameterBlock(this.context);
                            o.parentNode = this, o.parseJSON(e[t.CHILD_BLOCK_KEY]), this.childBlock = o
                        } else e[t.VARIABLE_KEY] && (this.setChildBlockToVariableIfPossible(e), this.setChildBlockToTraitIfPossible(e), this.setChildBlockToEventParameterIfPossible(e))
                    }, r.prototype.toString = function() {
                        return o.SourceFormatter.paramToSrc(this)
                    }, r.prototype.setChildBlockToVariableIfPossible = function(e) {
                        var r = e[t.VARIABLE_KEY];
                        if (this.context.findWithObjectID(l.HSVariablePrototype.key, r)) {
                            var i = new a.HSVariable(this.context);
                            i.parseJSON(e), this.childBlock = i
                        }
                    }, r.prototype.setChildBlockToTraitIfPossible = function(e) {
                        var r = e[t.VARIABLE_KEY],
                            i = this.context.findWithObjectID(c.HSParameterBlock.key, r);
                        i && (this.childBlock = i)
                    }, r.prototype.setChildBlockToEventParameterIfPossible = function(e) {
                        var r = e[t.VARIABLE_KEY],
                            i = this.context.findWithObjectID(u.HSEventParameterBlock.key, r);
                        i && (this.childBlock = i)
                    }, r.prototype.setChildBlockToSceneReferenceBlockIfPossible = function(e) {
                        var r = e[t.ID_KEY],
                            i = this.context.findWithObjectID(g.HSSceneReferenceBlock.key, r);
                        i && (this.childBlock = i)
                    }, r.key = "HSParameter", r
                }(s.HSManagedObject);
                window.HSParameter = y, window.VALUE_KEY = t.VALUE_KEY, window.CHILD_BLOCK_KEY = t.CHILD_BLOCK_KEY, window.VARIABLE_KEY = t.VARIABLE_KEY, window.PARAMETER_TYPE_KEY = t.PARAMETER_TYPE_KEY
            },
            3441: (e, t) => {
                "use strict";
                var r;
                Object.defineProperty(t, "__esModule", {
                        value: !0
                    }), t.HSParameterType = void 0,
                    function(e) {
                        e[e.Default = 42] = "Default", e[e.LineWidth = 43] = "LineWidth", e[e.LineColor = 44] = "LineColor", e[e.RandomLow = 45] = "RandomLow", e[e.RandomHigh = 46] = "RandomHigh", e[e.Variable = 47] = "Variable", e[e.VariableValue = 48] = "VariableValue", e[e.Conditional = 49] = "Conditional", e[e.HSObject = 50] = "HSObject", e[e.Sound = 51] = "Sound", e[e.Event = 52] = "Event", e[e.SetText = 53] = "SetText", e[e.Object = 54] = "Object", e[e.TextOnly = 55] = "TextOnly", e[e.Scene = 56] = "Scene", e[e.MultiPurposeNumberDefault = 57] = "MultiPurposeNumberDefault", e[e.Product = 58] = "Product", e[e.Rhythm = 59] = "Rhythm", e[e.MusicNote = 60] = "MusicNote", e[e.Instrument = 61] = "Instrument"
                    }(r = t.HSParameterType || (t.HSParameterType = {})), window.HSParameterType = r
            },
            9751: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSProject = t.SCENES_REFERENCES_KEY = t.SCENES_KEY = t.SCRIPTS_KEY = t.EVENT_PARAMETERS_KEY = t.TRAITS_KEY = t.VARIABLES_KEY = t.CUSTOM_RULE_INSTANCES_KEY = t.CUSTOM_RULES_KEY = t.RULES_KEY = t.OBJECTS_KEY = void 0;
                var i = r(655),
                    s = r(4662),
                    n = r(6642),
                    o = r(1518),
                    a = r(662),
                    h = r(9470),
                    l = r(861),
                    u = r(1559),
                    c = r(7351),
                    d = r(4241),
                    p = r(7779),
                    f = r(2983),
                    m = r(8084),
                    g = r(471),
                    y = r(5136);
                t.OBJECTS_KEY = "objects", t.RULES_KEY = "rules", t.CUSTOM_RULES_KEY = "customRules", t.CUSTOM_RULE_INSTANCES_KEY = "customRuleInstances", t.VARIABLES_KEY = "variables", t.TRAITS_KEY = "traits", t.EVENT_PARAMETERS_KEY = "eventParameters", t.SCRIPTS_KEY = "abilities", t.SCENES_KEY = "scenes", t.SCENES_REFERENCES_KEY = "sceneReferences";
                var _ = function(e) {
                    function r(r, i) {
                        void 0 === i && (i = {});
                        var s = e.call(this, r) || this;
                        return (0, g.preprocess_json_for_2_0)(i), s.context.parseJSON(i), s.parseObjectDictionaries(i[t.OBJECTS_KEY], i[t.SCENES_KEY]), s.parseVariableDictionaries(i[t.VARIABLES_KEY]), s.parseTraitsDictionaries(i[t.TRAITS_KEY]), s.parseEventParameters(i[t.EVENT_PARAMETERS_KEY]), s.parseSceneReferenceDictionaries(i[t.SCENES_REFERENCES_KEY]), s.parseScriptDictionaries(i[t.SCRIPTS_KEY]), s.parseRulesDictionaries(i[t.RULES_KEY]), s.importCustomRules(i[t.CUSTOM_RULES_KEY]), s.importCustomRuleInstances(i[t.CUSTOM_RULE_INSTANCES_KEY]), s.importRulesToCustomRules(i[t.CUSTOM_RULES_KEY]), s.addRulesToObjects(i[t.OBJECTS_KEY]), s.addScriptToObjects(i[t.OBJECTS_KEY]), s.addScriptToCustomRules(i[t.CUSTOM_RULES_KEY]), s.parseScenesDictionaries(i[t.SCENES_KEY]), s.addParentRelations(), s
                    }
                    return i.__extends(r, e), r.prototype.buildStageProject = function() {
                        f.HSStageVariable.globalScope = {};
                        var e = this.scenes.map((function(e) {
                            return e.stageScene()
                        }));
                        return new p.HSStageProject(e, this.context.activeSceneIndex, this.context.version)
                    }, r.prototype.addParentRelations = function() {
                        var e, t, r, s, n, o, h, l, u, c, p, f, m = [],
                            g = function(e) {
                                m.push.apply(m, i.__spreadArray([], i.__read(e.objects), !1)), e.objects.forEach((function(t) {
                                    return t.parentNode = e
                                }))
                            };
                        try {
                            for (var y = i.__values(this.scenes), _ = y.next(); !_.done; _ = y.next()) g(_.value)
                        } catch (t) {
                            e = {
                                error: t
                            }
                        } finally {
                            try {
                                _ && !_.done && (t = y.return) && t.call(y)
                            } finally {
                                if (e) throw e.error
                            }
                        }
                        var v = [],
                            S = function(e) {
                                var t = e.rules.filter((function(e) {
                                    return e instanceof a.HSRule
                                }));
                                v.push.apply(v, i.__spreadArray([], i.__read(t), !1)), t.forEach((function(t) {
                                    return t.parentNode = e
                                }))
                            };
                        try {
                            for (var T = i.__values(m), b = T.next(); !b.done; b = T.next()) S(I = b.value)
                        } catch (e) {
                            r = {
                                error: e
                            }
                        } finally {
                            try {
                                b && !b.done && (s = T.return) && s.call(T)
                            } finally {
                                if (r) throw r.error
                            }
                        }
                        var E = this.context.findAllForClassName(d.HSCustomRule.key),
                            x = function(e) {
                                v.push.apply(v, i.__spreadArray([], i.__read(e.rules), !1)), e.rules.forEach((function(t) {
                                    return t.parentNode = e
                                }))
                            };
                        try {
                            for (var w = i.__values(E), O = w.next(); !O.done; O = w.next()) x(H = O.value)
                        } catch (e) {
                            n = {
                                error: e
                            }
                        } finally {
                            try {
                                O && !O.done && (o = w.return) && o.call(w)
                            } finally {
                                if (n) throw n.error
                            }
                        }
                        try {
                            for (var A = i.__values(v), P = A.next(); !P.done; P = A.next()) {
                                var M = P.value;
                                M.script && (M.script.parentNode = M)
                            }
                        } catch (e) {
                            h = {
                                error: e
                            }
                        } finally {
                            try {
                                P && !P.done && (l = A.return) && l.call(A)
                            } finally {
                                if (h) throw h.error
                            }
                        }
                        try {
                            for (var C = i.__values(m), R = C.next(); !R.done; R = C.next()) {
                                var I;
                                (I = R.value).script && (I.script.parentNode = I)
                            }
                        } catch (e) {
                            u = {
                                error: e
                            }
                        } finally {
                            try {
                                R && !R.done && (c = C.return) && c.call(C)
                            } finally {
                                if (u) throw u.error
                            }
                        }
                        try {
                            for (var B = i.__values(E), D = B.next(); !D.done; D = B.next()) {
                                var H;
                                (H = D.value).script && (H.script.parentNode = H)
                            }
                        } catch (e) {
                            p = {
                                error: e
                            }
                        } finally {
                            try {
                                D && !D.done && (f = B.return) && f.call(B)
                            } finally {
                                if (p) throw p.error
                            }
                        }
                    }, r.prototype.parseEventParameters = function(e) {
                        var t = this;
                        void 0 === e && (e = []), e && e.forEach((function(e, r, i) {
                            new u.HSEventParameterBlock(t.context).parseJSON(e)
                        }))
                    }, r.prototype.parseVariableDictionaries = function(e) {
                        if (void 0 === e && (e = []), e) {
                            var t = this.context;
                            e.forEach((function(e, r, i) {
                                new l.HSVariablePrototype(t).parseJSON(e)
                            }))
                        }
                    }, r.prototype.parseTraitsDictionaries = function(e) {
                        if (void 0 === e && (e = []), e) {
                            var t = this.context;
                            e.forEach((function(e, r, i) {
                                new c.HSParameterBlock(t).parseJSON(e)
                            }))
                        }
                    }, r.prototype.parseObjectDictionaries = function(e, r) {
                        void 0 === e && (e = []), void 0 === r && (r = []);
                        var i = [];
                        r.length && (i = r.map((function(e) {
                            return null === e[t.OBJECTS_KEY] ? [] : e[t.OBJECTS_KEY]
                        })).reduce((function(e, t) {
                            return e.concat(t)
                        })));
                        var s = this.context;
                        e.forEach((function(e, t, o) {
                            r.length > 0 && !i.includes(e.objectID) || new n.HSObject(s).parseJSON(e)
                        }))
                    }, r.prototype.parseSceneReferenceDictionaries = function(e) {
                        if (void 0 === e && (e = []), e) {
                            var t = this.context;
                            e.forEach((function(e, r, i) {
                                new y.HSSceneReferenceBlock(t).parseJSON(e)
                            }))
                        }
                    }, r.prototype.addRulesToObjects = function(e) {
                        var t, r;
                        void 0 === e && (e = []);
                        var s = this.context,
                            o = function(e) {
                                var t = s.findWithObjectID(n.HSObject.key, e.objectID);
                                if (!e.rules || !t || !t.rules) return "continue";
                                var r = t.canChangeCostume(),
                                    i = !1,
                                    o = e.rules.map((function(e) {
                                        var t = s.findWithObjectID(a.HSRule.key, e);
                                        return !i && r && t && t.script.containsChangeCostume() && (i = !0), t
                                    })),
                                    h = e.rules.map((function(e) {
                                        return s.findWithObjectID(m.HSCustomRuleInstance.key, e)
                                    }));
                                t.rules = o.filter((function(e) {
                                    return !!e
                                })), t.customRules = h.filter((function(e) {
                                    return !!e
                                })), t.willChangeCostume = i
                            };
                        try {
                            for (var h = i.__values(e), l = h.next(); !l.done; l = h.next()) o(l.value)
                        } catch (e) {
                            t = {
                                error: e
                            }
                        } finally {
                            try {
                                l && !l.done && (r = h.return) && r.call(h)
                            } finally {
                                if (t) throw t.error
                            }
                        }
                    }, r.prototype.addScriptToObjects = function(e) {
                        var t, r;
                        void 0 === e && (e = []);
                        var s = this.context;
                        try {
                            for (var o = i.__values(e), a = o.next(); !a.done; a = o.next()) {
                                var l = a.value,
                                    u = s.findWithObjectID(n.HSObject.key, l.objectID);
                                if (u && l.abilityID) {
                                    var c = l.abilityID,
                                        d = s.findWithObjectID(h.HSScript.key, c);
                                    d && (u.script = d)
                                }
                            }
                        } catch (e) {
                            t = {
                                error: e
                            }
                        } finally {
                            try {
                                a && !a.done && (r = o.return) && r.call(o)
                            } finally {
                                if (t) throw t.error
                            }
                        }
                    }, r.prototype.addScriptToCustomRules = function(e) {
                        var t, r;
                        void 0 === e && (e = []);
                        var s = this.context;
                        try {
                            for (var n = i.__values(e), o = n.next(); !o.done; o = n.next()) {
                                var a = o.value,
                                    l = s.findWithObjectID(d.HSCustomRule.key, a.id);
                                if (l && a.abilityID) {
                                    var u = a.abilityID,
                                        c = s.findWithObjectID(h.HSScript.key, u);
                                    c && (l.script = c)
                                }
                            }
                        } catch (e) {
                            t = {
                                error: e
                            }
                        } finally {
                            try {
                                o && !o.done && (r = n.return) && r.call(n)
                            } finally {
                                if (t) throw t.error
                            }
                        }
                    }, r.prototype.importCustomRules = function(e) {
                        if (void 0 === e && (e = []), e instanceof Array) {
                            var t = this.context;
                            e.forEach((function(e, r, i) {
                                new d.HSCustomRule(t).parseJSON(e)
                            }))
                        }
                    }, r.prototype.importCustomRuleInstances = function(e) {
                        void 0 === e && (e = []);
                        var t = this.context;
                        e instanceof Array && e.forEach((function(e, r, i) {
                            new m.HSCustomRuleInstance(t).parseJSON(e)
                        }))
                    }, r.prototype.importRulesToCustomRules = function(e) {
                        if (void 0 === e && (e = []), e instanceof Array) {
                            var t = this.context;
                            e.forEach((function(e, r, i) {
                                t.findWithObjectID(d.HSCustomRule.key, e.id).addRulesFromJSON(e)
                            }))
                        }
                    }, r.prototype.parseScriptDictionaries = function(e) {
                        void 0 === e && (e = []);
                        for (var t = [], r = 0; r < e.length; r++) {
                            var i = new h.HSScript(this.context);
                            t.push(i), i.addObjectIDFromJSON(e[r])
                        }
                        for (r = 0; r < t.length; r++)(i = t[r]).parseJSON(e[r])
                    }, r.prototype.parseRulesDictionaries = function(e) {
                        void 0 === e && (e = []);
                        var t = this.context;
                        e.forEach((function(e, r, i) {
                            new a.HSRule(t).parseJSON(e)
                        }))
                    }, r.prototype.parseScenesDictionaries = function(e) {
                        if (void 0 === e && (e = []), e.length > 0) {
                            var t = this.context;
                            this.scenes = e.map((function(e) {
                                var r = new o.HSScene(t);
                                return r.parseJSON(e), r
                            }))
                        } else {
                            var r = new o.HSScene(this.context);
                            r.parseJSON(), this.scenes = [r]
                        }
                    }, r
                }(s.HSManagedObject);
                t.HSProject = _, window.HSProject = _, window.OBJECTS_KEY = t.OBJECTS_KEY, window.RULES_KEY = t.RULES_KEY, window.VARIABLES_KEY = t.VARIABLES_KEY, window.TRAITS_KEY = t.TRAITS_KEY, window.EVENT_PARAMETERS_KEY = t.EVENT_PARAMETERS_KEY, window.SCRIPTS_KEY = t.SCRIPTS_KEY, window.SCENES_KEY = t.SCENES_KEY
            },
            2127: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSProjectContext = t.HSProjectVersion = t.ACTIVE_SCENE_KEY = t.STAGE_SIZE = t.FONT_SIZE_KEY = t.SCALE_KEY = t.CUSTOM_OBJECTS_KEY = t.VERSION_KEY = void 0;
                var i = r(655),
                    s = r(6745),
                    n = r(1925),
                    o = r(662),
                    a = r(9002),
                    h = r(7351),
                    l = r(482),
                    u = r(3441),
                    c = r(445),
                    d = r(9005),
                    p = r(682),
                    f = i.__importDefault(r(7818));
                t.VERSION_KEY = "version", t.CUSTOM_OBJECTS_KEY = "customObjects", t.SCALE_KEY = "baseObjectScale", t.FONT_SIZE_KEY = "fontSize", t.STAGE_SIZE = "stageSize", t.ACTIVE_SCENE_KEY = "activeSceneIndex";
                var m, g = ["ocarina", "piano", "vibraphone", "guitar", "cello", "8bit", "choir"];
                ! function(e) {
                    e[e.V13 = 13] = "V13", e[e.V14 = 14] = "V14", e[e.V15 = 15] = "V15", e[e.V16 = 16] = "V16", e[e.V17 = 17] = "V17", e[e.V18 = 18] = "V18", e[e.V19 = 19] = "V19", e[e.V24 = 24] = "V24", e[e.WEBPLAYER_IN_APP = 25] = "WEBPLAYER_IN_APP", e[e.ADD_SELF = 26] = "ADD_SELF", e[e.CUSTOM_WHENS = 28] = "CUSTOM_WHENS"
                }(m = t.HSProjectVersion || (t.HSProjectVersion = {}));
                var y = t.HSProjectContext = function() {
                    function e() {
                        this.projectObjects = {}, this.version = m.CUSTOM_WHENS, this.baseObjectScale = 1, this.fontSize = 80, this.activeSceneIndex = 0, this.alreadyDownloadedInstruments = [], this._hasAccelerometerEvent = null, this._hasAccelerometerTrait = null, this._hasNoiseEvent = null
                    }
                    return e.prototype.findAllForClassName = function(e) {
                        return this.projectObjects[e] ? this.projectObjects[e] : []
                    }, e.prototype.findWithObjectID = function(e, t) {
                        return this.findAllForClassName(e).find((function(e) {
                            return e.objectID === t
                        }))
                    }, e.prototype.insertObject = function(e) {
                        var t = Object.getPrototypeOf(e).constructor.key;
                        this.projectObjects[t] ? this.projectObjects[t].push(e) : this.projectObjects[t] = [e]
                    }, e.prototype.deleteObject = function(e) {
                        var t = Object.getPrototypeOf(e).constructor.key,
                            r = this.projectObjects[t].indexOf(e);
                        r > -1 && this.projectObjects[t].splice(r, 1)
                    }, e.prototype.parseJSON = function(r) {
                        if (void 0 === r && (r = {}), this.version = r[t.VERSION_KEY] || m.V14, this.baseObjectScale = r[t.SCALE_KEY] || 1, this.fontSize = r[t.FONT_SIZE_KEY] || 80, this.activeSceneIndex = r[t.ACTIVE_SCENE_KEY] || 0, s.HSEmojiTextNode.WIDTH = this.fontSize / 2, s.HSEmojiTextNode.HEIGHT = this.fontSize / 2, s.HSTextNode.LINE_HEIGHT = this.fontSize < 80 ? 49 : 55, this.version >= m.V19) {
                            var i = r[t.STAGE_SIZE];
                            i && (n.HSStageScene.stageWidth = i.width, n.HSStageScene.stageHeight = i.height, s.HSTextNode.MAX_LINE_WIDTH = Math.min(600, i.width))
                        }
                        Array.isArray(r[t.CUSTOM_OBJECTS_KEY]) && r[t.CUSTOM_OBJECTS_KEY].forEach((function(t) {
                            var r = new l.HSCustomObject(t.fileName, t.size.width, t.size.height, t.updatedDate);
                            e.customObjectMap.set(t.id, r)
                        }))
                    }, e.prototype.allSoundNames = function() {
                        this.alreadyDownloadedInstruments.length = 0;
                        for (var e = this.findAllForClassName(a.HSParameter.key), t = [], r = 0; r < e.length; r++) {
                            var i = e[r];
                            switch (i.type) {
                                case u.HSParameterType.Sound:
                                    -1 === t.indexOf(i.value) && t.push(i.value);
                                    break;
                                case u.HSParameterType.MusicNote:
                                    t = t.concat(this.allMusicNotesFor());
                                    break;
                                case u.HSParameterType.Instrument:
                                    t = t.concat(this.allMusicNotesFor(i.value))
                            }
                        }
                        return t
                    }, e.prototype.allMusicNotesFor = function(e) {
                        return void 0 === e && (e = p.DEFAULT_INSTRUMENT), e = (0, d.parseInstrumentName)(e), this.alreadyDownloadedInstruments.includes(e) || !g.includes(e) ? [] : (this.alreadyDownloadedInstruments.push(e), i.__spreadArray([], i.__read(Array(37).keys()), !1).map((function(t) {
                            return e + "/" + (t + 48) + ".wav"
                        })))
                    }, e.prototype.hasAccelerometerEvent = function() {
                        if (null != this._hasAccelerometerEvent) return this._hasAccelerometerEvent;
                        for (var e = this.findAllForClassName(o.HSRule.key), t = 0; t < e.length; t++) switch (e[t].eventType()) {
                            case c.HSBlockType.EventOperatorTiltUp:
                            case c.HSBlockType.EventOperatorTiltDown:
                            case c.HSBlockType.EventOperatorTiltLeft:
                            case c.HSBlockType.EventOperatorTiltRight:
                            case c.HSBlockType.EventOperatorShake:
                                return this.preventDefaultKeys(), this._hasAccelerometerEvent = !0
                        }
                        return !1
                    }, e.prototype.preventDefaultKeys = function() {
                        var e = f.default.Key,
                            t = f.default.shared;
                        t.setPreventDefault(e.SPACE), t.setPreventDefault(e.RIGHT), t.setPreventDefault(e.LEFT), t.setPreventDefault(e.UP), t.setPreventDefault(e.DOWN)
                    }, e.prototype.hasAccelerometerTrait = function() {
                        if (null != this._hasAccelerometerTrait) return this._hasAccelerometerTrait;
                        for (var e = this.findAllForClassName(h.HSParameterBlock.key), t = 0; t < e.length; t++) switch (e[t].type) {
                            case c.HSBlockType.StageTraitTiltUp:
                            case c.HSBlockType.StageTraitTiltDown:
                            case c.HSBlockType.StageTraitTiltLeft:
                            case c.HSBlockType.StageTraitTiltRight:
                                return this._hasAccelerometerEvent = !0
                        }
                        return !1
                    }, e.prototype.hasNoiseEvent = function() {
                        if (null != this._hasNoiseEvent) return this._hasNoiseEvent;
                        for (var e = this.findAllForClassName(o.HSRule.key), t = 0; t < e.length; t++)
                            if (e[t].eventType() === c.HSBlockType.EventOperatorLoudNoise) return this._hasNoiseEvent = !0;
                        return !1
                    }, e.customObjectMap = new Map, e
                }();
                window.HSProjectVersion = m, window.HSProjectContext = y, window.VERSION_KEY = t.VERSION_KEY, window.CUSTOM_OBJECTS_KEY = t.CUSTOM_OBJECTS_KEY, window.SCALE_KEY = t.SCALE_KEY, window.FONT_SIZE_KEY = t.FONT_SIZE_KEY, window.STAGE_SIZE = t.STAGE_SIZE, window.ACTIVE_SCENE_KEY = t.ACTIVE_SCENE_KEY
            },
            9449: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSProjectOpener = void 0;
                var i = r(9005),
                    s = function() {
                        function e(e) {
                            this.projectIdentifier = e
                        }
                        return e.prototype.open = function() {
                            if ((0, i.isIOSApp)()) i.HSApp.sendToApp("openProject", this.projectIdentifier);
                            else {
                                var e = function(e) {
                                        var t = document.getElementById("page-info"),
                                            r = window.location.href;
                                        try {
                                            r = JSON.parse(t.dataset.api).endpoint
                                        } finally {
                                            return new URL("/api/v2/links", r).toString()
                                        }
                                    }(),
                                    t = {
                                        source: window.location.href,
                                        target: this.projectIdentifier
                                    },
                                    r = new XMLHttpRequest;
                                r.open("PUT", e, !0), r.setRequestHeader("Content-Type", "application/json;charset=UTF-8"), r.onreadystatechange = function() {
                                    if (4 === r.readyState && 200 === r.status) {
                                        var e = JSON.parse(r.responseText).target_uuid,
                                            t = (/\/e\//.test(window.location.href) ? "/e/" : "/p/") + e + "?play=1";
                                        window.location.href = new URL(t, window.location.href).toString()
                                    }
                                }, r.send(JSON.stringify(t))
                            }
                        }, e
                    }();
                t.HSProjectOpener = s, window.HSProjectOpener = s
            },
            662: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSRule = t.SCRIPT_ID_KEY = void 0;
                var i = r(655),
                    s = r(6642),
                    n = r(2127),
                    o = r(9002),
                    a = r(4222),
                    h = r(7351),
                    l = r(3847),
                    u = r(1559),
                    c = r(445),
                    d = r(3441);
                t.SCRIPT_ID_KEY = "abilityID";
                var p = t.HSRule = function(e) {
                    function r(t) {
                        var r = e.call(this, t) || this;
                        return r.type = c.HSBlockType.Rule, r
                    }
                    return i.__extends(r, e), r.prototype.stageRule = function(e, t) {
                        var r = new l.HSStageRule(this.childBlock().stageParameterBlock(e), e, t);
                        return r.stageScript = this.script.stageScript(r), r
                    }, r.prototype.stageRules = function(e, t) {
                        return [this.stageRule(e, t)]
                    }, r.prototype.parseJSON = function(r) {
                        if (void 0 === r && (r = {}), this.context.version < n.HSProjectVersion.CUSTOM_WHENS) this.parseLowerThanCustomWhensJSON(r);
                        else {
                            var i = this.context.findWithObjectID("HSScript", r[t.SCRIPT_ID_KEY]);
                            i ? (e.prototype.parseJSON.call(this, r), this.childBlock() ? (this.objectID = r.id, this.script = i) : this.context.deleteObject(this)) : this.context.deleteObject(this)
                        }
                    }, r.prototype.parseLowerThanCustomWhensJSON = function(r) {
                        void 0 === r && (r = {});
                        var i = this.context.findWithObjectID("HSScript", r[t.SCRIPT_ID_KEY]),
                            o = this.context.findWithObjectID("HSObject", r[s.OBJECT_ID_KEY]);
                        o && i ? (this.context.version < n.HSProjectVersion.V14 && this.parseLowerThanV14JSON(r, o), e.prototype.parseJSON.call(this, r), this.childBlock() ? (this.script = i, o.willChangeCostume = o.canChangeCostume() && i.containsChangeCostume(), o.addRule(this)) : this.context.deleteObject(this)) : this.context.deleteObject(this)
                    }, r.prototype.parseLowerThanV14JSON = function(e, t) {
                        var r = e.eventType,
                            i = (0, c.blockTypeForLegacyEventType)(r),
                            s = new h.HSParameterBlock(this.context);
                        s.type = i;
                        var n = new o.HSParameter(this.context);
                        switch (this.parameters = [n], n.childBlock = s, i) {
                            case c.HSBlockType.EventOperatorTap:
                            case c.HSBlockType.EventOperatorHold:
                                this.addObjectToEventOperator(s, t);
                                break;
                            case c.HSBlockType.EventOperatorBump:
                            case c.HSBlockType.EventOperatorIsTouching:
                            case c.HSBlockType.EventOperatorIsNotTouching:
                                this.addObjectsToBumps(s, t, e)
                        }
                    }, r.prototype.addObjectToEventOperator = function(e, t) {
                        var r = new u.HSEventParameterBlock(this.context);
                        r.object = t;
                        var i = new o.HSParameter(this.context);
                        i.type = d.HSParameterType.HSObject, i.childBlock = r, e.parameters = [i]
                    }, r.prototype.addObjectsToBumps = function(e, t, r) {
                        var i = new u.HSEventParameterBlock(this.context);
                        i.object = t;
                        var s = new u.HSEventParameterBlock(this.context);
                        s.object = this.context.findWithObjectID("HSObject", r.collisionReceiverObject);
                        var n = new o.HSParameter(this.context);
                        n.type = d.HSParameterType.HSObject, n.childBlock = i;
                        var a = new o.HSParameter(this.context);
                        a.type = d.HSParameterType.HSObject, a.childBlock = s, e.parameters = [n, a]
                    }, r.prototype.firstObject = function() {
                        return this.childBlock() && this.childBlock().parameters.length > 0 ? this.childBlock().parameters[0].childBlock.object : null
                    }, r.prototype.firstParam = function() {
                        return this.parameters[0]
                    }, r.prototype.childBlock = function() {
                        return this.firstParam().childBlock
                    }, r.prototype.eventType = function() {
                        return this.childBlock().type
                    }, r.prototype.eventParameterBlocks = function() {
                        var e = [];
                        return this.childBlock() && this.childBlock().parameters.forEach((function(t) {
                            t.childBlock && e.push(t.childBlock)
                        })), e
                    }, r.prototype.paramsBlock = function() {
                        if (this.childBlock().parameters[0]) return this.childBlock().parameters[0].childBlock
                    }, r.prototype.matchesEvent = function(e) {
                        return this.childBlock().type === e
                    }, r.key = "HSRule", r
                }(a.HSBlock);
                window.HSRule = p, window.SCRIPT_ID_KEY = t.SCRIPT_ID_KEY
            },
            1518: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSScene = void 0;
                var i = r(655),
                    s = r(4662),
                    n = r(1925),
                    o = r(6642),
                    a = r(9751),
                    h = t.HSScene = function(e) {
                        function t() {
                            var t = null !== e && e.apply(this, arguments) || this;
                            return t.objects = [], t
                        }
                        return i.__extends(t, e), t.prototype.parseJSON = function(e) {
                            var t = this;
                            void 0 === e && (e = {}), e[a.OBJECTS_KEY] && e[a.OBJECTS_KEY].length > 0 ? this.objects = e[a.OBJECTS_KEY].map((function(e) {
                                return t.context.findWithObjectID(o.HSObject.key, e)
                            })) : e[a.OBJECTS_KEY] && 0 === e[a.OBJECTS_KEY].length ? this.objects = [] : this.objects = this.context.findAllForClassName(o.HSObject.key), this.name = e.name, this.objectID = e.id
                        }, t.prototype.stageScene = function() {
                            var e = this.objects.map((function(e) {
                                return e.stageObject()
                            }));
                            return new n.HSStageScene(e, this.name, this.objectID, this.context)
                        }, t.key = "HSScene", t
                    }(s.HSManagedObject);
                window.HSScene = h
            },
            9470: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSScript = t.BLOCKS_KEY = void 0;
                var i = r(655),
                    s = r(4662),
                    n = r(3025),
                    o = r(662),
                    a = r(4222),
                    h = r(7069),
                    l = r(179),
                    u = r(450),
                    c = r(445);
                t.BLOCKS_KEY = "blocks";
                var d = t.HSScript = function(e) {
                    function r() {
                        var t = null !== e && e.apply(this, arguments) || this;
                        return t.blocks = [], t
                    }
                    return i.__extends(r, e), r.prototype.addObjectIDFromJSON = function(e) {
                        void 0 === e && (e = {}), this.objectID = e[o.SCRIPT_ID_KEY]
                    }, r.prototype.stageScript = function(e) {
                        return new l.HSStageScript(e, this)
                    }, r.prototype.stageBlocks = function(e) {
                        return this.blocks.map((function(t) {
                            return t.stageBlock(e)
                        }))
                    }, r.prototype.isImmediatelyRecursive = function() {
                        return this.blocks.length > 0 && this.blocks[0].scripts && this.blocks[0].scripts[0] === this || !this.firstMethod(0)
                    }, r.prototype.firstMethod = function(e) {
                        if (e > 30) return null;
                        var t = this.blocks[0];
                        return t ? t.isControl ? t.scripts[0] ? t.scripts[0].firstMethod(e + 1) : null : t : this
                    }, r.prototype.containsChangeCostume = function(e) {
                        void 0 === e && (e = {});
                        for (var t = 0; t < this.blocks.length; t++) {
                            var r = this.blocks[t];
                            if (r.type === c.HSBlockType.ChangeCostume) return !0;
                            var i = r;
                            if (i.scripts)
                                for (var s = 0; s < i.scripts.length; s++) {
                                    var n = i.scripts[s],
                                        o = n.objectID;
                                    if (!e[o] && (e[o] = !0, n.containsChangeCostume(e))) return !0
                                }
                        }
                        return !1
                    }, r.prototype.parseJSON = function(e) {
                        var r = this;
                        void 0 === e && (e = {}), (e[t.BLOCKS_KEY] || []).forEach((function(e) {
                            var t;
                            switch (a.HSBlock.blockClassForDict(e)) {
                                case a.HSBlockClass.Control:
                                    t = new h.HSControlBlock(r.context);
                                    break;
                                case a.HSBlockClass.Method:
                                    t = new u.HSMethodBlock(r.context);
                                    break;
                                case a.HSBlockClass.ConditionalControl:
                                    t = new n.HSConditionalControl(r.context)
                            }
                            t.parentNode = r, t.parseJSON(e), r.blocks.push(t)
                        }))
                    }, r.key = "HSScript", r
                }(s.HSManagedObject);
                window.HSScript = d, window.BLOCKS_KEY = t.BLOCKS_KEY
            },
            4066: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSSound = void 0;
                var i = r(9005),
                    s = t.HSSound = function() {
                        function e(t, r, i) {
                            void 0 === i && (i = "mp3");
                            var s = this;
                            this.name = t, this.context = r, this.extension = i, this.sources = new Set, e.soundCache.has(t) || e.soundCache.set(t, new Promise((function(e, t) {
                                var r = new XMLHttpRequest;
                                r.open("GET", s.url(), !0), r.responseType = "arraybuffer", r.onload = function() {
                                    r.status >= 200 && r.status < 300 ? s.context.decodeAudioData(r.response, e, (function() {})) : t(r)
                                }, r.onerror = t, r.send()
                            }))), e.soundCache.get(t).then((function(e) {
                                return s.buffer = e
                            })).catch((function(e) {
                                s.buffer = null
                            }))
                        }
                        return e.prototype.play = function() {
                            var e = this;
                            if ((0, i.isIOSApp)()) i.HSApp.sendToApp("sound", this.name);
                            else if (this.buffer) {
                                var t = this.context.createBufferSource();
                                t.buffer = this.buffer, t.connect(this.context.destination), t.start(0), this.sources.add(t), t.onended = function() {
                                    return e.sources.delete(t)
                                }
                            }
                        }, e.prototype.stop = function() {
                            this.sources.forEach((function(e) {
                                return e.stop()
                            })), this.sources.clear()
                        }, e.prototype.url = function() {
                            return "https://d2jeqdlsh5ay24.cloudfront.net/".concat(this.name, ".").concat(this.extension)
                        }, e.soundCache = new Map, e
                    }();
                window.HSSound = s
            },
            3452: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSSoundManager = t.AudioContext = void 0;
                var i = r(4066),
                    s = r(3372);
                t.AudioContext = window.AudioContext || window.webkitAudioContext;
                var n = t.HSSoundManager = function() {
                    function e(t, r) {
                        var n = this;
                        this.sounds = {}, this.context = e.audioContext, this.isMuted = !1, t.forEach((function(e) {
                            var t = e.split("."),
                                r = t[0],
                                s = t[1] || "mp3";
                            n.sounds[r] = new i.HSSound(r, n.context, s)
                        })), e.hasUnlockListener || (e.hasUnlockListener = !0, this.unlockListener = function() {
                            var e = n.context.createBufferSource();
                            e.buffer = n.context.createBuffer(1, 1, 22050), e.connect(n.context.destination), e.start(0), window.removeEventListener("touchstart", n.unlockListener), window.removeEventListener("touchend", n.unlockListener), window.removeEventListener("mousedown", n.unlockListener)
                        }, window.addEventListener("touchstart", this.unlockListener), window.addEventListener("touchend", this.unlockListener), window.addEventListener("mousedown", this.unlockListener)), this.microphoneManager = new s.HSMicrophoneManager(this.context, r)
                    }
                    return e.prototype.play = function(e) {
                        this.sounds[e] && !this.isMuted && this.sounds[e].play()
                    }, e.prototype.playNote = function(e, t) {
                        var r = t + "/" + e;
                        this.sounds[r] && !this.isMuted && this.sounds[r].play()
                    }, e.prototype.mute = function() {
                        this.isMuted || Object.values(this.sounds).forEach((function(e) {
                            return e.stop()
                        })), this.isMuted = !0
                    }, e.prototype.unmute = function() {
                        this.isMuted = !1
                    }, e.audioContext = new t.AudioContext, e.hasUnlockListener = !1, e
                }();
                window.HSSoundManager = n
            },
            861: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSVariablePrototype = t.OBJECT_ID_STRING_KEY = void 0;
                var i = r(655),
                    s = r(4662),
                    n = r(445),
                    o = r(9005),
                    a = r(2983);
                t.OBJECT_ID_STRING_KEY = "objectIdString";
                var h = t.HSVariablePrototype = function(e) {
                    function r(t) {
                        return e.call(this, t) || this
                    }
                    return i.__extends(r, e), r.prototype.parseJSON = function(e) {
                        void 0 === e && (e = {}), this.objectID = e[t.OBJECT_ID_STRING_KEY], this.name = e.name, this.type = e.type || n.HSBlockType.Object, this.initialValue = this.getInitialValue()
                    }, r.prototype.getInitialValue = function() {
                        return this.type !== n.HSBlockType.User ? "0" : a.HSStageVariable.parseValue(o.HSApp.initialUserVariables[this.objectID], !0) || "0"
                    }, r.key = "HSVariablePrototype", r
                }(s.HSManagedObject);
                window.HSVariablePrototype = h
            },
            2277: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.UIRegisterEventCallbacks = t.UIEventListener = t.UIEventListeners = t.UIPointerEvent = void 0;
                var i = r(1925),
                    s = r(66),
                    n = function(e, t, r) {
                        void 0 === r && (r = 0), this.id = r, this.id = r;
                        var n = e.target,
                            o = n.clientWidth,
                            a = n.clientHeight;
                        this.point = new s.Vec2(t[0] * i.HSStageScene.stageWidth / o, i.HSStageScene.stageHeight - t[1] * i.HSStageScene.stageHeight / a)
                    };
                t.UIPointerEvent = n;
                var o = function() {
                    function e(e) {
                        this.listeners = e
                    }
                    return e.prototype.unregister = function() {
                        this.listeners.forEach((function(e) {
                            return e.unregister()
                        }))
                    }, e
                }();
                t.UIEventListeners = o;
                var a = function() {
                    function e(e, t, r) {
                        this.element = e, this.eventType = t, this.callback = r, e.addEventListener(t, r)
                    }
                    return e.prototype.unregister = function() {
                        this.element.removeEventListener(this.eventType, this.callback)
                    }, e
                }();
                t.UIEventListener = a, t.UIRegisterEventCallbacks = function(e, t) {
                    function r(e, t, r) {
                        return new a(e, t, (function(e) {
                            e.preventDefault(), r(e)
                        }))
                    }

                    function i(e, t, i) {
                        return r(e, t, (function(e) {
                            var t = [e.offsetX, e.offsetY],
                                r = new n(e, t);
                            i(r)
                        }))
                    }

                    function s(e, t, i) {
                        return r(e, t, (function(e) {
                            return function(e, t) {
                                var r = e.target.getBoundingClientRect();
                                Array.from(e.changedTouches).forEach((function(e) {
                                    t(new n(e, [e.clientX - r.left, e.clientY - r.top], e.identifier))
                                }))
                            }(e, i)
                        }))
                    }
                    var h = !1;
                    return new o([i(e, "mousedown", (function(e) {
                        h && t.pointerUp(e), h = !0, t.pointerDown(e)
                    })), i(e, "mousemove", (function(e) {
                        h && t.pointerDrag(e)
                    })), i(window, "mouseup", (function(e) {
                        t.pointerUp(e), h = !1
                    })), s(e, "touchstart", t.pointerDown), s(e, "touchmove", t.pointerDrag), s(window, "touchend", t.pointerUp), s(window, "touchcancel", t.pointerCancel)])
                }, window.UIPointerEvent = n, window.UIEventListeners = o, window.UIEventListener = a
            },
            3724: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.SourceFormatter = void 0;
                var i = r(445),
                    s = r(3441),
                    n = function() {
                        function e() {}
                        return e.blocksToSrc = function(e) {
                            return null == e ? void 0 : e.join(", ")
                        }, e.blockToSrc = function(e) {
                            var t;
                            return i.HSBlockType[e.type] + "(" + (null === (t = e.parameters) || void 0 === t ? void 0 : t.join(", ")) + ")"
                        }, e.paramToSrc = function(e) {
                            return s.HSParameterType[e.type] + ": " + e.value
                        }, e.stageParamToSrc = function(e, t) {
                            return e + (t ? "...\n" + t.toString() : "")
                        }, e.stageControlToSrc = function(e) {
                            var t = i.HSBlockType[e.type] + "(" + e.parameters.join(", ") + ")";
                            return e.scripts.length > 0 && (t += " { ", t += e.scripts.map((function(e) {
                                return e.toString()
                            })).join(" } ")), t
                        }, e.stageMethodToSrc = function(e) {
                            return i.HSBlockType[e.type] + "(" + e.parameters.join(", ") + ")"
                        }, e.executableToSrc = function(e) {
                            return "NOW {" + e.blocksToExecuteNow.map((function(e) {
                                return e.toString()
                            })).join(", ") + "}; LATER {" + e.blocksToExecuteLater.map((function(e) {
                                return e.toString()
                            })).join(", ") + "}"
                        }, e
                    }();
                t.SourceFormatter = n, window.SourceFormatter = n
            },
            7925: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSConditionalCalculator = void 0;
                var i = r(445),
                    s = r(2983),
                    n = r(9005),
                    o = function() {
                        function e() {}
                        return e.prototype.computedBooleanValue = function(e, t, r, o) {
                            switch (t = s.HSStageVariable.parseValue(t, !0), r = s.HSStageVariable.parseValue(r, !0), e) {
                                case i.HSBlockType.ConditionalOperatorMatches:
                                    return (0, n.checkMatches)(String(t), String(r));
                                case i.HSBlockType.ConditionalOperatorEquals:
                                    return a(t, r);
                                case i.HSBlockType.ConditionalOperatorLessThan:
                                    return h(t, r) && !a(t, r);
                                case i.HSBlockType.ConditionalOperatorLessThanOrEqualTo:
                                    return a(t, r) || h(t, r);
                                case i.HSBlockType.ConditionalOperatorGreaterThan:
                                    return l(t, r) && !a(t, r);
                                case i.HSBlockType.ConditionalOperatorGreaterThanOrEqualTo:
                                    return a(t, r) || l(t, r);
                                case i.HSBlockType.ConditionalOperatorNotEquals:
                                    return !a(t, r);
                                case i.HSBlockType.ConditionalOperatorAnd:
                                    return !(!s.HSStageVariable.parseNumberFrom(t) || !s.HSStageVariable.parseNumberFrom(r));
                                case i.HSBlockType.ConditionalOperatorOr:
                                    return !(!s.HSStageVariable.parseNumberFrom(t) && !s.HSStageVariable.parseNumberFrom(r));
                                case i.HSBlockType.EventOperatorGamePlaying:
                                    return !0;
                                case i.HSBlockType.ConditionalOperatorIsFlipped:
                                    return o.isFlipped;
                                case i.HSBlockType.ConditionalOperatorNot:
                                    return !s.HSStageVariable.parseNumberFrom(t);
                                default:
                                    return !1
                            }
                        }, e
                    }();

                function a(e, t) {
                    if ("number" == typeof e && "number" == typeof t) {
                        var r = e,
                            i = t;
                        return Math.abs(r - i) <= Number.EPSILON
                    }
                    return e.toString() === t.toString()
                }

                function h(e, t) {
                    if ("number" == typeof e && "number" == typeof t) return e < t;
                    var r = e.toString(),
                        i = t.toString();
                    return -1 === r.localeCompare(i)
                }

                function l(e, t) {
                    if ("number" == typeof e && "number" == typeof t) return e > t;
                    var r = e.toString(),
                        i = t.toString();
                    return 1 === r.localeCompare(i)
                }
                t.HSConditionalCalculator = o
            },
            4882: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.LinePropertiesParser = void 0;
                var i = r(445),
                    s = r(8362),
                    n = function() {
                        function e() {}
                        return e.prototype.computedColorString = function(e, t) {
                            switch (e) {
                                case i.HSBlockType.ColorOperatorRandom:
                                    return s.HSColor.randomColor();
                                case i.HSBlockType.ColorOperatorRGB:
                                    return s.HSColor.rgb(t[0] % 256, t[1] % 256, t[2] % 256);
                                case i.HSBlockType.ColorOperatorHSB:
                                    return s.HSColor.hsb(t[0] % 361, t[1] % 101, t[2] % 101);
                                default:
                                    return s.HSColor.rgbTextColor
                            }
                        }, e.prototype.colorStringFromNumber = function(e) {
                            var t, r = String(e);
                            return null !== (t = s.HSColor.rgbStringFromNumericColor(r)) && void 0 !== t ? t : r
                        }, e.prototype.lineCapFromString = function(e) {
                            return s.HSLineCap.lineCapFromString(e)
                        }, e
                    }();
                t.LinePropertiesParser = n
            },
            2388: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSMathCalculator = void 0;
                var i = r(445),
                    s = r(2983),
                    n = r(9005),
                    o = function() {
                        function e() {}
                        return e.prototype.computedValue = function(e, t) {
                            var r = t[0],
                                o = t[1];
                            switch (r = s.HSStageVariable.parseValue(r, !0), o = s.HSStageVariable.parseValue(o, !0), e) {
                                case i.HSBlockType.Random110:
                                    return Math.floor(-8 * Math.random()) + 10;
                                case i.HSBlockType.Random1100:
                                    return Math.floor(-98 * Math.random()) + 100;
                                case i.HSBlockType.Random11000:
                                    return Math.floor(-998 * Math.random()) + 1e3;
                                case i.HSBlockType.MathOperatorRandom:
                                case i.HSBlockType.Random:
                                    var a = Math.max(r, o),
                                        h = Math.min(r, o);
                                    return Math.floor(Math.random() * (a - h + 1)) + h;
                                case i.HSBlockType.MathOperatorAdd:
                                    return r = s.HSStageVariable.parseValue(r, !1), o = s.HSStageVariable.parseValue(o, !1), "number" == typeof r && "number" == typeof o ? r + o : ("number" == typeof r && (r = Math.round(1e6 * r) / 1e6), "number" == typeof o && (o = Math.round(1e6 * o) / 1e6), (r = r.toString()) + (o = o.toString()));
                                case i.HSBlockType.MathOperatorSubtract:
                                    return r - o;
                                case i.HSBlockType.MathOperatorMultiply:
                                    return r * o;
                                case i.HSBlockType.MathOperatorDivide:
                                    return 0 === o ? 0 : r / o;
                                case i.HSBlockType.MathOperatorSine:
                                    return Math.sin((0, n.degreesToRadians)(r));
                                case i.HSBlockType.MathOperatorCosine:
                                    return Math.cos((0, n.degreesToRadians)(r));
                                case i.HSBlockType.MathOperatorTangent:
                                    return Math.tan((0, n.degreesToRadians)(r));
                                case i.HSBlockType.MathOperatorInverseSine:
                                    return (0, n.radiansToDegrees)(Math.asin(r) || 0);
                                case i.HSBlockType.MathOperatorInverseCosine:
                                    return (0, n.radiansToDegrees)(Math.acos(r) || 0);
                                case i.HSBlockType.MathOperatorInverseTangent:
                                    return (0, n.radiansToDegrees)(Math.atan(r) || 0);
                                case i.HSBlockType.MathOperatorMaximum:
                                    var l = o;
                                    if ("string" == typeof r || "string" == typeof l) {
                                        var u = r.toString(),
                                            c = l.toString();
                                        return u.localeCompare(c) >= 0 ? u : c
                                    }
                                    return Math.max(r, o);
                                case i.HSBlockType.MathOperatorMinimum:
                                    var d = o;
                                    return "string" == typeof r || "string" == typeof d ? (u = r.toString(), c = d.toString(), u.localeCompare(c) <= 0 ? u : c) : Math.min(r, o);
                                case i.HSBlockType.MathOperatorSquareRoot:
                                    return Math.sqrt(r);
                                case i.HSBlockType.MathOperatorPower:
                                    return Math.pow(r, o);
                                case i.HSBlockType.MathOperatorFloor:
                                    return Math.floor(r);
                                case i.HSBlockType.MathOperatorCeiling:
                                    return Math.ceil(r);
                                case i.HSBlockType.MathOperatorRound:
                                    return Math.round(r);
                                case i.HSBlockType.MathOperatorAbs:
                                    return Math.abs(r);
                                case i.HSBlockType.MathOperatorModulo:
                                    return 0 === o ? 0 : r % o;
                                default:
                                    return null
                            }
                        }, e
                    }();
                t.HSMathCalculator = o
            },
            3112: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSTextCalculator = void 0;
                var i = r(445),
                    s = function() {
                        function e() {}
                        return e.prototype.computedValue = function(e, t, r, s, n) {
                            switch (void 0 === n && (n = ""), e) {
                                case i.HSBlockType.TextOperatorCharAtIndex:
                                    return t[r] || "";
                                case i.HSBlockType.TextOperatorCharsInRange:
                                    return t.slice(r, s);
                                case i.HSBlockType.TextOperatorLength:
                                    return (null == t ? void 0 : t.length) || 0;
                                case i.HSBlockType.TextOperatorJoin:
                                    return t.concat(n);
                                default:
                                    return null
                            }
                        }, e
                    }();
                t.HSTextCalculator = s
            },
            3209: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSTraitCalculator = void 0;
                var i = r(37),
                    s = r(8519),
                    n = r(445),
                    o = r(2983),
                    a = r(682),
                    h = r(7779),
                    l = r(1925),
                    u = function() {
                        function e() {}
                        return e.prototype.computedValue = function(e, t, r) {
                            switch (e) {
                                case n.HSBlockType.TraitXPosition:
                                    // console.log(t.name)
                                    return Math.round((null == t ? void 0 : t.x) || 0);
                                case n.HSBlockType.TraitYPosition:
                                    return Math.round((null == t ? void 0 : t.y) || 0);
                                case n.HSBlockType.TraitWidth:
                                    // console.log(t.name)
                                    return (null == t ? void 0 : t.width()) || 0;
                                case n.HSBlockType.TraitHeight:
                                    return (null == t ? void 0 : t.height()) || 0;
                                case n.HSBlockType.TraitZIndex:
                                    return (null == t ? void 0 : t.zIndex) || 0;
                                case n.HSBlockType.TraitOriginX:
                                    return Math.round((null == t ? void 0 : t.originX) || 0);
                                case n.HSBlockType.TraitOriginY:
                                    return Math.round((null == t ? void 0 : t.originY) || 0);
                                case n.HSBlockType.TraitCenterX:
                                    return Math.round((null == t ? void 0 : t.x) || 0);
                                case n.HSBlockType.TraitCenterY:
                                    return Math.round((null == t ? void 0 : t.y) || 0);
                                case n.HSBlockType.TraitRotation:
                                    return (null == t ? void 0 : t.headingInDegrees) || 0;
                                case n.HSBlockType.TraitUsername:
                                    return s.HSMain.currentPlayerName;
                                case n.HSBlockType.TraitObjectName:
                                    return (null == t ? void 0 : t.name) || "";
                                case n.HSBlockType.TraitTime:
                                    return Date.now();
                                case n.HSBlockType.TraitYear:
                                    return (new Date).getFullYear();
                                case n.HSBlockType.TraitMonth:
                                    return (new Date).getMonth() + 1;
                                case n.HSBlockType.TraitDay:
                                    return (new Date).getDate();
                                case n.HSBlockType.TraitHour:
                                    return (new Date).getHours();
                                case n.HSBlockType.TraitMinute:
                                    return (new Date).getMinutes();
                                case n.HSBlockType.TraitSecond:
                                    return (new Date).getSeconds();
                                case n.HSBlockType.TraitSpeed:
                                    return (null == t ? void 0 : t.speed) || 0;
                                case n.HSBlockType.TraitCloneIndex:
                                    return (null == t ? void 0 : t.cloneIndex) || 0;
                                case n.HSBlockType.TraitText:
                                    var u = (null == t ? void 0 : t.text) || "";
                                    return o.HSStageVariable.parseValue(u, !1).toString();
                                case n.HSBlockType.TraitTotalClones:
                                    return r.allStageObjects().length;
                                case n.HSBlockType.StageTraitTotalObjects:
                                    return h.HSStageProject.sharedInstance.activeStageScene.stageObjects.length;
                                case n.HSBlockType.TraitInvisibility:
                                    return (null == t ? void 0 : t.invisibilityPercent) || 0;
                                case n.HSBlockType.TraitSize:
                                    return this.computedSizePercent(t);
                                case n.HSBlockType.StageTraitLastTouchX:
                                    return h.HSStageProject.sharedInstance.activeStageScene.lastTouchX;
                                case n.HSBlockType.StageTraitLastTouchY:
                                    return h.HSStageProject.sharedInstance.activeStageScene.lastTouchY;
                                case n.HSBlockType.StageTraitTiltUp:
                                    return i.HSAccelerometerManager.tiltUp;
                                case n.HSBlockType.StageTraitTiltDown:
                                    return i.HSAccelerometerManager.tiltDown;
                                case n.HSBlockType.StageTraitTiltLeft:
                                    return i.HSAccelerometerManager.tiltLeft;
                                case n.HSBlockType.StageTraitTiltRight:
                                    return i.HSAccelerometerManager.tiltRight;
                                case n.HSBlockType.StageTraitWidth:
                                    return l.HSStageScene.stageWidth;
                                case n.HSBlockType.StageTraitHeight:
                                    return l.HSStageScene.stageHeight;
                                case n.HSBlockType.EventOperatorGamePlaying:
                                    return 1;
                                case n.HSBlockType.TraitTempo:
                                    return (null == t ? void 0 : t.tempo) || a.DEFAULT_TEMPO;
                                case n.HSBlockType.TraitInstrument:
                                    return (null == t ? void 0 : t.instrument) || a.DEFAULT_INSTRUMENT;
                                default:
                                    return null
                            }
                        }, e.prototype.computedSizePercent = function(e) {
                            switch (this.whichSizeShouldIUse(e)) {
                                case "minimum":
                                    return Math.min(e.sizePercentHeight, e.sizePercentWidth);
                                case "height":
                                    return e.sizePercentHeight;
                                case "width":
                                    return e.sizePercentWidth
                            }
                        }, e.prototype.whichSizeShouldIUse = function(e) {
                            var t = Math.abs(e.sizePercentHeight),
                                r = Math.abs(e.sizePercentWidth);
                            return t === r ? "minimum" : t > r ? "height" : "width"
                        }, e
                    }();
                    t.HSTraitCalculator = u
            },
            5203: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSCollisionPair = void 0;
                var r = function() {
                    function e(e, t) {
                        this.isOverlapping = !1, this.wasOverlapping = !1;
                        var r = this.getSortedPair(e, t);
                        this.stageObject1 = r[0], this.stageObject2 = r[1], this.uniqueKey = this.stageObject1.stageObjectID + "_" + this.stageObject2.stageObjectID
                    }
                    return e.prototype.getSortedPair = function(e, t) {
                        return e.stageObjectID < t.stageObjectID ? [e, t] : [t, e]
                    }, e.prototype.collisionTest = function(e) {
                        return !!this.canCollide() && e.collisionTest(this.stageObject1, this.stageObject2)
                    }, e.prototype.isVisible = function() {
                        return !this.stageObject1.isInvisible() && !this.stageObject2.isInvisible()
                    }, e.prototype.canCollide = function() {
                        return this.isVisible() && this.isAlive()
                    }, e.prototype.isAlive = function() {
                        return this.stageObject1.isAlive && this.stageObject2.isAlive
                    }, e.prototype.update = function(e) {
                        this.wasOverlapping = this.isOverlapping, this.isOverlapping = this.collisionTest(e)
                    }, e.prototype.isTouching = function() {
                        return this.isOverlapping
                    }, e.prototype.isBumping = function() {
                        return this.isTouching() && !this.wasOverlapping
                    }, e
                }();
                t.HSCollisionPair = r, window.HSCollisionPair = r
            },
            1754: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSCollisionPairCollection = void 0;
                var r = function() {
                    function e(e) {
                        void 0 === e && (e = []), this.pairMap = new Map, this.add(e)
                    }
                    return e.prototype.add = function(e) {
                        var t = this;
                        e.forEach((function(e) {
                            return t.addOne(e)
                        }))
                    }, e.prototype.filter = function(t) {
                        return new e(this.toArray().filter(t))
                    }, e.prototype.contains = function(e) {
                        return this.pairMap.has(e.uniqueKey)
                    }, e.prototype.without = function(e) {
                        return this.filter((function(t) {
                            return !e.contains(t)
                        }))
                    }, e.prototype.addOne = function(e) {
                        this.pairMap.set(e.uniqueKey, e)
                    }, e.prototype.toArray = function() {
                        return Array.from(this.pairMap.values())
                    }, e.prototype.intersects = function(e) {
                        var t = this;
                        return e.some((function(e) {
                            return t.contains(e)
                        }))
                    }, e.prototype.copy = function() {
                        return new e(Array.from(this))
                    }, e.prototype.forEach = function(e) {
                        return this.pairMap.forEach((function(t) {
                            return e(t)
                        }))
                    }, e.prototype[Symbol.iterator] = function() {
                        return this.pairMap.values()
                    }, e.prototype.length = function() {
                        return this.pairMap.size
                    }, e
                }();
                t.HSCollisionPairCollection = r, window.HSCollisionPairCollection = r
            },
            8362: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSLineCap = t.HSColor = void 0;
                var i = r(9521),
                    s = t.HSColor = function() {
                        function e() {}
                        return e.textColor = function() {
                            return e.rgbTextColor
                        }, e.randomColor = function() {
                            var t = e.RGBAColors.length,
                                r = Math.floor(Math.random() * (t - 1));
                            return e.RGBAColors[r]
                        }, e.rgb = function(e, t, r) {
                            return "rgb(" + Math.round(e) + ", " + Math.round(t) + ", " + Math.round(r) + ")"
                        }, e.hexColor = function(e) {
                            return new i.TinyColor(e).toHex()
                        }, e.hexToTint = function(t) {
                            return void 0 === this._colorMap.get(t) && this._colorMap.set(t, parseInt(e.hexColor(t), 16)), this._colorMap.get(t)
                        }, e.hsb = function(t, r, i) {
                            return e.convertHSBStringToRGBAString("HSB(".concat(t, ", ").concat(r, "%, ").concat(i, "%)"))
                        }, e.rgbStringFromHSBString = function(t) {
                            var r = e.hsbRGBAColorMaps[t];
                            return r || (r = e.convertHSBStringToRGBAString(t)), r
                        }, e.hsbStringFromRgbString = function(e) {
                            var t = new i.TinyColor(e).toHsv();
                            return "HSB(".concat(Math.round(t.h), ",").concat(Math.round(100 * t.s), ",").concat(Math.round(100 * t.v), ")")
                        }, e.rgbStringFromNumericColor = function(t) {
                            var r = parseFloat(t);
                            if (!isNaN(r)) {
                                var i = Math.abs(Math.round(r) % e.RGBAColors.length);
                                return e.RGBAColors[i]
                            }
                            return null
                        }, e.convertHSBStringToTinyColor = function(e) {
                            var t = e.replace("B", "V");
                            return new i.TinyColor(t)
                        }, e.convertHSBStringToRGBAString = function(e) {
                            return this.convertHSBStringToTinyColor(e).toRgbString()
                        }, e.RGBAColors = ["rgb(100, 48, 112)", "rgb(134, 77, 209)", "rgb(168, 177, 255)", "rgb(215, 163, 227)", "rgb(255, 179, 207)", "rgb(232, 84, 96)", "rgb(214, 24, 100)", "rgb(212, 8, 29)", "rgb(255, 119, 0)", "rgb(250, 204, 0)", "rgb(255, 233, 38)", "rgb(159, 245, 165)", "rgb(134, 196, 63)", "rgb(64, 143, 50)", "rgb(86, 214, 186)", "rgb(140, 219, 255)", "rgb(10, 169, 209)", "rgb(39, 138, 219)", "rgb(29, 60, 117)", "rgb(77, 77, 77)", "rgb(51, 41, 50)", "rgb(122, 67, 29)", "rgb(204, 204, 204)", "rgb(255, 255, 255)", "rgb(250,220,186)", "rgb(225,187,146)", "rgb(192,143,101)", "rgb(156,100,57)", "rgb(89,69,56)"], e.hsbRGBAColorMaps = {
                            "HSB(289,57,44)": "rgb(100, 48, 112)",
                            "HSB(266,63,82)": "rgb(134, 77, 209)",
                            "HSB(234,34,100)": "rgb(168, 177, 255)",
                            "HSB(289,28,89)": "rgb(215, 163, 227)",
                            "HSB(338,30,100)": "rgb(255, 179, 207)",
                            "HSB(355,64,91)": "rgb(232, 84, 96)",
                            "HSB(336,89,84)": "rgb(214, 24, 100)",
                            "HSB(354,96,83)": "rgb(212, 8, 29)",
                            "HSB(28,100,100)": "rgb(255, 119, 0)",
                            "HSB(49,100,98)": "rgb(250, 204, 0)",
                            "HSB(54,85,100)": "rgb(255, 233, 38)",
                            "HSB(124,35,96)": "rgb(159, 245, 165)",
                            "HSB(88,68,77)": "rgb(134, 196, 63)",
                            "HSB(111,65,56)": "rgb(64, 143, 50)",
                            "HSB(167,60,84)": "rgb(86, 214, 186)",
                            "HSB(199,45,100)": "rgb(140, 219, 255)",
                            "HSB(192,95,82)": "rgb(10, 169, 209)",
                            "HSB(207,82,86)": "rgb(39, 138, 219)",
                            "HSB(219,75,46)": "rgb(29, 60, 117)",
                            "HSB(0,0,30)": "rgb(77, 77, 77)",
                            "HSB(306,20,20)": "rgb(51, 41, 50)",
                            "HSB(24,76,48)": "rgb(122, 67, 29)",
                            "HSB(0,0,80)": "rgb(204, 204, 204)",
                            "HSB(0,0,100)": "rgb(255, 255, 255)",
                            "HSB(32,26,98)": "rgb(250,220,186)",
                            "HSB(31,35,88)": "rgb(225,187,146)",
                            "HSB(28,47,75)": "rgb(192,143,101)",
                            "HSB(26,63,61)": "rgb(156,100,57)",
                            "HSB(24,37,35)": "rgb(89,69,56)"
                        }, e.rgbWhiteColor = "rgb(255, 255, 255)", e.rgbTextColor = "rgb(0,0,0)", e._colorMap = new Map, e
                    }(),
                    n = function() {
                        function e() {}
                        return e.lineCapFromString = function(e) {
                            switch (e) {
                                case "round":
                                case "square":
                                case "butt":
                                    return e
                            }
                            return "round"
                        }, e
                    }();
                t.HSLineCap = n, window.HSColor = s, window.HSLineCap = n
            },
            4450: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSExecutable = void 0;
                var i = r(655),
                    s = r(3724),
                    n = r(7779),
                    o = r(3452),
                    a = r(9449),
                    h = r(445),
                    l = r(9005),
                    u = function() {
                        function e(e, t, r) {
                            void 0 === r && (r = !1), this.blocksToExecuteNow = e, this.blocksToExecuteLater = t, this.isImmediate = r
                        }
                        return e.prototype.newWithNewBlocksToExecuteLater = function(t) {
                            return new e(this.blocksToExecuteNow, t)
                        }, e.prototype.execute = function(e) {
                            var t = this;
							/*PETRICHOR DEBUGGER MOD START*/
                            for (let petrichori = 0; petrichori < t.blocksToExecuteNow.length; petrichori++) {
								const block = t.blocksToExecuteNow[petrichori]
								petrichorFrameStateStack.push({state: PetrichorPossibleFrameProgressStates.progressInExecutable, index: petrichori})
								/*PETRICHOR DEBUGGER MOD END*/
                                t.executeBlock(block, e)
								/*PETRICHOR DEBUGGER MOD START*/
								petrichorFrameStateStack.pop()
                            }
							/*PETRICHOR DEBUGGER MOD END*/
                        }, e.prototype.toString = function() {
                            return s.SourceFormatter.executableToSrc(this)
                        }, e.prototype.executeBlock = function(e, t) {
                            var r, s, u = t.parentObject,
                                c = e.parameters;
                            switch (e.type) {
                                case h.HSBlockType.PlaySoundSeconds:
                                case h.HSBlockType.PlaySound:
                                    r = o.HSSoundManager.sharedInstance, s = c[0].computedStringValue(t), r.play(s);
                                    break;
                                case h.HSBlockType.MakeAClone:
                                    var d = 1;
                                    c[0] && (d = c[0].computedNumberValue(t)), u.clone(d);
                                    break;
                                case h.HSBlockType.Destroy:
                                    u.addToDestroyQueue();
                                    break;
                                case h.HSBlockType.ChangeX:
                                case h.HSBlockType.ChangeY:
                                case h.HSBlockType.Move:
                                case h.HSBlockType.Rotate:
                                    var p = u.x,
                                        f = u.y,
                                        m = u.headingInDegrees;
                                    t.executeBlock(e), u.x === p && u.y === f && u.headingInDegrees === m && this.blocksToExecuteLater.shift();
                                    break;
                                case h.HSBlockType.ChangeScene:
                                    n.HSStageProject.sharedInstance.changeScene(c[0].computedSceneValue(t));
                                    break;
                                case h.HSBlockType.BroadcastMessage:
                                    var g = c[0].computedStringValue(t);
                                    g && u.queueEventMessage(g);
                                    break;
                                case h.HSBlockType.RequestSeeds:
                                    ! function(e, t) {
                                        var r = i.__read(e, 2),
                                            s = r[0],
                                            n = r[1].variable();
                                        if (n && 1 !== n.computedNumberValue(t)) {
                                            var o = n.getPublicName();
                                            if (o) {
                                                var a = Math.max(0, Math.floor(s.computedNumberValue(t)));
                                                ! function(e, t, r) {
                                                    (0, l.isIOSApp)() ? l.HSApp.sendToApp("product:purchase", JSON.stringify({
                                                        variableID: e,
                                                        variableName: t,
                                                        seeds: r
                                                    })): confirm('This project is using a feature only available in the Hopscotch iOS App. Tap "OK" to download it!') && window.open("https://apps.apple.com/us/app/hopscotch-make-games/id617098629", "_self")
                                                }(n.objectID, o, a)
                                            }
                                        }
                                    }(c, t);
                                    break;
                                case h.HSBlockType.OpenProject:
                                    var y = c[0].computedStringValue(t);
                                    new a.HSProjectOpener(y).open();
                                default:
                                    t.executeBlock(e)
                            }
                        }, e
                    }();
                t.HSExecutable = u, window.HSExecutable = u
            },
            648: (e, t) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSLinkedListIterator = t.HSLinkedListNode = t.HSLinkedList = void 0;
                var r = function() {
                    function e() {
                        this.nodeMap = new Map, this.headNode = new i, this.length = 0, this.headNode.next = this.headNode, this.headNode.previous = this.headNode
                    }
                    return e.prototype.setNewOrder = function(e) {
                        var t = this,
                            r = e(Array.from(this.nodeMap.keys()));
                        r.forEach((function(e) {
                            return t.remove(e)
                        })), r.forEach((function(e) {
                            return t.push(e)
                        }))
                    }, e.prototype.push = function(e) {
                        if (!this.includes(e)) {
                            var t = new i(e);
                            t.next = this.headNode, t.previous = this.headNode.previous, t.previous.next = t, this.headNode.previous = t, this.nodeMap.set(e, t), this.length++
                        }
                    }, e.prototype.unshift = function(e) {
                        if (!this.includes(e)) {
                            var t = new i(e);
                            t.next = this.headNode.next, t.previous = this.headNode, t.next.previous = t, this.headNode.next = t, this.nodeMap.set(e, t), this.length++
                        }
                    }, e.prototype.remove = function(e) {
                        var t = this.nodeMap.get(e);
                        t && (t.previous.next = t.next, t.next.previous = t.previous, this.nodeMap.delete(e), this.length--)
                    }, e.prototype.includes = function(e) {
                        return this.nodeMap.has(e)
                    }, e.prototype[Symbol.iterator] = function() {
                        return new s(this.headNode)
                    }, e.prototype.getReverseIterator = function() {
                        return new s(this.headNode, !0)
                    }, e.prototype.forEach = function(e) {
                        var t = this,
                            r = 0;
                        this[Symbol.iterator]().forEach((function(i) {
                            return e(i, r++, t)
                        }))
                    }, e.prototype.forEachRight = function(e) {
                        var t = this,
                            r = this.length - 1;
                        this.getReverseIterator().forEach((function(i) {
                            return e(i, r--, t)
                        }))
                    }, e.prototype.find = function(e) {
                        var t = this,
                            r = 0;
                        return this[Symbol.iterator]().find((function(i) {
                            return e(i, r++, t)
                        }))
                    }, e.prototype.findLast = function(e) {
                        var t = this,
                            r = this.length - 1;
                        return this.getReverseIterator().find((function(i) {
                            return e(i, r--, t)
                        }))
                    }, e
                }();
                t.HSLinkedList = r;
                var i = function(e) {
                    void 0 === e && (e = null), this.value = e, this.next = this, this.previous = this
                };
                t.HSLinkedListNode = i;
                var s = function() {
                    function e(e, t) {
                        void 0 === t && (t = !1), this.headNode = e, this.isReversed = t, this.currentNode = e
                    }
                    return e.prototype.next = function() {
                        var e = this.isReversed ? this.currentNode.previous : this.currentNode.next;
                        return e !== this.headNode ? (this.currentNode = e, {
                            value: this.currentNode.value,
                            done: !1
                        }) : {
                            value: void 0,
                            done: !0
                        }
                    }, e.prototype.forEach = function(e) {
                        for (var t = this.next(); !t.done;) e(t.value), t = this.next()
                    }, e.prototype.find = function(e) {
                        for (var t = this.next(); !t.done;) {
                            if (e(t.value)) return t.value;
                            t = this.next()
                        }
                    }, e.prototype[Symbol.iterator] = function() {
                        return this
                    }, e
                }();
                t.HSLinkedListIterator = s, window.HSLinkedList = r
            },
            4958: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSPathDrawer = t.HSLinePoint = void 0;
                var i = r(9005),
                    s = t.HSLinePoint = function() {
                        function e(t, r, s) {
                            this.point = t, this.radius = r, this.lineReference = s, this.point.x = (0, i.clamp)(t.x, -e.MAX_POINT_VALUE, e.MAX_POINT_VALUE), this.point.y = (0, i.clamp)(t.y, -e.MAX_POINT_VALUE, e.MAX_POINT_VALUE);
                            var n = Math.ceil(2 * r) / 2;
                            this.radius = n < 0 ? .5 : (0, i.clamp)(n, 0, e.MAX_POINT_VALUE)
                        }
                        return e.prototype.clone = function() {
                            return new e(this.point, this.radius, this.lineReference)
                        }, e.MAX_POINT_VALUE = 1e4, e
                    }(),
                    n = function() {
                        function e(e) {
                            this.currentPoint = e, this.shouldDraw = !1
                        }
                        return e.prototype.drawDiff = function(e) {
                            this.shouldDrawPath() && (this.currentPoint.radius && e.drawLine(this.previousPointWithRadiusAndColor(), this.currentPoint), this.shouldDraw = !1)
                        }, e.prototype.shouldDrawPath = function() {
                            return this.shouldDraw && this.currentPoint && this.previousPoint
                        }, e.prototype.previousPointWithRadiusAndColor = function() {
                            var e = this.previousPoint.clone();
                            return e.lineReference = this.currentPoint.lineReference, e.radius = this.currentPoint.radius, e
                        }, e.prototype.addPoint = function(e, t) {
                            t ? (this.shouldDraw = !0, this.previousPoint = this.currentPoint, this.currentPoint = e) : (this.currentPoint = e, this.shouldDraw = !1)
                        }, e
                    }();
                t.HSPathDrawer = n, window.HSLinePoint = s, window.HSPathDrawer = n
            },
            7554: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSRuleActivator = void 0;
                var i = r(1754),
                    s = r(445),
                    n = function() {
                        function e(e) {
                            this.scene = e, this.currentCollisions = new i.HSCollisionPairCollection([]), this._stageRuleGroupCache = new Set, this._stageRulesCache = null, this._objectsToDestroy = []
                        }
                        return e.prototype.stageObjects = function() {
                            return this.scene.stageObjects
                        }, e.prototype.stageRuleGroups = function() {
                            return this.stageObjects().flatMap((function(e) {
                                return e.ruleGroups
                            }))
                        }, e.prototype.addToDestroyQueue = function(e) {
                            this._objectsToDestroy.push(e)
                        }, e.prototype.cleanDestroyQueue = function() {
                            for (var e; e = this._objectsToDestroy.pop();) this.destroy(e)
                        }, e.prototype.destroy = function(e) {
                            var t = this;
                            this._removeRulesForObject(e), e.ruleGroups.forEach((function(e) {
                                return t._stageRuleGroupCache.delete(e)
                            })), this._collisionPairs = null, this.scene.destroy(e)
                        }, e.prototype._removeRulesForObject = function(e) {
                            var t = this.stageRulesCache();
                            for (var r in t) 0 !== t[r].length && (t[r] = t[r].filter((function(t) {
                                return !t.isCurrentObject(e)
                            })))
                        }, e.prototype.activateAllRulesForEventType = function(e) {
                            this.stageRuleGroups().forEach((function(t) {
                                return t.activateAllStageRulesForEventType(e)
                            }))
                        }, e.prototype.allPossibleCollisionPairs = function() {
                            var e = this;
                            return this._collisionPairs || (this._collisionPairs = new i.HSCollisionPairCollection, this.stageObjects().forEach((function(t) {
                                return e.addCollisionPairsForStageObject(t)
                            }))), this._collisionPairs
                        }, e.prototype.addCollisionPairsForStageObject = function(e) {
                            if (this._collisionPairs) {
                                var t = Array.from(e.relatedCollisionRules).map((function(e) {
                                    return e.collisionPairs()
                                })).reduce((function(e, t) {
                                    return e.concat(t)
                                }), []).filter((function(e) {
                                    var t = e.stageObject1,
                                        r = e.stageObject2;
                                    return t && t.isAlive && r && r.isAlive
                                }));
                                this._collisionPairs.add(t), this._collisionPairs.add(e.allPossibleCollisionPairs())
                            }
                        }, e.prototype.allStageRulesForEventType = function(e) {
                            var t = this,
                                r = this.stageRulesCache();
                            return this.stageRuleGroups().filter((function(e) {
                                return !t._stageRuleGroupCache.has(e)
                            })).forEach((function(e) {
                                t.cacheRulesForStageObject(e)
                            })), r[e]
                        }, e.prototype.stageRulesCache = function() {
                            if (this._stageRulesCache) return this._stageRulesCache;
                            this._stageRulesCache = {};
                            for (var e = Object.keys(s.HSBlockType).filter((function(e) {
                                    return "string" == typeof e
                                })), t = 0; t < e.length; t++) this._stageRulesCache[e[t]] = [];
                            return this._stageRulesCache
                        }, e.prototype.cacheRulesForStageObject = function(e) {
                            var t = this.stageRulesCache(),
                                r = e.allRulesIncludingNested();
                            this._stageRuleGroupCache.add(e), r.forEach((function(e) {
                                return t[e.eventType()].push(e)
                            }))
                        }, e.prototype.activateCurrentCollisionRules = function() {
                            var e = this;
                            this.allTouchingRules().forEach((function(t) {
                                t.collisionPairs().find((function(t) {
                                    return e.currentCollisions.contains(t)
                                })) && t.activate()
                            })), this.allNotTouchingRules().forEach((function(t) {
                                t.collisionPairs().find((function(t) {
                                    return e.currentCollisions.contains(t)
                                })) || t.activate()
                            })), this.allBumpRules().forEach((function(t) {
                                e.bumpingCollisions.intersects(t.collisionPairs()) && t.activate()
                            }))
                        }, e.prototype.allNotTouchingRules = function() {
                            return this.allStageRulesForEventType(s.HSBlockType.EventOperatorIsNotTouching)
                        }, e.prototype.allTouchingRules = function() {
                            return this.allStageRulesForEventType(s.HSBlockType.EventOperatorIsTouching)
                        }, e.prototype.allBumpRules = function() {
                            return this.allStageRulesForEventType(s.HSBlockType.EventOperatorBump)
                        }, e.prototype.executeAllActiveRules = function() {
                            for (var e = this.stageRuleGroups(), t = e.length, r = 0; r < t; ++r) {
								if (void 0 !== e[r]) {
									e[r].executeActiveRules()
								}
							}
                        }, e.prototype.activateAllRulesForEventWithObjects = function(e, t) {
                            var r = this.allStageRulesForEventType(e);
                            t.forEach((function(e) {
                                r.forEach((function(t) {
                                    t.activateIfMatchesFirstObject(e)
                                }))
                            }))
                        }, e
                    }();
                t.HSRuleActivator = n, window.HSRuleActivator = n
            },
            5291: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSStageControl = void 0;
                var i = r(655),
                    s = r(4450),
                    n = r(3724),
                    o = r(781),
                    a = r(4925),
                    h = r(445),
                    l = r(4108),
                    u = r(5218),
                    c = function(e) {
                        function t(t, r, i) {
                            void 0 === r && (r = []);
                            var s = e.call(this, i) || this;
                            return s.type = t, s.parameters = r, s.isImmediate = !1, s.isControl = !0, s
                        }
                        return i.__extends(t, e), t.prototype.scopeMode = function() {
                            switch (this.type) {
                                case h.HSBlockType.Ability:
                                    return u.ScopeMode.Root;
                                case h.HSBlockType.Repeat:
                                case h.HSBlockType.RepeatForever:
                                case h.HSBlockType.CheckOnceIf:
                                case h.HSBlockType.CheckIfElse:
                                case h.HSBlockType.LeaveATrail:
                                    return u.ScopeMode.Own;
                                default:
                                    return u.ScopeMode.Parent
                            }
                        }, t.prototype.integerValue = function(e) {
                            switch (this.type) {
                                case h.HSBlockType.Repeat:
                                    return Math.round(this.firstIntegerValue(e));
                                case h.HSBlockType.RepeatForever:
                                    return 1 / 0;
                                default:
                                    return 0
                            }
                        }, t.prototype.script = function(e) {
                            switch (this.type) {
                                case h.HSBlockType.CheckOnceIf:
                                case h.HSBlockType.CheckIfElse:
                                    return this.parameters[0].computedBooleanValue(e) ? this.trueScript() : this.falseScript();
                                default:
                                    return this.trueScript()
                            }
                        }, t.prototype.trueScript = function() {
                            return this.scripts[0]
                        }, t.prototype.falseScript = function() {
                            return this.scripts[1]
                        }, t.prototype.toString = function() {
                            return n.SourceFormatter.stageControlToSrc(this)
                        }, t.prototype.firstIntegerValue = function(e) {
                            var t;
                            return (null === (t = this.parameters[0]) || void 0 === t ? void 0 : t.computedNumberValue(e)) || 0
                        }, t.prototype.executableForStepSize = function(e, t) {
                            switch (this.type) {
                                case h.HSBlockType.Repeat:
                                case h.HSBlockType.RepeatForever:
                                    return this.executableForRepeat(e, t);
                                case h.HSBlockType.LeaveATrail:
                                    return this.executableForLeaveATrail(e, t);
                                case h.HSBlockType.CheckOnceIf:
                                case h.HSBlockType.CheckIfElse:
                                    return this.scripts[0].isImmediatelyRecursive() ? new s.HSExecutable([], []) : this.script(t).executableForStepSize(e, t);
                                case h.HSBlockType.Ability:
                                    if (this.scripts[0].isImmediatelyRecursive()) return new s.HSExecutable([], []);
                                    var r = this.script(t);
                                    return this.parameters.forEach((function(e) {
                                        var i;
                                        return null === (i = r.environment()) || void 0 === i ? void 0 : i.set(e.key, e.computedStringValue(t))
                                    })), r.executableForStepSize(e, t)
                            }
                        }, t.prototype.executableForRepeat = function(e, t) {
                            switch (this.integerValue(t)) {
                                case 0:
                                    return new s.HSExecutable([], []);
                                case 1:
                                    return this.script(t).executableForStepSize(e, t);
                                default:
                                    return this.executableWithRepeatOnTheEnd(e, t)
                            }
                        }, t.prototype.executableForLeaveATrail = function(e, t) {
                            var r = this.script(t).executableForStepSize(e, t),
                                i = [new o.HSStageMethod(h.HSBlockType.PenDown, [], this)];
                            this.parameters[0] && i.push(new o.HSStageMethod(h.HSBlockType.SetTrailColor, [this.parameters[0]], this)), this.parameters[1] && i.push(new o.HSStageMethod(h.HSBlockType.SetTrailWidth, [this.parameters[1]], this));
                            var n = new o.HSStageMethod(h.HSBlockType.PenUp, [], this);
                            return new s.HSExecutable(i.concat(r.blocksToExecuteNow), r.blocksToExecuteLater.concat(n))
                        }, t.prototype.executableWithRepeatOnTheEnd = function(e, r) {
                            var i = this.script(r).executableForStepSize(e, r),
                                s = this.integerValue(r) - 1,
                                n = new a.HSStageParameter("" + s, this.parentNode()),
                                o = new t(this.type, [n], this.parentNode());
                            this.scripts.forEach((function(e) {
                                return e.updateParentNode(o)
                            })), o.scripts = this.scripts;
                            var h = i.blocksToExecuteLater;
                            return h.push(o), i.newWithNewBlocksToExecuteLater(h)
                        }, t
                    }(l.HSStageObjectBase);
                t.HSStageControl = c, window.HSStageControl = c
            },
            3339: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSStageCustomRule = void 0;
                var i = r(655),
                    s = r(5218),
                    n = function(e) {
                        function t(t, r) {
                            var i = e.call(this, t) || this;
                            return i.name = r, i.ruleGroups = [], i.parameters = [], i
                        }
                        return i.__extends(t, e), t.prototype.scopeMode = function() {
                            return s.ScopeMode.DynamicRoot
                        }, t.prototype.baseRuleGroup = function() {
                            return this.ruleGroups[0]
                        }, t.prototype.script = function() {
                            var e;
                            return null === (e = this.ruleGroups[0]) || void 0 === e ? void 0 : e.script()
                        }, t.prototype.rules = function() {
                            return this.ruleGroups.flatMap((function(e) {
                                return e.rules()
                            }))
                        }, t.prototype.deepCopy = function(e) {
                            var r = this,
                                i = new t(e, this.name);
                            return i.ruleGroups = this.ruleGroups.map((function(t) {
                                return t.deepCopy(r, e.parentObject)
                            })), i
                        }, t
                    }(r(4108).HSStageObjectBase);
                t.HSStageCustomRule = n
            },
            1209: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSStageLocalVariable = void 0;
                var i = r(655),
                    s = r(445),
                    n = r(2983),
                    o = function(e) {
                        function t(t, r) {
                            var i = e.call(this, s.HSBlockType.Scoped, s.HSBlockType.Variable, null, null, null, r) || this;
                            return i.name = t, i
                        }
                        return i.__extends(t, e), t.prototype.setValue = function(e) {
                            this.environment().set(this.name, e)
                        }, t.prototype.computedValue = function() {
                            return this.environment().get(this.name) || 0
                        }, t.prototype.computedNumberValue = function() {
                            return n.HSStageVariable.parseNumberFrom(this.computedValue())
                        }, t
                    }(r(1972).HSStageParameterBlock);
                t.HSStageLocalVariable = o
            },
            781: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSStageMethod = void 0;
                var i = r(655),
                    s = r(3452),
                    n = r(4450),
                    o = r(3724),
                    a = r(4925),
                    h = r(445),
                    l = r(1925),
                    u = r(9005),
                    c = function(e) {
                        function t(t, r, i) {
                            void 0 === r && (r = []);
                            var s = e.call(this, i) || this;
                            return s.type = t, s.parameters = r, s.isControl = !1, s.id = "", s.isImmediate = [h.HSBlockType.PenDown, h.HSBlockType.SetTrailColor, h.HSBlockType.SetTrailWidth, h.HSBlockType.SetTrailCap, h.HSBlockType.PenUp, h.HSBlockType.SetVariable, h.HSBlockType.ChangeVariable, h.HSBlockType.Comment].includes(t), s
                        }
                        return i.__extends(t, e), t.prototype.isOverStepSize = function(e, t) {
                            return this.usesStepSize() && Math.abs(this.firstIntegerValue(t)) > e
                        }, t.prototype.isWaitBlock = function() {
                            return this.type === h.HSBlockType.Wait || this.type === h.HSBlockType.WaitSeconds
                        }, t.prototype.isFinishedTimestampBlock = function(e) {
                            return this.type === h.HSBlockType.WaitTilTimestamp && this.firstIntegerValue(e) <= Date.now()
                        }, t.prototype.isUnfinishedTimestampBlock = function(e) {
                            return this.type === h.HSBlockType.WaitTilTimestamp && this.firstIntegerValue(e) > Date.now()
                        }, t.prototype.usesStepSize = function() {
                            return -1 !== [h.HSBlockType.ChangeX, h.HSBlockType.ChangeY, h.HSBlockType.Move, h.HSBlockType.Rotate].indexOf(this.type)
                        }, t.prototype.firstIntegerValue = function(e) {
                            var t;
                            return (null === (t = this.parameters[0]) || void 0 === t ? void 0 : t.computedNumberValue(e)) || 0
                        }, t.prototype.calculateValueMinusOneStep = function(e, t) {
                            return this.isOverStepSize(e, t) ? this.signOfFirstValue(t) * (Math.abs(this.firstIntegerValue(t)) - Math.abs(e)) : 0
                        }, t.prototype.executableForStepSize = function(e, t, r) {
                            return this.isWaitBlock() ? this.waitTilMillisecondsForWait(t).executableForStepSize(e, t, r) : this.type == h.HSBlockType.PlayNote ? this.playNoteAndReturnWaitTime(e, t, r) : new n.HSExecutable(this.blocksToExecuteNow(e, t), this.blocksToExecuteLater(e, t))
                        }, t.prototype.playNoteAndReturnWaitTime = function(e, r, i) {
                            var n = r.parentObject,
                                o = s.HSSoundManager.sharedInstance,
                                l = this.parameters[0].computedStringValue(r);
                            return o.playNote(l, n.instrument), new t(h.HSBlockType.Wait, [new a.HSStageParameter(this.parameters[1].computedRhythmValue(r) + "", this.parentNode())], this.parentNode()).waitTilMillisecondsForWait(r).executableForStepSize(e, r, i)
                        }, t.prototype.waitTilMillisecondsForWait = function(e) {
                            var r = this.getWaitMilliseconds(e),
                                i = Date.now() + r;
                            return new t(h.HSBlockType.WaitTilTimestamp, [new a.HSStageParameter(i + "", this.parentNode())], this.parentNode())
                        }, t.prototype.getWaitMilliseconds = function(e) {
                            if (!this.isWaitBlock()) return 0;
                            var t = this.firstIntegerValue(e);
                            return this.type === h.HSBlockType.WaitSeconds ? 1e3 * t : t
                        }, t.prototype.blocksToExecuteNow = function(e, r) {
                            if (this.type === h.HSBlockType.WaitTilTimestamp) return [];
                            if (!this.isOverStepSize(e, r)) return [this];
                            var i = new a.HSStageParameter("" + e * this.signOfFirstValue(r), this.parentNode());
                            return [new t(this.type, [i], this.parentNode())]
                        }, t.prototype.toString = function() {
                            return o.SourceFormatter.stageMethodToSrc(this)
                        }, t.prototype.signOfFirstValue = function(e) {
                            var t = this.firstIntegerValue(e);
                            return t / Math.abs(t)
                        }, t.prototype.isPromptDone = function() {
                            var e, t = (null === (e = this.parameters[0]) || void 0 === e ? void 0 : e.value) || "-1",
                                r = l.HSStageScene.promptsToExecute.find((function(e) {
                                    return e.id === t
                                }));
                            return null == r ? void 0 : r.isDone
                        }, t.prototype.blocksToExecuteLater = function(e, r) {
                            switch (this.type) {
                                case h.HSBlockType.WaitTilTimestamp:
                                    return this.firstIntegerValue(r) > Date.now() ? [this] : [];
                                case h.HSBlockType.ChangeX:
                                case h.HSBlockType.Ability:
                                case h.HSBlockType.ChangeY:
                                case h.HSBlockType.AnyObject:
                                case h.HSBlockType.Move:
                                case h.HSBlockType.Rotate:
                                    var i = this.calculateValueMinusOneStep(e, r),
                                        s = new a.HSStageParameter("" + i, this.parentNode());
                                    return [new t(this.type, [s], this.parentNode())];
                                case h.HSBlockType.WaitUntilInputIsDone:
                                    return this.isPromptDone() ? [] : [this];
                                case h.HSBlockType.SaveInput:
                                case h.HSBlockType.SetTextToInput:
                                case h.HSBlockType.ShowPopup:
                                    return "" === this.id && (this.id = (0, u.generateUUID)()), [new t(h.HSBlockType.WaitUntilInputIsDone, [new a.HSStageParameter(this.id, this.parentNode())], this.parentNode())];
                                case h.HSBlockType.PlaySound:
                                    return [new t(h.HSBlockType.Wait, [new a.HSStageParameter(this.parameters[1].computedValue(r) + "", this.parentNode())], this.parentNode())];
                                case h.HSBlockType.PlayNote:
                                    return [new t(h.HSBlockType.Wait, [new a.HSStageParameter(this.parameters[1].computedRhythmValue(r) + "", this.parentNode())], this.parentNode())];
                                case h.HSBlockType.PlaySoundSeconds:
                                    return [new t(h.HSBlockType.WaitSeconds, [new a.HSStageParameter(this.parameters[1].computedValue(r) + "", this.parentNode())], this.parentNode())];
                                default:
                                    return []
                            }
                        }, t
                    }(r(4108).HSStageObjectBase);
                t.HSStageMethod = c, window.HSStageMethod = c
            },
            682: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSStageObject = t.DEFAULT_INSTRUMENT = t.DEFAULT_TEMPO = t.DEBUG_DRAW_BOUNDING_BOXES = t.EDGE_OF_SCREEN_OBJECT_ID = t.BASE_STEP_SIZE = t.BASE_SPEED = void 0;
                var i = r(655),
                    s = r(4958),
                    n = r(6595),
                    o = r(1925),
                    a = r(9134),
                    h = r(6745),
                    l = r(1288),
                    u = r(6317),
                    c = r(8232),
                    d = r(3193),
                    p = r(8362),
                    f = r(66),
                    m = r(5218),
                    g = r(4108);
                t.BASE_SPEED = 400, t.BASE_STEP_SIZE = 10, t.EDGE_OF_SCREEN_OBJECT_ID = "zzzEdge", t.DEBUG_DRAW_BOUNDING_BOXES = !1, t.DEFAULT_TEMPO = 120, t.DEFAULT_INSTRUMENT = "piano";
                var y = t.HSStageObject = function(e) {
                    function r(i, n, o, l, d, p, f, m, g, y, _, v, S) {
                        void 0 === _ && (_ = 1), void 0 === v && (v = 1), void 0 === S && (S = 0);
                        var T = e.call(this, null) || this;
                        return T.x = i, T.y = n, T.text = o, T.name = l, T.type = d, T.baseObjectScale = p, T.fontSize = f, T.objectID = m, T.imageName = g, T.willChangeCostume = y, T.originalWidth = _, T.originalHeight = v, T.headingInDegrees = S, T.createOrder = -1, T._animationNumber = 0, T.sizePercentWidth = 100, T.sizePercentHeight = 100, T.speed = t.BASE_SPEED, T.tempo = t.DEFAULT_TEMPO, T.instrument = t.DEFAULT_INSTRUMENT, T.invisibilityPercent = 0, T.isFlipped = !1, T.drawingRadius = null, T.drawingColor = null, T.drawingCap = "round", T.drawingOpacityPercent = 100, T.penDown = !1, T.shouldClear = !1, T.shouldSetBackground = !1, T.creationTick = null, T.relatedCollisionRules = new Set, T.collisionImageFactory = new u.HSCollisionImageFactory, T.cloneIndex = 0, T.zIndex = 0, T.isAlive = !0, T.variables = [], T.ruleGroups = [], T.resetTextSize = function() {
                            var e, t = h.HSTextNode.fromString(T.text),
                                r = T.view.canvas;
                            if (r) {
                                if (t) {
                                    var i = (e = t.flow(r.getContext("2d"), h.HSTextNode.MAX_LINE_WIDTH)).width,
                                        s = e.height;
                                    T.originalWidth = i, T.originalHeight = s, T.collisionObject = null
                                }
                            } else T.view.onTextureBuild = T.resetTextSize
                        }, r.initEdges(), T.originalObject = T, T.createOrder = ++r.OBJECTS_CREATED, T.color = T.colorForType(d), T.stageObjectID = r.uniqueIdCounter++, T.type === c.HSObjectType.text ? T.text = o : T.text = null, T.pathDrawer = new s.HSPathDrawer(T.currentPoint()), T.view = new a.HSView(T.viewProps()), T
                    }
                    return i.__extends(r, e), r.prototype.mainRuleGroup = function() {
                        return this.ruleGroups[0]
                    }, r.prototype.scopeMode = function() {
                        return m.ScopeMode.DynamicRoot
                    }, r.prototype.allPossibleCollisionPairs = function() {
                        return this.ruleGroups.flatMap((function(e) {
                            return e.allPossibleCollisionPairs()
                        }))
                    }, r.initEdges = function() {
                        r.initiatedEdgeOfScreen || (r.initiatedEdgeOfScreen = !0, r.edgeOfScreenObject = new r(0, 0, "", "", c.HSObjectType.edgeOfScreen, 1, 80, t.EDGE_OF_SCREEN_OBJECT_ID, null, !1))
                    }, r.prototype.executeScripts = function() {
                        this.ruleGroups.forEach((function(e) {
                            return e.executeScript()
                        })), this.ruleGroups.forEach((function(e) {
                            return e.populateEnvironment()
                        }))
                    }, r.prototype.setWidth = function(e) {
                        0 === e && (e = .01), e && (this.sizePercentWidth = e / this.originalWidth * (1 / this.baseScale()) * 100)
                    }, r.prototype.setHeight = function(e) {
                        0 === e && (e = .01), e && (this.sizePercentHeight = e / this.originalHeight * (1 / this.baseScale()) * 100)
                    }, r.prototype.width = function() {
                        return this.view.textureExists ? this.view.width() : Math.round(this.originalWidth * this.baseScale())
                    }, r.prototype.height = function() {
                        return this.view.textureExists ? this.view.height() : Math.round(this.originalHeight * this.baseScale())
                    }, r.prototype.colorForType = function(e) {
                        return this.type === c.HSObjectType.text || this.isShape() ? p.HSColor.rgbTextColor : p.HSColor.rgbWhiteColor
                    }, r.prototype.baseScale = function() {
                        return this.isFullSizeShape() ? .5 : 1
                    }, r.prototype.isFullSizeShape = function() {
                        return (0, c.hsIsFullSizeShape)(this.type)
                    }, r.prototype.isShape = function() {
                        return (0, c.hsIsShapeType)(this.type)
                    }, r.prototype.update = function() {
                        this.isAlive && this.view.update(this.viewProps())
                    }, r.prototype.viewProps = function() {
                        return {
                            type: this.type,
                            text: this.text,
                            color: this.color,
                            x: this.x,
                            y: this.y,
                            headingInRadians: this.headingInRadians(),
                            sizePercentWidth: this.sizePercentWidth,
                            sizePercentHeight: this.sizePercentHeight,
                            fontSize: this.fontSize,
                            opacity: this.opacity(),
                            isFlipped: this.isFlipped,
                            animationNumber: this.animationNumber(),
                            willChangeCostume: this.willChangeCostume,
                            imageName: this.imageName,
                            baseObjectScale: this.baseScale(),
                            stageHeight: o.HSStageScene.stageHeight,
                            originalHeight: this.originalHeight,
                            originalWidth: this.originalWidth
                        }
                    }, r.prototype.imageForCollision = function() {
                        return this.collisionImageFactory.image(this.view.imageSource())
                    }, r.prototype.boundingBox = function() {
                        this._boundingBox || (this._boundingBox = new l.HSBoundingBox);
                        var e = this.view.bounds();
                        return this._boundingBox.update(this.x, this.y, e.width / 2, e.height / 2), this._boundingBox
                    }, r.prototype.drawPath = function(e) {
                        this.pathDrawer.drawDiff(e)
                    }, r.prototype.isBlankTextObject = function() {
                        return this.type === c.HSObjectType.text && !this.shouldDrawText()
                    }, r.prototype.shouldDrawText = function() {
                        return n.HSTokenizer.hasDrawableTokens(this.text)
                    }, r.prototype.canDrawCharacter = function() {
                        return this.type !== c.HSObjectType.text
                    }, r.prototype.canDrawImage = function() {
                        return !!this.imageName
                    }, r.prototype.opacity = function() {
                        return .01 * Math.max(100 - this.invisibilityPercent, 0)
                    }, r.prototype.clear = function() {
                        this.shouldClear = !0
                    }, r.prototype.setBackground = function(e) {
                        this.backgroundColor = e, this.shouldSetBackground = !0
                    }, r.prototype.maxStepSize = function() {
                        var e = this.speed / t.BASE_SPEED * t.BASE_STEP_SIZE;
                        return Math.abs(e) >= 1 ? e : Math.sign(e)
                    }, r.prototype.headingInRadians = function() {
                        return this.headingInDegrees * Math.PI / 180
                    }, r.prototype.changeXBy = function(e) {
                        this.x += e, this.moveToWithinBoundary(), this.pathDrawer.addPoint(this.currentPoint(), this.penDown)
                    }, r.prototype.changeYBy = function(e) {
                        this.y += e, this.moveToWithinBoundary(), this.pathDrawer.addPoint(this.currentPoint(), this.penDown)
                    }, r.prototype.setPosition = function(e, t) {
                        this.x = e, this.y = t, this.pathDrawer.addPoint(this.currentPoint(), this.penDown)
                    }, r.prototype.setOrigin = function(e, t) {
                        this.setPosition(e + .5 * this.width(), t + .5 * this.height())
                    }, r.prototype.rotateBy = function(e) {
                        this.headingInDegrees = r.normalizeHeading(this.headingInDegrees + e * this.multiplier())
                    }, r.prototype.moveBy = function(e) {
                        this.x += this.multiplier() * Math.cos(this.headingInRadians()) * e, this.y += this.multiplier() * Math.sin(this.headingInRadians()) * e, this.moveToWithinBoundary(), this.pathDrawer.addPoint(this.currentPoint(), this.penDown)
                    }, r.prototype.setText = function(e, t) {
                        this.text = e, this.color = t, this.type = c.HSObjectType.text, this.resetTextSize()
                    }, r.prototype.setCharacter = function(e) {
                        this.type = e, this.color = this.colorForType(e), this._animationNumber = 0, this.text = null, this.imageName = null, d.HSOBJECT_SIZES[e] && (this.originalWidth = d.HSOBJECT_SIZES[e].width, this.originalHeight = d.HSOBJECT_SIZES[e].height)
                    }, r.prototype.setImage = function(e) {
                        this.type = c.HSObjectType.image, this.color = this.colorForType(c.HSObjectType.image), this._animationNumber = 0, this.text = null, e && (this.imageName = e.fileName, this.originalWidth = e.width, this.originalHeight = e.height)
                    }, r.prototype.changePose = function() {
                        this.isShape() || this._animationNumber++
                    }, r.prototype.animationNumber = function() {
                        return this._animationNumber % 4
                    }, r.prototype.bringToFront = function() {
                        this.bringToFrontFunction(this)
                    }, r.prototype.sendToBack = function() {
                        this.sendToBackFunction(this)
                    }, r.prototype.clone = function(e) {
                        this.cloneFunction(this, e)
                    }, r.prototype.addToDestroyQueue = function() {
                        this.isAlive = !1, this.destroyFunction(this)
                    }, r.prototype.queueEventMessage = function(e) {
                        this.broadcastMessageFunction(e)
                    }, r.prototype.destroy = function() {
                        this.view = null, this.ruleGroups = []
                    }, r.prototype.isInvisible = function() {
                        return this.invisibilityPercent >= 100
                    }, r.prototype.deepCopy = function() {
                        var e = this,
                            t = new r(this.x, this.y, this.text, this.name, this.type, this.baseObjectScale, this.fontSize, this.objectID, this.imageName, this.willChangeCostume, this.originalWidth, this.originalHeight);
                        return t.color = this.color, t.originalObject = this.originalObject, t.sizePercentHeight = this.sizePercentHeight, t.sizePercentWidth = this.sizePercentWidth, t.isFlipped = this.isFlipped, t.headingInDegrees = this.headingInDegrees, t.speed = this.speed, t.invisibilityPercent = this.invisibilityPercent, t._animationNumber = this._animationNumber, t.tempo = this.tempo, t.instrument = this.instrument, t.zIndex = this.zIndex, t.ruleGroups = this.ruleGroups.map((function(e) {
                            return e.deepCopy(t, t)
                        })), t.variables = this.variables, this.variables.forEach((function(r) {
                            var i = r.computedStringValue(e.mainRuleGroup());
                            r.setValue(i, t.mainRuleGroup())
                        })), t
                    }, r.prototype.break = function() {
                        this.ruleGroups.forEach((function(e) {
                            return e.break()
                        }))
                    }, r.normalizeHeading = function(e) {
                        return (e % 360 + 360) % 360
                    }, r.prototype.currentPoint = function() {
                        return new s.HSLinePoint(new f.Vec2(this.x, this.y), this.drawingRadius, {
                            lineColor: this.drawingColor,
                            lineCap: this.drawingCap,
                            lineAlpha: this.drawingOpacityPercent / 100
                        })
                    }, r.prototype.moveToWithinBoundary = function() {
                        this.x = Math.min(this.x, o.HSStageScene.stageWidth), this.x = Math.max(this.x, 0), this.y = Math.min(this.y, o.HSStageScene.stageHeight), this.y = Math.max(this.y, 0)
                    }, r.prototype.multiplier = function() {
                        return this.isFlipped ? -1 : 1
                    }, Object.defineProperty(r.prototype, "originX", {
                        get: function() {
                            return this.x - .5 * this.width()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), Object.defineProperty(r.prototype, "originY", {
                        get: function() {
                            return this.y - .5 * this.height()
                        },
                        enumerable: !1,
                        configurable: !0
                    }), r.OBJECTS_CREATED = 0, r.uniqueIdCounter = 0, r.initiatedEdgeOfScreen = !1, r
                }(g.HSStageObjectBase);
                window.HSStageObject = y, window.BASE_SPEED = t.BASE_SPEED, window.BASE_STEP_SIZE = t.BASE_STEP_SIZE, window.EDGE_OF_SCREEN_OBJECT_ID = t.EDGE_OF_SCREEN_OBJECT_ID, window.DEBUG_DRAW_BOUNDING_BOXES = t.DEBUG_DRAW_BOUNDING_BOXES, window.DEFAULT_TEMPO = t.DEFAULT_TEMPO, window.DEFAULT_INSTRUMENT = t.DEFAULT_INSTRUMENT
            },
            4108: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSStageObjectBase = void 0;
                var i = r(5218);
                t.HSStageObjectBase = function() {
                    function e(e) {
                        this._parentNode = e, this.description = this.constructor.name
                    }
                    return e.prototype.parentNode = function() {
                        return this._parentNode
                    }, e.prototype.scopeMode = function() {
                        return i.ScopeMode.Parent
                    }, e.prototype.updateParentNode = function(e) {
                        this._parentNode = e
                    }, e.prototype.isDynamicRoot = function() {
                        if (void 0 === this._dynamicRoot) switch (this.scopeMode()) {
                            case i.ScopeMode.Parent:
                            case i.ScopeMode.Own:
                                this._dynamicRoot = !!this.parentNode() && this.parentNode().isDynamicRoot();
                                break;
                            case i.ScopeMode.Root:
                                this._dynamicRoot = !1;
                                break;
                            case i.ScopeMode.DynamicRoot:
                                this._dynamicRoot = !0
                        }
                        return this._dynamicRoot
                    }, e.prototype.expectedCurrentObject = function() {
                        switch (this.scopeMode()) {
                            case i.ScopeMode.Parent:
                            case i.ScopeMode.Own:
                                return this.parentNode();
                            case i.ScopeMode.Root:
                            case i.ScopeMode.DynamicRoot:
                                return this
                        }
                    }, e.prototype.environment = function() {
                        return this.expectedCurrentObject(), this._environment || (this._environment = i.HSEnvironment.environmentForNode(this)), this._environment
                    }, e.key = "HSStageObjectBase", e
                }()
            },
            4925: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSStageParameter = void 0;
                var i = r(655),
                    s = r(2983),
                    n = r(3724),
                    o = r(8232),
                    a = r(445),
                    h = r(8362),
                    l = r(4108),
                    u = r(7779),
                    c = function(e) {
                        function t(t, r, i, s) {
                            void 0 === i && (i = null);
                            var n = e.call(this, r) || this;
                            return n.value = t, n.childBlock = i, n.key = s, n
                        }
                        return i.__extends(t, e), t.prototype.variable = function() {
                            return this.childBlock && this.childBlock.type === a.HSBlockType.Variable ? this.childBlock : null
                        }, t.prototype.localVariable = function() {
                            return this.childBlock && this.childBlock.type == a.HSBlockType.Scoped ? this.childBlock : null
                        }, t.prototype.computedStringValue = function(e) {
                            return this.childBlock ? this.childBlock.computedStringValue(e) : this.value
                        }, t.prototype.computedRoundedStringValue = function(e) {
                            return this.childBlock ? this.childBlock.computedRoundedStringValue(e) : s.HSStageVariable.parseValue(this.value, !1).toString()
                        }, t.prototype.computedObjectType = function() {
                            return this.childBlock ? o.HSObjectType.image : "string" == typeof this.value ? o.HSObjectType.text : this.value
                        }, t.prototype.isSet = function(e) {
                            return null !== this.value || null != this.childBlockValue(e)
                        }, t.prototype.computedBooleanValue = function(e) {
                            var t = this.computedValue(e);
                            return "0" !== t && !!t
                        }, t.prototype.computedRhythmValue = function(e) {
                            var t, r = e.parentObject,
                                i = 60 / (r.tempo ? +r.tempo : 120) * 1e3 * 4;
                            return null !== (t = +this.computedNumberValue(e) * i) && void 0 !== t ? t : 0
                        }, t.prototype.computedValue = function(e) {
                            var t = this.childBlockValue(e);
                            return null != t ? t : s.HSStageVariable.parseValue(this.value, !1)
                        }, t.prototype.computedNumberValue = function(e) {
                            return s.HSStageVariable.parseNumberFrom(this.computedValue(e))
                        }, t.prototype.computedColorString = function(e) {
                            return this.childBlock ? this.childBlock.computedColorString(e) : h.HSColor.rgbStringFromHSBString(this.computedStringValue(e))
                        }, t.prototype.computedLineCap = function(e) {
                            if (this.childBlock) return this.childBlock.computedLineCap(e);
                            var t = this.computedStringValue(e).toLowerCase();
                            return h.HSLineCap.lineCapFromString(t)
                        }, t.prototype.computedSceneValue = function(e) {
                            var t, r;
                            if (null == (t = this.childBlock ? this.childBlock.computedSceneValue(e) : this.computedStringValue(e))) return null;
                            if ((r = u.HSStageProject.sharedInstance.stageScenes.find((function(e) {
                                    return e.id === t
                                }))) || (r = u.HSStageProject.sharedInstance.stageScenes.find((function(e) {
                                    return e.name === t
                                }))), !r) {
                                var i = parseInt(t);
                                Number.isNaN(i) || (r = u.HSStageProject.sharedInstance.stageScenes[i])
                            }
                            return r || null
                        }, t.prototype.toString = function() {
                            return n.SourceFormatter.stageParamToSrc(this.value, this.childBlock)
                        }, t.prototype.childBlockValue = function(e) {
                            return this.childBlock ? this.childBlock.computedValue(e) : null
                        }, t
                    }(l.HSStageObjectBase);
                t.HSStageParameter = c, window.HSStageParameter = c
            },
            1972: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSStageParameterBlock = void 0;
                var i = r(655),
                    s = r(682),
                    n = r(2127),
                    o = r(445),
                    a = r(2983),
                    h = r(4108),
                    l = r(6642),
                    u = r(7779),
                    c = r(2388),
                    d = r(3209),
                    p = r(7925),
                    f = r(4882),
                    m = r(3112),
                    g = function(e) {
                        function t(t, r, i, s, n, o, a) {
                            void 0 === a && (a = null);
                            var h = e.call(this, o) || this;
                            return h.type = t, h.objectReferenceType = r, h.object = i, h.parameters = s, h.context = n, h.sceneID = a, h.mathCalculator = new c.HSMathCalculator, h.traitCalculator = new d.HSTraitCalculator, h.conditionalCalculator = new p.HSConditionalCalculator, h.linePropertiesParser = new f.LinePropertiesParser, h.textCalculator = new m.HSTextCalculator, h
                        }
                        return i.__extends(t, e), t.prototype.matchesStageObject = function(e, t) {
                            var r = this.stageObjects(t),
                                i = r[0];
                            if (!i && !e) return !0;
                            var s = this.childParameterBlocks() && this.childParameterBlocks().length > 0 && this.childParameterBlocks()[0].type === o.HSBlockType.AnyObject;
                            return this.context.version < n.HSProjectVersion.ADD_SELF && !s ? i && e && i.objectID === e.objectID : r.includes(e)
                        }, t.prototype.stageObjects = function(e) {
                            return this.type === o.HSBlockType.Self ? [e.parentObject] : this.usesOriginalObject() ? [e.parentObject.originalObject] : this.object ? this.object.allStageObjects() : this.type === o.HSBlockType.ScreenEdge ? [s.HSStageObject.edgeOfScreenObject] : this.type === o.HSBlockType.AnyObject ? u.HSStageProject.sharedInstance.activeStageScene.stageObjects : this.type >= o.HSBlockType.TraitRotation && this.type < o.HSBlockType.HS_END_OF_OBJECT_TRAITS ? [e.parentObject] : this.childParameterBlocks().reduce((function(t, r) {
                                return t.concat(r.stageObjects(e))
                            }), [])
                        }, t.prototype.childParameterBlocks = function() {
                            return this.parameters.filter((function(e) {
                                return null != e.childBlock
                            })).map((function(e) {
                                return e.childBlock
                            }))
                        }, t.prototype.parameterBlockStringValues = function(e) {
                            return this.parameters.map((function(t) {
                                return function(e, t) {
                                    var r, i = (null === (r = e.childBlock) || void 0 === r ? void 0 : r.computedValue(t)) || e.value || "";
                                    return a.HSStageVariable.parseValue(i, !0).toString()
                                }(t, e)
                            }))
                        }, t.prototype.matchesObject = function(e) {
                            return this.object ? this.object === e : !e
                        }, t.prototype.typeOfCalculation = function() {
                            if (this.type >= o.HSBlockType.ConditionalOperatorEquals && this.type < o.HSBlockType.HS_END_OF_CONDITIONAL_OPERATORS) return "conditional";
                            if (this.type > o.HSBlockType.HS_END_OF_CONDITIONAL_OPERATORS && this.type < o.HSBlockType.HS_END_OF_STAGE_TRAITS) return "trait";
                            if (this.type > o.HSBlockType.HS_END_OF_STAGE_TRAITS && this.type < o.HSBlockType.HS_END_OF_MATH_OPERATORS) return "math";
                            if (this.type > o.HSBlockType.HS_END_OF_MATH_OPERATORS && this.type < o.HSBlockType.HS_END_OF_COLOR_OPERATORS) return "color";
                            if (this.type > o.HSBlockType.HS_END_OF_EVENT_PARAMETER_BLOCKS && this.type < o.HSBlockType.HS_END_OF_TEXT_OPERATOR_BLOCKS) return "text";
                            switch (this.type) {
                                case o.HSBlockType.Random110:
                                case o.HSBlockType.Random1100:
                                case o.HSBlockType.Random11000:
                                case o.HSBlockType.Random:
                                    return "math";
                                default:
                                    return null
                            }
                        }, t.prototype.computedValue = function(e) {
                            var t;
                            switch (this.typeOfCalculation()) {
                                case "math":
                                    var r = [this.firstParamValue(e), this.secondParamValue(e)];
                                    return this.mathCalculator.computedValue(this.type, r);
                                case "trait":
                                    var i = this.stageObjects(e)[0],
                                        s = null !== (t = null == i ? void 0 : i.objectID) && void 0 !== t ? t : "",
                                        n = this.context.findWithObjectID(l.HSObject.key, s);
                                    return this.traitCalculator.computedValue(this.type, i, n);
                                case "conditional":
                                    return this.computedBooleanValue(e) ? 1 : 0;
                                case "color":
                                    return this.colorStringFromColorType(e);
                                case "text":
                                    var o = String(this.firstParamStringValue(e)),
                                        a = this.secondParamNumberValue(e),
                                        h = this.endIndexValue(e),
                                        u = String(this.secondParamStringValue(e));
                                    return this.textCalculator.computedValue(this.type, o, a, h, u);
                                default:
                                    return null
                            }
                        }, t.prototype.computedColorString = function(e) {
                            return "color" === this.typeOfCalculation() ? this.colorStringFromColorType(e) : this.linePropertiesParser.colorStringFromNumber(this.computedValue(e))
                        }, t.prototype.computedLineCap = function(e) {
                            var t = this.computedStringValue(e).toLowerCase();
                            return this.linePropertiesParser.lineCapFromString(t)
                        }, t.prototype.computedSceneValue = function(e) {
                            var t = u.HSStageProject.sharedInstance.stageScenes.indexOf(u.HSStageProject.sharedInstance.activeStageScene);
                            switch (this.type) {
                                case o.HSBlockType.SceneReferenceBlock:
                                    return this.sceneID;
                                case o.HSBlockType.PreviousSceneParameter:
                                    return t > 0 ? u.HSStageProject.sharedInstance.stageScenes[t - 1].id : null;
                                case o.HSBlockType.NextSceneParameter:
                                    return t < u.HSStageProject.sharedInstance.stageScenes.length - 1 ? u.HSStageProject.sharedInstance.stageScenes[t + 1].id : null;
                                default:
                                    return this.computedStringValue(e)
                            }
                        }, t.prototype.colorStringFromColorType = function(e) {
                            var t, r, i = null !== (r = null === (t = this.parameters) || void 0 === t ? void 0 : t.map((function(t) {
                                return t.computedValue(e)
                            }))) && void 0 !== r ? r : [];
                            return this.linePropertiesParser.computedColorString(this.type, i)
                        }, t.prototype.computedStringValue = function(e) {
                            var t = this.computedValue(e);
                            return null == t ? "0" : t.toString()
                        }, t.prototype.computedRoundedStringValue = function(e) {
                            var t = this.computedValue(e),
                                r = a.HSStageVariable.parseValue(t, !1);
                            return "number" == typeof r && (r = Math.round(1e6 * r) / 1e6), r.toString()
                        }, t.prototype.computedBooleanValue = function(e) {
                            var t = this.firstParamValue(e),
                                r = this.secondParamValue(e);
                            return this.conditionalCalculator.computedBooleanValue(this.type, t, r, e.parentObject)
                        }, t.prototype.usesOriginalObject = function() {
                            return this.type === o.HSBlockType.OriginalObject || this.objectReferenceType === o.HSBlockType.OriginalObject
                        }, t.prototype.firstParamValue = function(e) {
                            return this.parameters.length > 0 ? this.parameters[0].computedValue(e) : 0
                        }, t.prototype.firstParamStringValue = function(e) {
                            return this.parameters.length > 0 ? this.parameters[0].computedStringValue(e) : ""
                        }, t.prototype.secondParamValue = function(e) {
                            return this.parameters.length >= 2 ? this.parameters[1].computedValue(e) : 0
                        }, t.prototype.secondParamNumberValue = function(e) {
                            return a.HSStageVariable.parseNumberFrom(this.secondParamValue(e))
                        }, t.prototype.secondParamStringValue = function(e) {
                            return this.parameters.length >= 2 ? this.parameters[1].computedStringValue(e) : ""
                        }, t.prototype.endIndexValue = function(e) {
                            return this.parameters.length < 3 ? 0 : this.parameters[2].computedNumberValue(e)
                        }, t
                    }(h.HSStageObjectBase);
                t.HSStageParameterBlock = g, window.HSStageParameterBlock = g
            },
            7779: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSStageProject = void 0;
                var i = r(445),
                    s = function() {
                        function e(t, r, i) {
                            this.stageScenes = t, this.version = i, this.shouldResetSceneVisuals = !1, this.activeStageScene = this.stageScenes[r || 0], e.sharedInstance = this
                        }
                        return e.prototype.changeScene = function(e) {
                            e && (this.shouldResetSceneVisuals = !0, this.activeStageScene = e, this.activeStageScene.activator.activateAllRulesForEventType(i.HSBlockType.EventOperatorStart))
                        }, e.prototype.activateAllRulesForEventType = function(e) {
                            this.activeStageScene.activator.activateAllRulesForEventType(e)
                        }, e.prototype.executeAllActiveRules = function() {
                            this.activeStageScene.activator.executeAllActiveRules()
                        }, e.prototype.animationTick = function(collisionContext, visualContext) {
                            this.activeStageScene.animationTick(collisionContext), this.shouldResetSceneVisuals && (visualContext.drawingContext.clear(), visualContext.backgroundContext.clear(), this.shouldResetSceneVisuals = !1)
                        }, e.prototype.receiveClickEvent = function(e, t) {
                            this.activeStageScene.receiveClickEvent(e, t)
                        }, e.prototype.receiveTouchDownEvent = function(e, t) {
                            this.activeStageScene.receiveTouchDownEvent(e, t)
                        }, e.prototype.receiveTouchMoveEvent = function(e, t) {
                            this.activeStageScene.receiveTouchMoveEvent(e, t)
                        }, e.prototype.receiveTouchUpEvent = function(e, t) {
                            this.activeStageScene.receiveTouchUpEvent(e, t)
                        }, e
                    }();
                t.HSStageProject = s, window.HSStageProject = s
            },
            2610: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.MessageView = t.PromptView = t.HSStagePrompt = void 0;
                var i = r(2983),
                    s = r(445),
                    n = r(8362),
                    o = r(9005),
                    a = t.HSStagePrompt = function() {
                        function e(t, r) {
                            var i, n;
                            switch (this.ruleGroup = t, this.isOnScreen = !1, e.enableAntiSpam(), this.type = r.type, this.id = r.id, this.parameters = r.parameters, r.type) {
                                case s.HSBlockType.SaveInput:
                                case s.HSBlockType.SetTextToInput:
                                    this.promptText = (null === (i = r.parameters[1]) || void 0 === i ? void 0 : i.computedStringValue(t)) || "Type here", this.view = new l(this.promptText);
                                    break;
                                case s.HSBlockType.ShowPopup:
                                    this.promptText = (null === (n = r.parameters[0]) || void 0 === n ? void 0 : n.computedStringValue(t)) || "", this.view = new u(this.promptText)
                            }
                        }
                        return e.enableAntiSpam = function() {
                            null === e.antiSpam && (e.antiSpam = new c)
                        }, e.prototype.execute = function() {
                            this.displayIfNeeded(), this.checkValue()
                        }, e.prototype.checkSpam = function(e) {
                            this.antiSpam.check(e)
                        }, e.prototype.checkValue = function() {
                            var e;
                            if (!this.doesNotNeedToBeChecked()) switch (this.checkSpam(this.view.isSpam), this.type) {
                                case s.HSBlockType.SaveInput:
                                    var t = this.parameters[0],
                                        r = null == t ? void 0 : t.variable(),
                                        o = null == t ? void 0 : t.localVariable();
                                    if (!r && !o) return;
                                    r && r.setValue(this.view.value, this.ruleGroup), o && o.setValue(this.view.value);
                                    break;
                                case s.HSBlockType.SetTextToInput:
                                    var a = (null === (e = this.parameters[0]) || void 0 === e ? void 0 : e.computedColorString(this.ruleGroup)) || n.HSColor.rgbTextColor;
                                    this.ruleGroup.parentObject.setText(i.HSStageVariable.parseValue(this.view.value, !1).toString(), a)
                            }
                        }, e.prototype.displayIfNeeded = function() {
                            this.needsToBeDisplayed() && (this.isOnScreen = !0, this.view.show(e.antiSpam.askIfNextIsSpam))
                        }, e.prototype.doesNotNeedToBeChecked = function() {
                            return this.isOnScreen && !this.view.isDone
                        }, e.prototype.needsToBeDisplayed = function() {
                            var e, t, r = this.type === s.HSBlockType.SaveInput && ((null === (e = this.parameters[0]) || void 0 === e ? void 0 : e.variable()) || (null === (t = this.parameters[0]) || void 0 === t ? void 0 : t.localVariable())),
                                i = this.type === s.HSBlockType.SetTextToInput,
                                n = this.type === s.HSBlockType.ShowPopup;
                            return !this.isSpam && !this.isOnScreen && (r || i || n) && !this.isDone
                        }, Object.defineProperty(e.prototype, "isDone", {
                            get: function() {
                                return this.view.isDone
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e.prototype, "antiSpam", {
                            get: function() {
                                return e.antiSpam
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(e.prototype, "isSpam", {
                            get: function() {
                                return this.antiSpam.dontShowPrompts
                            },
                            enumerable: !1,
                            configurable: !0
                        }), e.antiSpam = null, e
                    }();

                function h(e, t) {
                    for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
                }
                var l = function() {
                    function e(e) {
                        void 0 === e && (e = "Type here"), this.text = e, this.isSpam = !1, this.isDone = !1, this.appValue = "", this.createHTMLView(e)
                    }
                    return e.prototype.createHTMLView = function(e) {
                        var t = this;
                        if (!(0, o.isIOSApp)()) {
                            var r = document.createElement("div");
                            r.id = "hs_parent_div" + (0, o.generateUUID)(), r.classList.add("hs-popup"), h(r.style, {
                                position: "absolute",
                                top: "0",
                                left: "50%",
                                transform: "translate(-50%, 20%)",
                                overflow: "hidden",
                                padding: "10px 20px 10px 20px",
                                borderRadius: "16px",
                                background: "white",
                                boxShadow: "2px 2px 8px 2px rgba(158, 158, 158, 0.47)",
                                zIndex: "9",
                                fontSize: "100%",
                                minWidth: "min(35%, 320px)"
                            }), this.div = r;
                            var i = document.createElement("p");
                            h(i.style, {
                                fontSize: "1em",
                                "word-break": "break-word",
                                fontFamily: "Avenir, sans-serif",
                                fontWeight: "normal",
                                color: "#000000c2",
                                margin: "10px 0px",
                                textAlign: "center"
                            }), i.innerText = e, this.div.appendChild(i);
                            var s = document.createElement("input");
                            h(s.style, {
                                width: "100%",
                                height: "50px",
                                type: "text",
                                fontSize: "1.8em",
                                fontFamily: "Avenir, sans-serif",
                                borderWidth: "2px",
                                borderStyle: "solid",
                                borderRadius: "8px",
                                borderImage: "none",
                                outline: "none",
                                padding: "10px",
                                color: "#000000de"
                            }), s.autofocus = !0, this.input = s, this.div.appendChild(s);
                            var n = document.createElement("a");
                            h(n.style, {
                                fontFamily: "Avenir, sans-serif",
                                display: "block",
                                position: "relative",
                                textAlign: "center",
                                padding: "10px",
                                background: "#1dd8be",
                                color: "white",
                                fontWeight: "bold",
                                fontSize: "1.8em",
                                borderRadius: "19px",
                                width: "100px",
                                margin: "10px auto -1px",
                                cursor: "pointer",
                                userSelect: "none",
                                webkitUserSelect: "none"
                            }), n.innerText = "OK";
                            var a = d() ? "touchstart" : "click";
                            n.addEventListener(a, (function() {
                                l(t)
                            })), s.addEventListener(a, (function(e) {
                                return s.focus()
                            })), s.addEventListener("keyup", (function(e) {
                                13 === e.keyCode && (e.preventDefault(), l(t))
                            })), this.btn = n, this.div.appendChild(n)
                        }

                        function l(e) {
                            e.isDone = !0, e.hide()
                        }
                    }, e.prototype.show = function(e) {
                        this.showAppPromptIfNecessary(e), this.showBrowserPromptIfNecessary()
                    }, e.prototype.showBrowserPromptIfNecessary = function() {
                        (0, o.isIOSApp)() || (document.body.appendChild(this.div), this.input.value = "", this.input.focus())
                    }, e.prototype.showAppPromptIfNecessary = function(e) {
                        var t = this;
                        (0, o.isIOSApp)() && (o.HSApp.sendToApp("input_prompt" + (e ? ":spam" : ""), this.text), o.HSApp.readFromAppOnce("input_prompt", (function(e) {
                            t.readInputFromIOSApp(e, !1)
                        })), e && o.HSApp.readFromAppOnce("input_prompt:spam", (function(e) {
                            t.readInputFromIOSApp(e, !0)
                        })))
                    }, e.prototype.readInputFromIOSApp = function(e, t) {
                        this.appValue = e, this.isDone = !0, this.isSpam = t
                    }, e.prototype.hide = function() {
                        (0, o.isIOSApp)() || this.div.remove()
                    }, e.prototype.isFilled = function() {
                        return "" !== this.value
                    }, Object.defineProperty(e.prototype, "value", {
                        get: function() {
                            return (0, o.isIOSApp)() ? this.appValue : this.input.value
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e
                }();
                t.PromptView = l;
                var u = function() {
                    function e(e) {
                        void 0 === e && (e = ""), this.text = e, this.isSpam = !1, this.isDone = !1, this.createHTMLView(e)
                    }
                    return e.prototype.createHTMLView = function(e) {
                        var t = this,
                            r = document.createElement("div");
                        r.id = "hs_parent_div" + (0, o.generateUUID)(), r.classList.add("hs-popup"), h(r.style, {
                            position: "absolute",
                            top: "0",
                            left: "50%",
                            transform: "translate(-50%, 20%)",
                            overflow: "hidden",
                            padding: "10px 20px 10px 20px",
                            borderRadius: "16px",
                            background: "white",
                            boxShadow: "2px 2px 8px 2px rgba(158, 158, 158, 0.47)",
                            zIndex: "9",
                            fontSize: "100%",
                            minWidth: "min(35%, 320px)"
                        }), this.div = r;
                        var i = document.createElement("p");
                        h(i.style, {
                            fontSize: "2em",
                            fontFamily: "Avenir, sans-serif",
                            fontWeight: "normal",
                            color: "#000000c2",
                            margin: "10px 0px",
                            textAlign: "center",
                            overflowY: "scroll",
                            maxHeight: "8em",
                            userSelect: "text",
                            webkitUserSelect: "text"
                        }), i.innerText = e, this.div.appendChild(i);
                        var s = document.createElement("a");
                        h(s.style, {
                            fontFamily: "Avenir, sans-serif",
                            display: "block",
                            position: "relative",
                            textAlign: "center",
                            padding: "10px",
                            background: "#1dd8be",
                            color: "white",
                            fontWeight: "bold",
                            fontSize: "1.8em",
                            borderRadius: "19px",
                            width: "100px",
                            margin: "10px auto -1px",
                            cursor: "pointer",
                            userSelect: "none",
                            webkitUserSelect: "none"
                        }), s.innerText = "OK";
                        var n = d() ? "touchstart" : "click";
                        s.addEventListener(n, (function(e) {
                            var r;
                            (r = t).isDone = !0, r.hide(), e.preventDefault(), e.stopImmediatePropagation()
                        }), {
                            capture: !0,
                            once: !0
                        }), this.btn = s, this.div.appendChild(s)
                    }, e.prototype.showBrowserPromptIfNecessary = function() {
                        (0, o.isIOSApp)() || document.body.appendChild(this.div)
                    }, e.prototype.show = function(e) {
                        this.showAppPromptIfNecessary(e), this.showBrowserPromptIfNecessary()
                    }, e.prototype.hide = function() {
                        this.div.remove()
                    }, Object.defineProperty(e.prototype, "value", {
                        get: function() {
                            return ""
                        },
                        enumerable: !1,
                        configurable: !0
                    }), e.prototype.showAppPromptIfNecessary = function(e) {
                        var t = this;
                        (0, o.isIOSApp)() && (o.HSApp.sendToApp("message_prompt" + (e ? ":spam" : ""), this.text), o.HSApp.readFromAppOnce("message_prompt", (function(e) {
                            t.readInputFromIOSApp(!1)
                        })), e && o.HSApp.readFromAppOnce("message_prompt:spam", (function(e) {
                            t.readInputFromIOSApp(!0)
                        })))
                    }, e.prototype.readInputFromIOSApp = function(e) {
                        this.isDone = !0, this.isSpam = e
                    }, e
                }();
                t.MessageView = u;
                var c = function() {
                    function e() {
                        var e = this;
                        this.minTimeBeforeSpam = 1600, this.timeBeforeCheck = 2200, this.count = 0, this.lastTime = 0, this.elapsed = 0, this.askIfNextIsSpam = !1, this.dontShowPrompts = !1, this.reset = function() {
                            e.count = 0, e.elapsed = 0, e.lastTime = 0, e.askIfNextIsSpam = !1, e.dontShowPrompts = !1
                        }, o.HSApp.addResetCallback("antispam", this.reset)
                    }
                    return e.prototype.check = function(e) {
                        e && (this.dontShowPrompts = !0), this.checkElapsedTime(), this.lastTime = Date.now(), this.askIfNextIsSpam = this.askUserIfNextIsSpam()
                    }, e.prototype.checkElapsedTime = function() {
                        if (0 !== this.lastTime) {
                            var e = this.lastTime,
                                t = Date.now() - e;
                            this.elapsed += t, this.count += 1
                        }
                    }, e.prototype.askUserIfNextIsSpam = function() {
                        if (this.elapsed <= this.timeBeforeCheck) return !1;
                        var e = this.elapsed,
                            t = this.count;
                        return this.elapsed = 0, this.count = 0, e / t <= this.minTimeBeforeSpam
                    }, e
                }();

                function d() {
                    return "ontouchstart" in document.documentElement
                }
                window.HSStagePrompt = a, window.PromptView = l
            },
            3847: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSStageRule = void 0;
                var i = r(655),
                    s = r(7779),
                    n = r(5203),
                    o = r(445),
                    a = r(9005),
                    h = r(4108),
                    l = r(5218),
                    u = function(e) {
                        function t(t, r, i) {
                            var s = e.call(this, r) || this;
                            return s.eventBlock = t, s.ruleGroup = r, s.parentCustomRule = i, s.isActive = !1, s._collisionPairs = [], s.numFirstParamObjects = 0, s.numSecondParamObjects = 0, s.activateIfEqualsEventMessage = function(e) {
                                var t;
                                e.trim() === (null === (t = s.eventBlock.parameterBlockStringValues(s.ruleGroup)[0]) || void 0 === t ? void 0 : t.trim()) && s.activate()
                            }, s.activateIfMatchesEventMessage = function(e) {
                                var t, r = e.trim(),
                                    i = null === (t = s.eventBlock.parameterBlockStringValues(s.ruleGroup)[0]) || void 0 === t ? void 0 : t.trim();
                                (0, a.checkMatches)(r, i) && s.activate()
                            }, s
                        }
                        return i.__extends(t, e), t.prototype.scopeMode = function() {
                            return l.ScopeMode.Own
                        }, t.prototype.reset = function() {
                            var e;
                            null === (e = this.environment()) || void 0 === e || e.clear(), this.stageScript.reset()
                        }, t.prototype.activate = function() {
                            this.isActive || (this.reset(), this.isActive = !0)
                        }, t.prototype.activateIfMatchesFirstObject = function(e) {
                            this.matchesFirstObject(e) && this.activate()
                        }, t.prototype.activateIfNotPressed = function(e) {
                            this.isPressed(e) || this.activate()
                        }, t.prototype.isPressed = function(e) {
                            var t = this;
                            return e.currentlyPressedObjects.some((function(e) {
                                return t.matchesATap(e)
                            }))
                        }, t.prototype.matchesATap = function(e) {
                            var t = this;
                            return e.some((function(e) {
                                return t.matchesFirstObject(e)
                            }))
                        }, t.prototype.break = function() {
                            this.isActive = !1, this.reset()
                        }, t.prototype.collisionPairs = function() {
                            var e = this,
                                t = this.eventBlock.childParameterBlocks()[0],
                                r = this.eventBlock.childParameterBlocks()[1],
                                i = this.stageObjectsForParameter(t),
                                s = this.stageObjectsForParameter(r);
                            if (this._collisionPairs && this.numFirstParamObjects === i.length && this.numSecondParamObjects === s.length) return this._collisionPairs;
                            var o = i.slice(this.numFirstParamObjects),
                                a = s.slice(this.numSecondParamObjects),
                                h = i.slice(0, this.numFirstParamObjects);
                            return o.forEach((function(t) {
                                s.filter((function(e) {
                                    return e !== t
                                })).forEach((function(r) {
                                    e._collisionPairs.push(new n.HSCollisionPair(t, r)), t.relatedCollisionRules.add(e), r.relatedCollisionRules.add(e)
                                }))
                            })), h.forEach((function(t) {
                                a.filter((function(e) {
                                    return e !== t
                                })).forEach((function(r) {
                                    e._collisionPairs.push(new n.HSCollisionPair(t, r))
                                }))
                            })), this.numFirstParamObjects = i.length, this.numSecondParamObjects = s.length, this._collisionPairs
                        }, t.prototype.stageObjectsForParameter = function(e) {
                            try {
                                return e.type === o.HSBlockType.AnyObject ? s.HSStageProject.sharedInstance.activeStageScene.stageObjects : e.stageObjects(this.ruleGroup)
                            } catch (e) {}
                            return []
                        }, t.prototype.eventType = function() {
                            return this.eventBlock.type
                        }, t.prototype.matchesEvent = function(e) {
                            return this.eventType() === e
                        }, t.prototype.matchesFirstObject = function(e) {
                            return this.eventBlock.matchesStageObject(e, this.ruleGroup)
                        }, t.prototype.execute = function(ruleGroup) {
                            if (this.isExecutable()) {
								if (this.stageScript.isImmediate)
									this.isActive = false
								 this.stageScript.execute(ruleGroup)
							 } else {
								 this.isActive = false
							 }
                        }, t.prototype.isExecutable = function() {
                            return this.isValid() && this.isActive && this.hasBlocksToExecute()
                        }, t.prototype.hasBlocksToExecute = function() {
                            return this.stageScript.blocks().length > 0
                        }, t.prototype.isValid = function() {
                            return null != this.stageScript
                        }, t.prototype.conditionIsTrue = function(e) {
                            return this.eventBlock.computedBooleanValue(e)
                        }, t.prototype.deepCopy = function(e) {
                            var r = new t(this.eventBlock, e, this.parentCustomRule);
                            return r.stageScript = this.stageScript.deepCopy(r), r
                        }, t.prototype.isCurrentObject = function(e) {
                            return this.ruleGroup.parentObject === e
                        }, t
                    }(h.HSStageObjectBase);
                t.HSStageRule = u, window.HSStageRule = u
            },
            4517: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSStageRuleGroup = void 0;
                var i = r(655),
                    s = r(445),
                    n = r(5218),
                    o = r(8232),
                    a = r(9005),
                    h = r(8362),
                    l = r(682),
                    u = r(4108),
                    c = r(2610),
                    d = r(1925),
                    p = function(e) {
                        function t(t, r, i) {
                            void 0 === i && (i = !1);
                            var s = e.call(this, t) || this;
                            return s.parentObject = r, s.isBase = i, s._rules = [], s
                        }
                        return i.__extends(t, e), t.prototype.scopeMode = function() {
                            return this.isBase ? n.ScopeMode.Parent : n.ScopeMode.DynamicRoot
                        }, t.prototype.populateEnvironment = function(e) {
                            var t, r, s, n = this,
                                o = (null === (s = this.customRule) || void 0 === s || s.name, e || this);
                            if (this.customRule) {
                                try {
                                    for (var a = i.__values(this.customRule.parameters), h = a.next(); !h.done; h = a.next()) {
                                        var l = h.value;
                                        this.environment().set(l.key, l.computedStringValue(o))
                                    }
                                } catch (e) {
                                    t = {
                                        error: e
                                    }
                                } finally {
                                    try {
                                        h && !h.done && (r = a.return) && r.call(a)
                                    } finally {
                                        if (t) throw t.error
                                    }
                                }
                                o = this, this.customRuleGroups().forEach((function(e) {
                                    e.populateEnvironment(n)
                                }))
                            }
                        }, t.prototype.deepCopy = function(e, r) {
                            var i, s, n = new t(e, r);
                            n.addRules(this.rules().map((function(e) {
                                return e.deepCopy(n)
                            }))), n.setScript(null === (i = this.script()) || void 0 === i ? void 0 : i.deepCopy(n)), n.customRule = null === (s = this.customRule) || void 0 === s ? void 0 : s.deepCopy(n);
                            var o = this.environment();
                            return n.environment().replace(o), n
                        }, t.prototype.setScript = function(e) {
                            this._script = e
                        }, t.prototype.addRules = function(e) {
                            this._rules = this.rules().concat(e)
                        }, t.prototype.rules = function() {
                            return this._rules.length > 0 ? this._rules : []
                        }, t.prototype.customRuleGroups = function() {
                            var e;
                            return (null === (e = this.customRule) || void 0 === e ? void 0 : e.ruleGroups) || []
                        }, t.prototype.allRulesIncludingNested = function() {
                            var e = this.customRuleGroups().flatMap((function(e) {
                                return e.allRulesIncludingNested()
                            }));
                            return this.rules().concat(e)
                        }, t.prototype.script = function() {
                            return this._script
                        }, t.prototype.executeScript = function() {
                            var e;
                            null === (e = this.script()) || void 0 === e || e.execute(this), this.customRuleGroups().forEach((function(e) {
                                return e.executeScript()
                            }))
                        }, t.prototype.activateAllStageRulesForEventType = function(e, t) {
                            this.allStageRulesForEventTypeAndObject(e, t).forEach((function(e) {
                                return e.activate()
                            })), this.customRuleGroups().forEach((function(r) {
                                return r.activateAllStageRulesForEventType(e, t)
                            }))
                        }, t.prototype.allStageRulesForEventTypeAndObject = function(e, t) {
                            return this.allStageRulesForEventType(e).filter((function(e) {
                                return e.matchesFirstObject(t)
                            }))
                        }, t.prototype.allStageRulesForEventType = function(e) {
                            return this.rules().filter((function(t) {
                                return t.matchesEvent(e)
                            }))
                        }, t.prototype.allPossibleCollisionPairs = function() {
                            var e = this.allStageRulesForEventType(s.HSBlockType.EventOperatorIsTouching),
                                t = this.allStageRulesForEventType(s.HSBlockType.EventOperatorIsNotTouching),
                                r = this.allStageRulesForEventType(s.HSBlockType.EventOperatorBump),
                                i = e.concat(t).concat(r).reduce((function(e, t) {
                                    return e.concat(t.collisionPairs())
                                }), []),
                                n = this.customRuleGroups().flatMap((function(e) {
                                    return e.allPossibleCollisionPairs()
                                })).filter((function(e) {
                                    return !!e
                                }));
                            return i.concat(n)
                        }, t.prototype.executeActiveRules = function() {
                            for (var e = this.rules(), t = e.length, r = 0; r !== t; ++r) { e[r].conditionIsTrue(this) && (e[r].hasBlocksToExecute() || (e[r].isActive = !1), e[r].activate())
								/*PETRICHOR DEBUGGER MOD START*/
								petrichorFrameStateStack.push({state: PetrichorPossibleFrameProgressStates.progressInRuleGroup, index: r})
								/*PETRICHOR DEBUGGER MOD END*/
								e[r].execute(this);
								/*PETRICHOR DEBUGGER MOD START*/
								petrichorFrameStateStack.pop()
								/*PETRICHOR DEBUGGER MOD END*/
							}
                            this.customRuleGroups().forEach((function(e) {
								/*PETRICHOR DEBUGGER MOD START*/
								// TODO: This
								/*PETRICHOR DEBUGGER MOD END*/
                                return e.executeActiveRules()
                            }))
                        }, t.prototype.break = function() {
                            this.rules().forEach((function(e) {
                                return e.break()
                            })), this.customRuleGroups().forEach((function(e) {
                                return e.break()
                            }))
                        }, t.prototype.maxStepSize = function() {
                            return this.parentObject.maxStepSize()
                        }, t.prototype.executeBlock = function(e) {
                            var t, r, i, n, u, p, f, m = e.firstIntegerValue(this),
                                g = e.parameters,
                                y = this.parentObject;
                            switch (e.type) {
                                case s.HSBlockType.Move:
                                    y.moveBy(m);
                                    break;
                                case s.HSBlockType.SetPosition:
                                    y.setPosition(g[0].computedNumberValue(this), g[1].computedNumberValue(this));
                                    break;
                                case s.HSBlockType.SetSize:
                                    if (null === (t = g[0]) || void 0 === t ? void 0 : t.isSet(this)) {
                                        var _ = null === (r = g[0]) || void 0 === r ? void 0 : r.computedValue(this);
                                        "number" == typeof _ && (y.sizePercentWidth = _, y.sizePercentHeight = _)
                                    }
                                    break;
                                case s.HSBlockType.Grow:
                                    i = Math.max(100 + m, 0), y.sizePercentWidth *= .01 * i, y.sizePercentHeight *= .01 * i;
                                    break;
                                case s.HSBlockType.Scale:
                                    y.sizePercentWidth *= .01 * m, y.sizePercentHeight *= .01 * m;
                                    break;
                                case s.HSBlockType.Shrink:
                                    i = Math.max(100 - m, 0), n = y.sizePercentWidth * i * .01, y.sizePercentWidth = Math.max(n, 1e-7), n = y.sizePercentHeight * i * .01, y.sizePercentHeight = Math.max(n, 1e-7);
                                    break;
                                case s.HSBlockType.SetHeading:
                                    y.headingInDegrees = l.HSStageObject.normalizeHeading(m);
                                    break;
                                case s.HSBlockType.ChangeX:
                                    y.changeXBy(m);
                                    break;
                                case s.HSBlockType.ChangeY:
                                    y.changeYBy(m);
                                    break;
                                case s.HSBlockType.Rotate:
                                    y.rotateBy(m);
                                    break;
                                case s.HSBlockType.ChangeSpeed:
                                    y.speed = m;
                                    break;
                                case s.HSBlockType.SetInvisibility:
                                    y.invisibilityPercent = m;
                                    break;
                                case s.HSBlockType.Flip:
                                    y.isFlipped = !y.isFlipped;
                                    break;
                                case s.HSBlockType.SetTrailColor:
                                    y.drawingColor = g[0].computedColorString(this);
                                    break;
                                case s.HSBlockType.SetTrailWidth:
                                    y.drawingRadius = m / 2;
                                    break;
                                case s.HSBlockType.SetTrailCap:
                                    y.drawingCap = g[0].computedLineCap(this);
                                    break;
                                case s.HSBlockType.SetTrailOpacity:
                                    y.drawingOpacityPercent = m;
                                    break;
                                case s.HSBlockType.Clear:
                                    y.clear();
                                    break;
                                case s.HSBlockType.PenDown:
                                    y.penDown = !0;
                                    break;
                                case s.HSBlockType.PenUp:
                                    y.penDown = !1;
                                    break;
                                case s.HSBlockType.ChangeCostume:
                                    y.changePose();
                                    break;
                                case s.HSBlockType.SetText:
                                    f = h.HSColor.rgbTextColor, g.length >= 2 && (f = g[1].computedColorString(this)), y.setText(g[0].computedRoundedStringValue(this), f);
                                    break;
                                case s.HSBlockType.SetTextToInput:
                                    d.HSStageScene.promptsToExecute.push(new c.HSStagePrompt(this, e));
                                    break;
                                case s.HSBlockType.SetVariable:
                                    (u = g[0].variable()) && u.setValue(g[1].computedStringValue(this), this), (p = g[0].localVariable()) && p.setValue(g[1].computedStringValue(this));
                                    break;
                                case s.HSBlockType.SaveInput:
                                case s.HSBlockType.ShowPopup:
                                    d.HSStageScene.promptsToExecute.push(new c.HSStagePrompt(this, e));
                                    break;
                                case s.HSBlockType.ChangeVariable:
                                    u = g[0].variable(), p = g[0].localVariable();
                                    var v = u || p;
                                    if (v) {
                                        var S = v.computedNumberValue(this) + g[1].computedNumberValue(this);
                                        v.setValue(S, this)
                                    }
                                    break;
                                case s.HSBlockType.BringToFront:
                                    y.bringToFront();
                                    break;
                                case s.HSBlockType.SendToBack:
                                    y.sendToBack();
                                    break;
                                case s.HSBlockType.SetImage:
                                    g[0].computedObjectType() === o.HSObjectType.text ? y.setText(g[0].value, h.HSColor.rgbTextColor) : g[0].computedObjectType() === o.HSObjectType.image ? y.setImage(g[0].childBlock) : y.setCharacter(g[0].computedObjectType());
                                    break;
                                case s.HSBlockType.SetColor:
                                    y.color = g[0].computedColorString(this);
                                    break;
                                case s.HSBlockType.SetWidthAndHeight:
                                    g[0].isSet(this) && y.setWidth(g[0].computedNumberValue(this)), g[1].isSet(this) && y.setHeight(g[1].computedNumberValue(this));
                                    break;
                                case s.HSBlockType.SetZIndex:
                                    var T = g[0].computedNumberValue(this);
                                    T !== y.zIndex && (y.zIndex = T, d.HSStageScene.dirtySort = !0);
                                    break;
                                case s.HSBlockType.SetBackground:
                                    y.setBackground(g[0].computedColorString(this));
                                    break;
                                case s.HSBlockType.SetOriginXY:
                                    y.setOrigin(g[0].computedNumberValue(this), g[1].computedNumberValue(this));
                                    break;
                                case s.HSBlockType.SetCenterXY:
                                    y.setPosition(g[0].computedNumberValue(this), g[1].computedNumberValue(this));
                                    break;
                                case s.HSBlockType.SetTempo:
                                    y.tempo = m;
                                    break;
                                case s.HSBlockType.SetInstrument:
                                    y.instrument = (0, a.parseInstrumentName)(g[0].computedStringValue(this)) || l.DEFAULT_INSTRUMENT
                            }
                        }, t
                    }(u.HSStageObjectBase);
                t.HSStageRuleGroup = p
            },
            1925: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSStageScene = void 0;
                var i = r(655),
                    s = r(9005),
                    n = r(37),
                    o = r(6642),
                    a = r(7554),
                    h = r(648),
                    l = r(445),
                    u = r(4108),
                    c = i.__importStar(r(8687)),
                    d = r(3452),
                    p = t.HSStageScene = function(e) {
                        function t(r, i, s, n) {
                            var o = e.call(this, null) || this;
                            return o.stageObjects = r, o.name = i, o.id = s, o.context = n, o.renderList = new h.HSLinkedList, o.pointers = [], o.currentlyPressedObjects = [], o.tickCount = 0, o.nextEvents = new Set, o.currentEvents = new Set, o.activator = new a.HSRuleActivator(o), o.container = new c.Container, o.stageObjects.forEach((function(e) {
                                o.bindStageObject(e)
                            })), o.lastTouchX = t.stageWidth / 2, o.lastTouchY = t.stageHeight / 2, o
                        }
                        return i.__extends(t, e), t.prototype.queueEventMessage = function(e) {
                            this.nextEvents.add(e)
                        }, t.prototype.swapEventMessageQueue = function() {
                            var e = this.currentEvents;
                            e.clear(), this.currentEvents = this.nextEvents, this.nextEvents = e
                        }, t.prototype.bindStageObject = function(e) {
                            e.bringToFrontFunction = this.bringToFront.bind(this), e.sendToBackFunction = this.sendToBack.bind(this), e.cloneFunction = this.clone.bind(this), e.destroyFunction = this.activator.addToDestroyQueue.bind(this.activator), e.broadcastMessageFunction = this.queueEventMessage.bind(this), this.renderList.push(e)
                        }, t.prototype.animationTick = function(collisionContext) {
                            // var stageScene = this;
                            // t.dirtySort && (t.dirtySort = !1, this.sortRenderList()), this.container.removeChildren(), this.renderList.forEach((function(e) {
                            //     e.update(), e.view.sprite && stageScene.container.addChild(e.view.sprite)
                            // })), this.collisionTest(collisionContext), this.activateRules()
							// this.executeRules()
							// this.activator.cleanDestroyQueue(), this.swapEventMessageQueue(), this.tickCount++
                        }, t.prototype.collisionTest = function(e) {
                            if (e) {
                                e.tick(this.renderList), e.numberOfPixelCollisions = 0;
                                var t = this.activator.allPossibleCollisionPairs();
                                t.forEach((function(t) {
                                    return t.update(e)
                                })), this.activator.currentCollisions = t.filter((function(e) {
                                    return e.isTouching()
                                })), this.activator.bumpingCollisions = this.activator.currentCollisions.filter((function(e) {
                                    return e.isBumping()
                                }))
                            }
                        }, t.prototype.activateRules = function() {
                            var e = this;
                            this.touchIsDown && this.currentlyPressedObjects.forEach((function(t) {
                                e.activator.activateAllRulesForEventWithObjects(l.HSBlockType.EventOperatorHold, t)
                            })), this.context.hasAccelerometerEvent() && (this.activateTiltRules(), this.activateShakeRules()), this.context.hasNoiseEvent() && this.activateNoiseRules(), this.activateAllNotPressedRules(), this.activateEventMessageRules(), this.activator.activateCurrentCollisionRules()
                        }, t.prototype.activateEventMessageRules = function() {
                            var e = this;
                            this.activator.allStageRulesForEventType(l.HSBlockType.EventOperatorHearMessage).forEach((function(t) {
                                e.currentEvents.forEach(t.activateIfEqualsEventMessage)
                            })), this.activator.allStageRulesForEventType(l.HSBlockType.EventOperatorMessageMatches).forEach((function(t) {
                                e.currentEvents.forEach(t.activateIfMatchesEventMessage)
                            }))
                        }, t.prototype.activateAllNotPressedRules = function() {
                            var e = this;
                            this.activator.allStageRulesForEventType(l.HSBlockType.EventOperatorNotPressed).forEach((function(t) {
                                t.activateIfNotPressed(e)
                            }))
                        }, t.prototype.executeRules = function() {
                            this.activator.executeAllActiveRules()
                        }, t.prototype.receiveClickEvent = function(e, t) {
                            var r;
                            this.setTouchPosition(e, t);
                            var i = (r = e.point).x,
                                s = r.y,
                                n = this.stageObjectsToReceiveTouchInRange(i, s, t);
                            this.activator.activateAllRulesForEventWithObjects(l.HSBlockType.EventOperatorTap, n), this.activator.activateAllRulesForEventWithObjects(l.HSBlockType.EventOperatorHold, n);
                            var o = this.indexOfPointer(e.id);
                            this.currentlyPressedObjects[o] = n
                        }, t.prototype.addPointer = function(e) {
                            var t = this.indexOfPointer(e.id);
                            if (-1 !== t) return this.pointers[t];
                            var r = this.getPointerData(e);
                            return this.pointers.push(r), r
                        }, t.prototype.receiveTouchDownEvent = function(e, t) {
                            this.setTouchPosition(e, t)
                        }, t.prototype.receiveTouchMoveEvent = function(e, t) {
                            this.touchIsDown && (this.setTouchPosition(e, t), this.calculateSwipeEvents(this.getPointerFrom(e.id), t))
                        }, t.prototype.receiveTouchUpEvent = function(e, t) {
                            var r = this.indexOfPointer(e.id);
                            this.removePointer(e.id), this.currentlyPressedObjects.splice(r, 1), this.activator.activateAllRulesForEventType(l.HSBlockType.EventOperatorTouchEnds)
                        }, t.prototype.getPointerData = function(e) {
                            var t, r = (t = e.point).x,
                                i = t.y;
                            return {
                                id: e.id,
                                downX: r,
                                downY: i,
                                lastX: r,
                                lastY: i
                            }
                        }, t.prototype.removePointer = function(e) {
                            var t = this.indexOfPointer(e); - 1 !== t && this.pointers.splice(t, 1)
                        }, t.prototype.indexOfPointer = function(e) {
                            for (var t = 0; t < this.pointers.length; t++)
                                if (this.pointers[t].id === e) return t;
                            return -1
                        }, t.prototype.getPointerFrom = function(e) {
                            var t = this.indexOfPointer(e);
                            return -1 !== t ? this.pointers[t] : null
                        }, t.prototype.calculateSwipeEvents = function(e, t) {
                            var r = this.horizontalSwipeForPoint(e),
                                i = this.verticalSwipeForPoint(e),
                                s = this.directionForSwipe(r, i);
                            if (s) {
                                var n = this.stageObjectsToReceiveTouchInRange(e.downX, e.downY, t);
                                this.activator.activateAllRulesForEventWithObjects(s, n), e.downX = null, e.downY = null
                            }
                        }, t.prototype.directionForSwipe = function(e, t) {
                            switch ((0, s.hs_direction)(e, t, 10)) {
                                case s.HSDirection.up:
                                    return l.HSBlockType.EventOperatorSwipeUp;
                                case s.HSDirection.down:
                                    return l.HSBlockType.EventOperatorSwipeDown;
                                case s.HSDirection.left:
                                    return l.HSBlockType.EventOperatorSwipeLeft;
                                case s.HSDirection.right:
                                    return l.HSBlockType.EventOperatorSwipeRight;
                                default:
                                    return null
                            }
                        }, t.prototype.horizontalSwipeForPoint = function(e) {
                            return e.downX ? e.lastX - e.downX : 0
                        }, t.prototype.verticalSwipeForPoint = function(e) {
                            return e.downY ? e.lastY - e.downY : 0
                        }, t.prototype.setTouchPosition = function(e, t) {
                            var r, i = this.getPointerFrom(e.id) || this.addPointer(e),
                                s = (r = e.point).x,
                                n = r.y;
                            return i.lastX = s, i.lastY = n, this.isTheLastPointer(e.id) && (this.lastTouchX = s, this.lastTouchY = n), i
                        }, t.prototype.isTheLastPointer = function(e) {
                            return this.indexOfPointer(e) === this.pointers.length - 1
                        }, t.prototype.firstStageObjectWithinRange = function(e, t, r) {
                            var i = Array.from(this.renderList).filter((function(i) {
                                return r.hitTest(i, e, t)
                            }));
                            return i.length > 0 ? i.sort((function(e, t) {
                                return e.zIndex - t.zIndex
                            }))[i.length - 1] : null
                        }, t.prototype.stageObjectsToReceiveTouchInRange = function(e, t, r) {
                            var i = this.firstStageObjectWithinRange(e, t, r);
                            return i ? [i, null] : [null]
                        }, t.prototype.bringToFront = function(e) {
                            var t;
                            this.renderList.forEach((function(e) {
                                (!t || e.zIndex > t) && (t = e.zIndex)
                            })), e.zIndex = t + 1, this.sortRenderList()
                        }, t.prototype.sendToBack = function(e) {
                            var t;
                            this.renderList.forEach((function(e) {
                                (!t || e.zIndex < t) && (t = e.zIndex)
                            })), e.zIndex = t - 1, this.sortRenderList()
                        }, t.prototype.sortRenderList = function() {
                            this.renderList.setNewOrder((function(e) {
                                var t = [];
                                return e.forEach((function(e) {
                                    var r = e.zIndex || 0;
                                    t[r] || (t[r] = []), t[r].push(e)
                                })), (t = t.filter((function(e) {
                                    return !!e
                                }))).forEach((function(e) {
                                    e.sort((function(e, t) {
                                        return e.createOrder - t.createOrder
                                    }))
                                })), t.reduce((function(e, t) {
                                    return e.concat(t)
                                }), [])
                            }))
                        }, t.prototype.break = function() {
                            this.stageObjects.forEach((function(e) {
                                return e.break()
                            }))
                        }, t.prototype.destroy = function(e) {
                            this.stageObjects.remove(e), e.destroy(), this.renderList.remove(e), this.context.findWithObjectID(o.HSObject.key, e.objectID).removeStageObject(e)
                        }, t.prototype.clone = function(e, r) {
                            var i = this;
                            if (void 0 === r && (r = 1), !(this.stageObjects.length >= t.MAX_CLONES)) {
                                r = Math.min(t.MAX_CLONES - this.stageObjects.length, r);
                                for (var s = this.context.findWithObjectID(o.HSObject.key, e.objectID), n = 0; n < r; n++) {
                                    var a = e.deepCopy();
                                    a.creationTick = this.tickCount, s.addStageObject(a), a.relatedCollisionRules = e.relatedCollisionRules, this.stageObjects.push(a), this.bindStageObject(a);
                                    var h = a.ruleGroups;
                                    this.activator.addCollisionPairsForStageObject(a), h.forEach((function(e) {
                                        i.activator.cacheRulesForStageObject(e), e.activateAllStageRulesForEventType(l.HSBlockType.EventOperatorEnterTheWorld)
                                    }))
                                }
                            }
                        }, t.prototype.activateTiltRules = function() {
                            var e;
                            switch (n.HSAccelerometerManager.tiltDirection()) {
                                case s.HSDirection.up:
                                    e = l.HSBlockType.EventOperatorTiltUp;
                                    break;
                                case s.HSDirection.down:
                                    e = l.HSBlockType.EventOperatorTiltDown;
                                    break;
                                case s.HSDirection.left:
                                    e = l.HSBlockType.EventOperatorTiltLeft;
                                    break;
                                case s.HSDirection.right:
                                    e = l.HSBlockType.EventOperatorTiltRight;
                                    break;
                                default:
                                    e = l.HSBlockType.None
                            }
                            this.activator.activateAllRulesForEventType(e)
                        }, t.prototype.activateShakeRules = function() {
                            n.HSAccelerometerManager.isShaking() && this.activator.activateAllRulesForEventType(l.HSBlockType.EventOperatorShake)
                        }, t.prototype.activateNoiseRules = function() {
                            var e = d.HSSoundManager.sharedInstance;
                            null != e && e.microphoneManager.hasLoudNoise() && this.activator.activateAllRulesForEventType(l.HSBlockType.EventOperatorLoudNoise)
                        }, Object.defineProperty(t.prototype, "touchIsDown", {
                            get: function() {
                                return 0 !== this.pointers.length
                            },
                            enumerable: !1,
                            configurable: !0
                        }), t.dirtySort = !1, t.promptsToExecute = [], t.stageHeight = 768, t.stageWidth = 1024, t.MAX_CLONES = 4096, t
                    }(u.HSStageObjectBase);
                window.HSStageScene = p
            },
            179: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSStageScript = void 0;
                var i = r(655),
                    s = r(4450),
                    n = r(3724),
                    o = r(4108),
                    a = r(5218),
                    h = function(e) {
                        function t(t, r) {
                            var i, s = this;
                            return (s = e.call(this, t) || this).script = r, null === (i = s.environment()) || void 0 === i || i.clear(), s
                        }
                        return i.__extends(t, e), t.prototype.scopeMode = function() {
                            return a.ScopeMode.Parent
                        }, t.prototype.reset = function() {
                            var e;
                            null === (e = this.environment()) || void 0 === e || e.clear(), this._blocks = i.__spreadArray([], i.__read(this.script.stageBlocks(this.parentNode())), !1), this.isImmediate = this.blocks().every((function(e) {
                                return e.isImmediate
                            }))
                        }, t.prototype.blocks = function() {
                            return this._blocks || (this._blocks = i.__spreadArray([], i.__read(this.script.stageBlocks(this.parentNode())), !1)), this._blocks
                        }, t.prototype.execute = function(stageRule) {
                            var executable = this.executableForStepSize(stageRule.maxStepSize(), stageRule);
                            executable.execute(stageRule), this._blocks = executable.blocksToExecuteLater, this.isImmediate = this._blocks.every((function(e) {
                                return e.isImmediate
                            })), executable.isImmediate && this.execute(stageRule)
                        }, t.prototype.isImmediatelyRecursive = function() {
                            return this.script.isImmediatelyRecursive()
                        }, t.prototype.executableForStepSize = function(e, t) {
                            if (!this.blocks().length) return new s.HSExecutable([], []);
                            var r = this.blocks().slice().reverse(),
                                i = r.pop(),
                                n = i.executableForStepSize(e, t, this);
                            return new s.HSExecutable(n.blocksToExecuteNow, n.blocksToExecuteLater.concat(r.reverse()), i.isImmediate)
                        }, t.prototype.deepCopy = function(e) {
                            return new t(e, this.script)
                        }, t.prototype.toString = function() {
                            return n.SourceFormatter.blocksToSrc(this._blocks)
                        }, t
                    }(o.HSStageObjectBase);
                t.HSStageScript = h, window.HSStageScript = h
            },
            9005: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.checkMatches = t.radiansToDegrees = t.degreesToRadians = t.getImageFromUri = t.exitFullscreen = t.hs_directionForMagnitudeAndPlane = t.hs_direction = t.hs_magnitude = t.hs_plane = t.HSDirection = t.HSMagnitude = t.HSPlane = t.benchmarkEnd = t.benchmarkStart = t.findLast = t.variance = t.mean = t.clamp = t.log = t.requestTextureFromApp = t.appRequestCache = t.appRequestCallbacks = t.onlyEmoji = t.hasEmoji = t.generateUUID = t.HSApp = t.isIOSApp = t.iOSApp = t.iOS = t.emoji = t.parseInstrumentName = t.MAX_FLOAT = void 0;
                var i = r(37);

                function s() {
                    return t.iOSApp || !!window.HS_IS_IOS_APP
                }
                t.MAX_FLOAT = 34028234663852886e22, t.parseInstrumentName = function(e) {
                    return "strings" === e && (e = "cello"), e.toLocaleLowerCase().replace(" ", "")
                }, t.emoji = window.emoji, t.emoji.basePath = "https://d2j12ek52gvmx9.cloudfront.net/emojis", t.iOS = /(iPhone|iPod|iPad).*AppleWebKit/i.test(navigator.userAgent), t.iOSApp = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent), t.isIOSApp = s;
                var n = t.HSApp = function() {
                    function e() {}
                    return e.forceIOSApp = function(e) {
                        t.iOSApp = e
                    }, e.initUserVariables = function(t, r) {
                        s() || 0 === t.length || 0 === r.length || (e.userVarID = e.userVarPrefix + t + "_" + r, e.initialUserVariables = JSON.parse(localStorage.getItem(e.userVarID) || "{}"))
                    }, e.storeUserVar = function(t, r) {
                        s() || (e.initialUserVariables[t] = r, localStorage.setItem(e.userVarID, JSON.stringify(e.initialUserVariables)))
                    }, e.sendToApp = function() {
                        for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
                        e.instance.sendToApp.apply(e.instance, t)
                    }, e.addResetCallback = function(t, r) {
                        e.resetCallback[t] = r
                    }, e.prototype.sendToApp = function(e, t, r) {
                        var i;
                        void 0 === r && (r = "hopscotch");
                        var s = window.webkit;
                        s && s.messageHandlers && s.messageHandlers[r].postMessage(((i = {})[e] = t, i))
                    }, e.reset = function() {
                        for (var t in i.HSAccelerometerManager.clear(), e.appCallbacks = {}, e.resetCallback) e.resetCallback.hasOwnProperty(t) && e.resetCallback[t]()
                    }, e.readFromAppOnce = function(t, r) {
                        e.appCallbacks[t] = r
                    }, e.readFromAppEternal = function(t, r) {
                        e.eternalCallbacks.push(t), e.appCallbacks[t] = r
                    }, e.executeCallback = function(t, r) {
                        e.appCallbacks[t] && (e.appCallbacks[t](r), -1 === e.eternalCallbacks.indexOf(t) && delete e.appCallbacks[t])
                    }, e.instance = new e, e.isRunning = !0, e.initialUserVariables = {}, e.userVarPrefix = "user_var_", e.eternalCallbacks = [], e.appCallbacks = {}, e.resetCallback = {}, e
                }();

                function o(e) {
                    return null != e && "" !== e && (/[\uD800-\uDBFF\uDC00-\uDFFF]/.test(e) || RegExp("".concat(t.emoji.regex.source)).test(e))
                }

                function a(e) {
                    return null != e && "" !== e && RegExp("^(".concat(t.emoji.regex.source, ")+$")).test(e)
                }
                t.generateUUID = function() {
                    var e = (new Date).getTime(),
                        t = "undefined" != typeof performance && performance.now && 1e3 * performance.now() || 0;
                    return "xxxxxxxx".replace(/[xy]/g, (function(r) {
                        var i = 16 * Math.random();
                        return e > 0 ? (i = (e + i) % 16 | 0, e = Math.floor(e / 16)) : (i = (t + i) % 16 | 0, t = Math.floor(t / 16)), ("x" === r ? i : 3 & i | 8).toString(16)
                    }))
                }, t.hasEmoji = o, t.onlyEmoji = a;
                var h = 0;

                function l(e, r) {
                    var i = JSON.stringify(e),
                        s = t.appRequestCache.get(i);
                    if (null != r && (null == s ? void 0 : s.updatedDate) === r) return s.promise;
                    var n = h++,
                        o = {
                            updatedDate: r || 0,
                            promise: new Promise((function(r) {
                                t.appRequestCallbacks[n] = r, window.webkit.messageHandlers.renderer.postMessage(Object.assign({}, e, {
                                    replyTo: "appRequestCallbacks[".concat(n, "]")
                                }))
                            })).then((function(e) {
                                return delete t.appRequestCallbacks[n], e
                            }))
                        };
                    return t.appRequestCache.set(i, o), t.appRequestCache.get(i).promise
                }

                function u() {
                    for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                    n.sendToApp("log", Array.prototype.join.call(arguments, " "))
                }

                function c(e, t, r) {
                    var i = Math.max(t, e);
                    return Math.min(i, r)
                }

                function d(e) {
                    return e.reduce((function(e, t) {
                        return e + t
                    }), 0) / e.length
                }

                function p(e) {
                    var t = d(e);
                    return e.reduce((function(e, r) {
                        return e + Math.pow(r - t, 2)
                    }), 0) / e.length
                }

                function f(e, t) {
                    for (var r = e.length - 1; r >= 0; r--)
                        if (t(e[r], r, e)) return e[r]
                }
                t.appRequestCallbacks = {}, t.appRequestCache = new Map, t.requestTextureFromApp = l, t.log = u, t.clamp = c, t.mean = d, t.variance = p, t.findLast = f;
                var m, g, y, _ = [],
                    v = 0;

                function S() {
                    v = performance.now()
                }

                function T() {
                    var e = performance.now();
                    if (_.length >= 100) {
                        for (var t = 0, r = 0; r < _.length; r++) t += _[r];
                        var i = document.getElementById("time").innerText;
                        i.length > 130 && (i = i.substring(50, 130));
                        var s = Math.round(t / _.length * 1e3) / 1e3;
                        document.getElementById("time").innerText = i + " " + s + "ms", _ = []
                    }
                    var n = e - v;
                    _.push(n)
                }

                function b(e, t) {
                    return Math.abs(e) >= Math.abs(t) ? m.horizontal : m.vertical
                }

                function E(e, t) {
                    return Math.abs(e) < t ? g.none : e > 0 ? g.positive : g.negative
                }

                function x(e, t, r) {
                    var i, s = b(e, t);
                    switch (s) {
                        case m.horizontal:
                            i = E(e, r);
                            break;
                        case m.vertical:
                            i = E(t, r)
                    }
                    return w(i, s)
                }

                function w(e, t) {
                    return e === g.positive && t === m.horizontal ? y.right : e === g.positive && t === m.vertical ? y.up : e === g.negative && t === m.horizontal ? y.left : e === g.negative && t === m.vertical ? y.down : null
                }

                function O() {}

                function A(e) {
                    var t = new Image;
                    return e.startsWith("data:") || (t.crossOrigin = "Anonymous"), new Promise((function(r, i) {
                        t.onload = function() {
                            return r(t)
                        }, t.onerror = i, t.src = e.replace(/-?200d/g, "")
                    }))
                }

                function P(e) {
                    return e * Math.PI / 180
                }

                function M(e) {
                    return e / Math.PI * 180
                }
                t.benchmarkStart = S, t.benchmarkEnd = T,
                    function(e) {
                        e[e.horizontal = 0] = "horizontal", e[e.vertical = 1] = "vertical"
                    }(m = t.HSPlane || (t.HSPlane = {})),
                    function(e) {
                        e[e.positive = 0] = "positive", e[e.negative = 1] = "negative", e[e.none = 2] = "none"
                    }(g = t.HSMagnitude || (t.HSMagnitude = {})),
                    function(e) {
                        e[e.up = 0] = "up", e[e.down = 1] = "down", e[e.left = 2] = "left", e[e.right = 3] = "right"
                    }(y = t.HSDirection || (t.HSDirection = {})), t.hs_plane = b, t.hs_magnitude = E, t.hs_direction = x, t.hs_directionForMagnitudeAndPlane = w, t.exitFullscreen = O, t.getImageFromUri = A, t.degreesToRadians = P, t.radiansToDegrees = M, Array.prototype.remove = function(e) {
                        var t = this.indexOf(e);
                        void 0 !== t && this.splice(t, 1)
                    }, t.checkMatches = function(e, t) {
                        return function(e, t) {
                            try {
                                return new RegExp(e, "gi")
                            } catch (t) {
                                return new RegExp(e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"))
                            }
                        }(t).test(e)
                    }, window.isIOSApp = s, window.HSPlane = m, window.HSMagnitude = g, window.HSDirection = y, window.hasEmoji = o, window.onlyEmoji = a, window.requestTextureFromApp = l, window.log = u, window.clamp = c, window.mean = d, window.variance = p, window.findLast = f, window.benchmarkStart = S, window.benchmarkEnd = T, window.hs_plane = b, window.hs_magnitude = E, window.hs_direction = x, window.hs_directionForMagnitudeAndPlane = w, window.exitFullscreen = O, window.getImageFromUri = A, window.degreesToRadians = P, window.radiansToDegrees = M, window.HSApp = n, window.appRequestCallbacks = t.appRequestCallbacks, window.MAX_FLOAT = t.MAX_FLOAT
            },
            7910: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(655).__importDefault(r(8745)),
                    s = function() {
                        function e(e, t) {
                            this.key = e, this.manager = t, this.isPressed = !1, this.isDown = !1, this.isReleased = !1, this.ctrl = !1, this.shift = !1, this.alt = !1
                        }
                        return e.prototype.update = function() {
                            this.isDown = this.manager.isDown(this.key), this.isPressed = this.manager.isPressed(this.key), this.isReleased = this.manager.isReleased(this.key), this.ctrl = this.manager.isDown(i.default.CTRL), this.shift = this.manager.isDown(i.default.SHIFT), this.alt = this.manager.isDown(i.default.ALT)
                        }, e.prototype.remove = function() {
                            this.manager.removeHotKey(this.key)
                        }, e
                    }();
                t.default = s
            },
            8745: (e, t) => {
                "use strict";
                var r;
                Object.defineProperty(t, "__esModule", {
                        value: !0
                    }),
                    function(e) {
                        e[e.BACKSPACE = 8] = "BACKSPACE", e[e.TAB = 9] = "TAB", e[e.ENTER = 13] = "ENTER", e[e.SHIFT = 16] = "SHIFT", e[e.PAUSE = 19] = "PAUSE", e[e.CTRL = 17] = "CTRL", e[e.ALT = 18] = "ALT", e[e.CAPS_LOCK = 20] = "CAPS_LOCK", e[e.ESCAPE = 27] = "ESCAPE", e[e.SPACE = 32] = "SPACE", e[e.PAGE_UP = 33] = "PAGE_UP", e[e.PAGE_DOWN = 34] = "PAGE_DOWN", e[e.END = 35] = "END", e[e.HOME = 36] = "HOME", e[e.LEFT = 37] = "LEFT", e[e.UP = 38] = "UP", e[e.RIGHT = 39] = "RIGHT", e[e.DOWN = 40] = "DOWN", e[e.PRINT_SCREEN = 44] = "PRINT_SCREEN", e[e.INSERT = 45] = "INSERT", e[e.DELETE = 46] = "DELETE", e[e._0 = 48] = "_0", e[e._1 = 49] = "_1", e[e._2 = 50] = "_2", e[e._3 = 51] = "_3", e[e._4 = 52] = "_4", e[e._5 = 53] = "_5", e[e._6 = 54] = "_6", e[e._7 = 55] = "_7", e[e._8 = 56] = "_8", e[e._9 = 57] = "_9", e[e.A = 65] = "A", e[e.B = 66] = "B", e[e.C = 67] = "C", e[e.D = 68] = "D", e[e.E = 69] = "E", e[e.F = 70] = "F", e[e.G = 71] = "G", e[e.H = 72] = "H", e[e.I = 73] = "I", e[e.J = 74] = "J", e[e.K = 75] = "K", e[e.L = 76] = "L", e[e.M = 77] = "M", e[e.N = 78] = "N", e[e.O = 79] = "O", e[e.P = 80] = "P", e[e.Q = 81] = "Q", e[e.R = 82] = "R", e[e.S = 83] = "S", e[e.T = 84] = "T", e[e.U = 85] = "U", e[e.V = 86] = "V", e[e.W = 87] = "W", e[e.X = 88] = "X", e[e.Y = 89] = "Y", e[e.Z = 90] = "Z", e[e.CMD = 91] = "CMD", e[e.CMD_RIGHT = 93] = "CMD_RIGHT", e[e.NUM_0 = 96] = "NUM_0", e[e.NUM_1 = 97] = "NUM_1", e[e.NUM_2 = 98] = "NUM_2", e[e.NUM_3 = 99] = "NUM_3", e[e.NUM_4 = 100] = "NUM_4", e[e.NUM_5 = 101] = "NUM_5", e[e.NUM_6 = 102] = "NUM_6", e[e.NUM_7 = 103] = "NUM_7", e[e.NUM_8 = 104] = "NUM_8", e[e.NUM_9 = 105] = "NUM_9", e[e.MULTIPLY = 106] = "MULTIPLY", e[e.ADD = 107] = "ADD", e[e.SUBTRACT = 109] = "SUBTRACT", e[e.DECIMAL_POINT = 110] = "DECIMAL_POINT", e[e.DIVIDE = 111] = "DIVIDE", e[e.F1 = 112] = "F1", e[e.F2 = 113] = "F2", e[e.F3 = 114] = "F3", e[e.F4 = 115] = "F4", e[e.F5 = 116] = "F5", e[e.F6 = 117] = "F6", e[e.F7 = 118] = "F7", e[e.F8 = 119] = "F8", e[e.F9 = 120] = "F9", e[e.F10 = 121] = "F10", e[e.F11 = 122] = "F11", e[e.F12 = 123] = "F12", e[e.NUM_LOCK = 144] = "NUM_LOCK", e[e.SCROLL_LOCK = 145] = "SCROLL_LOCK", e[e.SEMI_COLON = 186] = "SEMI_COLON", e[e.EQUAL = 187] = "EQUAL", e[e.COMMA = 188] = "COMMA", e[e.DASH = 189] = "DASH", e[e.PERIOD = 190] = "PERIOD", e[e.FORWARD_SLASH = 191] = "FORWARD_SLASH", e[e.OPEN_BRACKET = 219] = "OPEN_BRACKET", e[e.BACK_SLASH = 220] = "BACK_SLASH", e[e.CLOSE_BRACKET = 221] = "CLOSE_BRACKET", e[e.SINGLE_QUOTE = 222] = "SINGLE_QUOTE"
                    }(r || (r = {})), t.default = r
            },
            7818: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                });
                var i = r(655),
                    s = i.__importStar(r(8687)),
                    n = i.__importDefault(r(7910)),
                    o = i.__importDefault(r(8745)),
                    a = function(e) {
                        function t() {
                            var t = e.call(this) || this;
                            return t.isEnabled = !1, t.pressedKeys = [], t.releasedKeys = [], t.downKeys = {}, t.hotKeys = [], t.preventDefaultKeys = [], t
                        }
                        return i.__extends(t, e), t.prototype.enable = function() {
                            this.isEnabled || (this.isEnabled = !0, this._enableEvents())
                        }, t.prototype._enableEvents = function() {
                            window.addEventListener("keydown", this._onKeyDown.bind(this), !0), window.addEventListener("keyup", this._onKeyUp.bind(this), !0)
                        }, t.prototype.disable = function() {
                            this.isEnabled && (this.isEnabled = !1, this._disableEvents())
                        }, t.prototype._disableEvents = function() {
                            window.removeEventListener("keydown", this._onKeyDown, !0), window.removeEventListener("keyup", this._onKeyUp, !0)
                        }, t.prototype.setPreventDefault = function(e, t) {
                            if (void 0 === t && (t = !0), i = e, "[object Array]" === Object.prototype.toString.call(i))
                                for (var r = 0; r < e.length; r++) this.preventDefaultKeys[e[r]] = t;
                            else this.preventDefaultKeys[e] = t;
                            var i
                        }, t.prototype._onKeyDown = function(e) {
                            var t = e.which || e.keyCode;
                            this.preventDefaultKeys[t] && e.preventDefault(), this.isDown(t) || (this.downKeys[t] = 0, this.pressedKeys[t] = !0, this.emit("pressed", t))
                        }, t.prototype._onKeyUp = function(e) {
                            var t = e.which || e.keyCode;
                            this.preventDefaultKeys[t] && e.preventDefault(), this.isDown(t) && (this.pressedKeys[t] = !1, this.releasedKeys[t] = !0, delete this.downKeys[t], this.emit("released", t))
                        }, t.prototype.downTime = function(e) {
                            return this.downKeys[e] || 0
                        }, t.prototype.isDown = function(e) {
                            return this.downKeys.hasOwnProperty(e)
                        }, t.prototype.isPressed = function(e) {
                            return !!this.pressedKeys[e]
                        }, t.prototype.isReleased = function(e) {
                            return !!this.releasedKeys[e]
                        }, t.prototype.update = function(e) {
                            for (var t in void 0 === e && (e = 0), this.hotKeys.forEach((function(e) {
                                    return e.update()
                                })), this.downKeys) this.downKeys.hasOwnProperty(t) && (this.downKeys[t] += e, this.emit("down", t));
                            this.pressedKeys.length = 0, this.releasedKeys.length = 0
                        }, t.prototype.getHotKey = function(e) {
                            var t = this.hotKeys[e] || new n.default(e, this);
                            return this.hotKeys[e] = t, t
                        }, t.prototype.removeHotKey = function(e) {
                            this.hotKeys[e] && delete this.hotKeys[e]
                        }, t.shared = new t, t.Key = o.default, t
                    }(s.utils.EventEmitter);
                t.default = a
            },
            1296: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSVisualContext = void 0;
                var i = r(8938),
                    s = r(5074),
                    n = r(638),
                    o = t.HSVisualContext = function() {
                        function e(e, t) {
                            this.backgroundCanvas = e, this.drawingCanvas = t, this.backgroundContext = new n.HopscotchBackgroundContext(e, this), this.drawingContext = new s.HopscotchDrawingContext(t, this), this.collisionContext = new i.HSCollisionContext
                        }
                        return e.collisionResolution = 64, e
                    }();
                window.HSVisualContext = o
            },
            638: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HopscotchBackgroundContext = void 0;
                var i = r(1925),
                    s = r(8519),
                    n = function() {
                        function e(e, t) {
                            this.bgCanvas = e, this.visualContext = t, this.bgContext = this.layerFromCanvas2d(e), this.clear()
                        }
                        return e.prototype.layerFromCanvas2d = function(e) {
                            var t = this.canvasWidth(),
                                r = this.canvasHeight();
                            e.width = t, e.height = r;
                            var i = e.getContext("2d");
                            return i && (i.translate(0, r), i.scale(s.HSMain.dpi, -1 * s.HSMain.dpi)), i
                        }, e.prototype.canvasWidth = function() {
                            return i.HSStageScene.stageWidth * s.HSMain.dpi
                        }, e.prototype.canvasHeight = function() {
                            return i.HSStageScene.stageHeight * s.HSMain.dpi
                        }, e.prototype.setBackground = function(e) {
                            this.bgContext && (this.bgContext.fillStyle = e, this.bgContext.fillRect(0, 0, this.bgCanvas.width, this.bgCanvas.height))
                        }, e.prototype.clear = function() {
                            this.setBackground("white")
                        }, e
                    }();
                t.HopscotchBackgroundContext = n, window.HopscotchDrawingContext = n
            },
            5074: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HopscotchDrawingContext = void 0;
                var i = r(1925),
                    s = r(8519),
                    n = t.HopscotchDrawingContext = function() {
                        function e(e, t) {
                            this.drawingCanvas = e, this.visualContext = t, this.dwContext = this.layerFromCanvas2d(e), this.clear()
                        }
                        return e.prototype.layerFromCanvas2d = function(e) {
                            var t = this.canvasWidth(),
                                r = this.canvasHeight();
                            e.width = t, e.height = r;
                            var i = e.getContext("2d");
                            return i && (i.translate(0, r), i.scale(s.HSMain.dpi, -1 * s.HSMain.dpi)), i
                        }, e.prototype.canvasWidth = function() {
                            return i.HSStageScene.stageWidth * s.HSMain.dpi
                        }, e.prototype.canvasHeight = function() {
                            return i.HSStageScene.stageHeight * s.HSMain.dpi
                        }, e.prototype.clear = function() {
                            this.dwContext && this.dwContext.clearRect(0, 0, this.drawingCanvas.width, this.drawingCanvas.height)
                        }, e.prototype.drawLine = function(e, t) {
                            var r = this.dwContext;
                            if (r.beginPath(), r.moveTo.apply(r, [e.point.x, e.point.y]), e.point.x === t.point.x && e.point.y === t.point.y) switch (r.fillStyle = t.lineReference.lineColor, r.globalAlpha = t.lineReference.lineAlpha, t.lineReference.lineCap) {
                                case "square":
                                    r.fillRect(t.point.x - t.radius, t.point.y - t.radius, 2 * t.radius, 2 * t.radius);
                                    break;
                                case "butt":
                                    break;
                                case "round":
                                    r.arc(t.point.x, t.point.y, t.radius, 0, 2 * Math.PI), r.fill()
                            } else r.globalAlpha = t.lineReference.lineAlpha, r.lineWidth = 2 * t.radius, r.lineCap = t.lineReference.lineCap, r.strokeStyle = t.lineReference.lineColor, r.fillStyle = t.lineReference.lineColor, r.lineTo.apply(r, [t.point.x, t.point.y]), r.stroke();
                            r.globalAlpha = 1
                        }, e.MAX_TEXTURE_SIDE_LENGTH = 1024, e
                    }();
                window.HopscotchDrawingContext = n
            },
            1288: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSBoundingBox = void 0;
                var i = r(4958),
                    s = r(8362),
                    n = r(66),
                    o = t.HSBoundingBox = function() {
                        function e(e, t, r, i) {
                            void 0 === e && (e = 0), void 0 === t && (t = 0), void 0 === r && (r = 0), void 0 === i && (i = 0), this.centerX = e, this.centerY = t, this.halfWidth = r, this.halfHeight = i, this.vertices = [new n.Vec2, new n.Vec2, new n.Vec2, new n.Vec2], this.update(e, t, r, i)
                        }
                        return e.prototype.update = function(e, t, r, i) {
                            this.halfWidth = r, this.halfHeight = i, this.centerX = e, this.centerY = t, this.vertices[0].x = e - this.halfWidth, this.vertices[0].y = t - this.halfHeight, this.vertices[1].x = e + this.halfWidth, this.vertices[1].y = t - this.halfHeight, this.vertices[2].x = e + this.halfWidth, this.vertices[2].y = t + this.halfHeight, this.vertices[3].x = e - this.halfWidth, this.vertices[3].y = t + this.halfHeight
                        }, e.prototype.width = function() {
                            return 2 * this.halfWidth
                        }, e.prototype.height = function() {
                            return 2 * this.halfHeight
                        }, e.prototype.minX = function() {
                            return this.vertices[0].x
                        }, e.prototype.minY = function() {
                            return this.vertices[0].y
                        }, e.prototype.maxX = function() {
                            return this.vertices[2].x
                        }, e.prototype.maxY = function() {
                            return this.vertices[2].y
                        }, e.prototype.draw = function(e) {
                            var t = s.HSColor.rgb(0, 0, 0),
                                r = this.vertices.map((function(e) {
                                    return new i.HSLinePoint(e, 1, {
                                        lineColor: t,
                                        lineCap: "round",
                                        lineAlpha: 1
                                    })
                                }));
                            r.forEach((function(t, i) {
                                e.drawLine(t, r[(i + 1) % r.length])
                            }))
                        }, e.prototype.containsPoint = function(e, t) {
                            this.pointTestVecs || (this.pointTestVecs = [new n.Vec2, new n.Vec2, new n.Vec2]);
                            var r = new n.Vec2(e, t),
                                i = this.vertices[0],
                                s = this.vertices[1],
                                o = this.vertices[3],
                                a = this.pointTestVecs[0].subtract(s, i),
                                h = this.pointTestVecs[1].subtract(o, i),
                                l = this.pointTestVecs[2].subtract(r, i),
                                u = l.dot(a) / a.len(),
                                c = l.dot(h) / h.len();
                            return u > 0 && u < a.len() && c > 0 && c < h.len()
                        }, e.prototype.area = function() {
                            return this.width() * this.height()
                        }, e.prototype.overlapsWithOtherBoundingBox = function(e) {
                            return this.maxX() > e.minX() && this.minX() < e.maxX() && this.maxY() > e.minY() && this.minY() < e.maxY()
                        }, e.prototype.intersectionRectWithOtherBoundingBox = function(t) {
                            if (this.surroundingBox || (this.surroundingBox = new e), !this.overlapsWithOtherBoundingBox(t)) return e.zero;
                            var r = this.minX(),
                                i = this.minY(),
                                s = this.maxX(),
                                n = this.maxY(),
                                o = t.minX(),
                                a = t.minY(),
                                h = t.maxX(),
                                l = t.maxY(),
                                u = Math.max(r, o),
                                c = Math.max(i, a),
                                d = Math.min(s, h),
                                p = Math.min(n, l),
                                f = .5 * (u + d),
                                m = .5 * (c + p),
                                g = .5 * (d - u),
                                y = .5 * (p - c);
                            return this.surroundingBox.update(f, m, g, y), this.surroundingBox
                        }, e.zero = new e, e
                    }();
                window.HSBoundingBox = o
            },
            8980: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSCharacterTextureFactory = void 0;
                var i = r(655),
                    s = r(9134),
                    n = r(8232),
                    o = r(8362),
                    a = i.__importStar(r(8687)),
                    h = t.HSCharacterTextureFactory = function() {
                        function e() {}
                        return e.prototype.build = function(e, t) {
                            return Promise.resolve(this._build(t))
                        }, e.prototype._build = function(e) {
                            var t, r = document.getElementById(this.imageID(e)),
                                i = this.quantizedScale(r, e) || 1,
                                s = this.svgString(r, e),
                                n = e.originalWidth || 0,
                                o = e.originalHeight || 0;
                            if (r) {
                                n = parseFloat(r.getAttribute("width")) || n, o = parseFloat(r.getAttribute("height")) || o;
                                var h = new a.SVGResource(s, {
                                        scale: i
                                    }),
                                    l = new a.BaseTexture(h);
                                (t = a.Texture.from(l, {
                                    width: n,
                                    height: o,
                                    scaleMode: a.SCALE_MODES.LINEAR,
                                    resolution: i,
                                    target: a.TARGETS.TEXTURE_2D
                                })).baseTexture.width = n, t.baseTexture.height = o, t.baseTexture.resolution = i
                            } else t = null;
                            return t
                        }, e.prototype.quantizedScale = function(e, t) {
                            var r = 1,
                                i = Math.max(t.originalWidth, t.originalHeight);
                            if (e) {
                                var s = parseFloat(e.getAttribute("width")) || t.originalWidth,
                                    n = parseFloat(e.getAttribute("height")) || t.originalHeight;
                                i = Math.max(s, n), r = Math.max(t.originalWidth / s, t.originalHeight / n)
                            }
                            var o = Math.abs(t.sizePercentWidth),
                                a = Math.abs(t.sizePercentHeight),
                                h = Math.max(o, a),
                                l = i * Math.max(Math.ceil(.01 * h), 1) * r,
                                u = Math.round(Math.max(l / 100, 1) * t.baseObjectScale);
                            l < 100 ? u = 1 : l < 150 && (u = 2);
                            var c = Math.floor(1024 / i);
                            return Math.min(u, c)
                        }, e.prototype.buildAll = function(e, t) {
                            for (var r = [], i = t.willChangeCostume ? 4 : 1, s = 0; s < i; s++) t.animationNumber = s, r.push(this._build(t));
                            return Promise.resolve(r)
                        }, e.prototype.imageID = function(e) {
                            var t = e.type || 0,
                                r = n.HSObjectType[t];
                            return r[0].toUpperCase() + r.slice(1) + e.animationNumber + ".svg"
                        }, e.prototype.svgString = function(e, t) {
                            var r = "";
                            if (e) {
                                e.style.fill = o.HSColor.rgbWhiteColor;
                                var i = this.quantizedScale(e, t);
                                e.setAttribute("hsScale", "" + i);
                                var n = s.HSView.xmlSerializer.serializeToString(e);
                                r = window.btoa(n)
                            }
                            return "data:image/svg+xml;base64," + r
                        }, e.instance = new e, e
                    }();
                window.HSCharacterTextureFactory = h
            },
            8938: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSCollisionContext = t.makeDebugCanvas = void 0;
                var i = r(1925),
                    s = r(1296),
                    n = r(8232),
                    o = r(5189);
                t.makeDebugCanvas = function(e, t) {
                    var r = document.createElement("canvas");
                    return r.style.position = "fixed", r.style.top = e + "px", r.style.left = t + "px", r.style.border = "1px solid blue", r.style.zIndex = "99999", document.body.appendChild(r), r.width = s.HSVisualContext.collisionResolution, r.height = s.HSVisualContext.collisionResolution, r
                };
                var a = t.HSCollisionContext = function() {
                    function e() {
                        this.numberOfPixelCollisions = 0, this.manager = new o.CollisionManager, this.canvas1 = document.createElement("canvas"), this.canvas2 = document.createElement("canvas")
                    }
                    return e.prototype.hitTest = function(e, t, r) {
                        if (e.isInvisible()) return !1;
                        var i = this.boundingBoxForObject(e);
                        if (i.containsPoint(t, r)) {
                            if (e.type === n.HSObjectType.text) return !0;
                            var s = this.generatePixelTestData(this.canvas1, e, i, i),
                                o = s.width / (i.maxX() - i.minX()),
                                a = s.height / (i.maxY() - i.minY()),
                                h = (t - i.minX()) * o,
                                l = s.height - (r - i.minY()) * a;
                            return t = Math.round(h), r = Math.round(l), this.pixelCoordinateHasAlpha(t, r, s)
                        }
                        return !1
                    }, e.prototype.tick = function(e) {
                        this.manager.tick(Array.from(e))
                    }, e.prototype.collisionTest = function(e, t) {
                        return t.type === n.HSObjectType.edgeOfScreen ? this.objectIsTouchingEdgeOfScreen(e) : e.type === n.HSObjectType.edgeOfScreen ? this.objectIsTouchingEdgeOfScreen(t) : this.objectsAreColliding(e, t)
                    }, e.prototype.objectsAreColliding = function(e, t) {
                        return this.manager.existsCollisionBetweenStageObjects(e, t)
                    }, e.prototype.objectIsTouchingEdgeOfScreen = function(e) {
                        var t = this.boundingBoxForObject(e);
                        if (0 === t.area()) return !1;
                        var r = t.centerX,
                            s = t.centerY;
                        return r <= 0 || r >= i.HSStageScene.stageWidth || s <= 0 || s >= i.HSStageScene.stageHeight
                    }, e.prototype.pixelCoordinateHasAlpha = function(e, t, r) {
                        var i = 4 * (t * r.width + e) + 3;
                        return r.data[i] > 0
                    }, e.prototype.boundingBoxForObject = function(e) {
                        return e.boundingBox()
                    }, e.prototype.generatePixelTestData = function(e, t, r, i) {
                        var s = (e = this.prepareCanvasForPixelTest(e, t, r, i)).getContext("2d"),
                            n = e.width / r.width(),
                            o = e.height / r.height(),
                            a = Math.round((i.minX() - r.minX()) * n),
                            h = Math.round((r.maxY() - i.maxY()) * o),
                            l = Math.max(Math.ceil((i.maxX() - i.minX()) * n), 1),
                            u = Math.max(Math.ceil((i.maxY() - i.minY()) * o), 1);
                        return s.getImageData(a, h, l, u)
                    }, e.prototype.prepareCanvasForPixelTest = function(e, t, r, i) {
                        var s = t.imageForCollision();
                        if (!s) return e;
                        var n = function(e, t, r) {
                            var i = Math.cos(r),
                                s = Math.sin(r);
                            return s < 0 && (s = -s), i < 0 && (i = -i), {
                                width: t * s + e * i,
                                height: t * i + e * s
                            }
                        }(Math.ceil(s.width * r.halfWidth / r.halfWidth), Math.ceil(s.height * r.halfHeight / r.halfHeight), t.headingInRadians());
                        e.width = Math.ceil(n.width), e.height = Math.ceil(n.height);
                        var o = e.getContext("2d");
                        o.imageSmoothingEnabled = !1, o.oImageSmoothingEnabled = !1, o.msImageSmoothingEnabled = !1, o.mozImageSmoothingEnabled = !1, o.webkitImageSmoothingEnabled = !1, o.clearRect(0, 0, e.width, e.height);
                        var a = e.width / 2,
                            h = e.height / 2;
                        return o.translate(a, h), o.rotate(-t.headingInRadians()), t.isFlipped && o.scale(-1, 1), s.width * s.height == 0 || (o.drawImage(s, -s.width / 2, -s.height / 2), o.setTransform(1, 0, 0, 1, 0, 0)), e
                    }, e.PIXEL_TESTING_THRESHOLD = 10, e
                }();
                window.HSCollisionContext = a
            },
            6317: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSCollisionImageFactory = void 0;
                var i = r(1296);
                HTMLCanvasElement.prototype.unscaledWidth = function() {
                    return this.width
                }, HTMLCanvasElement.prototype.unscaledHeight = function() {
                    return this.height
                }, HTMLImageElement.prototype.unscaledWidth = function() {
                    return this.naturalWidth
                }, HTMLImageElement.prototype.unscaledHeight = function() {
                    return this.naturalHeight
                };
                var s = function() {
                    function e() {}
                    return e.prototype.image = function(e) {
                        if (this._image) return this._image;
                        if (!e) return null;
                        var t = document.createElement("canvas"),
                            r = t.getContext("2d"),
                            s = e.unscaledWidth(),
                            n = e.unscaledHeight(),
                            o = i.HSVisualContext.collisionResolution,
                            a = this.getScaledImageDimensions({
                                width: s,
                                height: n
                            }, Math.pow(o, 2)),
                            h = a.width,
                            l = a.height;
                        return t.width = h, t.height = l, r.drawImage(e, 0, 0, s, n, 0, 0, h, l), this._image = t, t
                    }, e.prototype.getScaledImageDimensions = function(e, t) {
                        var r = Math.max(Math.sqrt(e.width * e.height / t), 1);
                        return {
                            width: Math.round(e.width / r),
                            height: Math.round(e.height / r)
                        }
                    }, e
                }();
                t.HSCollisionImageFactory = s, window.HSCollisionImageFactory = s
            },
            8935: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSImageTextureFactory = void 0;
                var i = r(655),
                    s = r(9005),
                    n = i.__importStar(r(8687)),
                    o = t.HSImageTextureFactory = function() {
                        function e() {
                            this.prefetchedImageCache = new Map
                        }
                        return e.prototype.build = function(e, t) {
                            var r, i = null === (r = this.prefetchedImageCache.get(t.imageName)) || void 0 === r ? void 0 : r.promise;
                            return i ? i.then((function(e) {
                                return n.Texture.from(e)
                            })) : Promise.reject(null)
                        }, e.prototype.buildAll = function(e, t) {
                            return this.build(e, t).then((function(e) {
                                return [e]
                            }))
                        }, e.prototype.prefetchImage = function(e) {
                            var t = this;
                            if (e) {
                                var r = e.fileName,
                                    i = this.prefetchedImageCache.get(r);
                                if (null == e.updatedDate || (null == i ? void 0 : i.updatedDate) !== e.updatedDate) {
                                    var n = this.getImageUrl(e).then(s.getImageFromUri).then((function(r) {
                                        return t.resizeImage(r, e.width, e.height)
                                    })).catch((function(e) {
                                        return console.log("Couldn't download the image. ", e), null
                                    }));
                                    this.prefetchedImageCache.set(r, {
                                        updatedDate: e.updatedDate,
                                        promise: n
                                    })
                                }
                            }
                        }, e.prototype.resizeImage = function(e, t, r) {
                            return e.width = t, e.height = r, Promise.resolve(e)
                        }, e.prototype.getImageUrl = function(e) {
                            var t = e.fileName,
                                r = e.updatedDate;
                            return (Object.prototype.hasOwnProperty.call(window, "BASE_IMAGE_URL") ? this.getImageUrlFromBaseUrl : this.getImageUrlFromApp)(t, r)
                        }, e.prototype.getImageUrlFromBaseUrl = function(e, t) {
                            var r = BASE_IMAGE_URL + e,
                                i = -1 !== r.indexOf("?") ? "&" : "?";
                            return Promise.resolve(r + i + "cache=" + t)
                        }, e.prototype.getImageUrlFromApp = function(e, t) {
                            return (0, s.requestTextureFromApp)({
                                fileName: e
                            }, t).then((function(e) {
                                return e.dataURI
                            }))
                        }, e.instance = new e, e
                    }();
                window.HSImageTextureFactory = o
            },
            6745: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSGeometricShapeTextNode = t.HSEmojiTextNode = t.HSTextNode = t.HSTextJustify = t.HSLineBox = void 0;
                var i, s = r(655),
                    n = r(9005),
                    o = r(8519),
                    a = r(6595),
                    h = r(8362),
                    l = function() {
                        this.width = 0
                    };
                t.HSLineBox = l,
                    function(e) {
                        e[e.center = 1] = "center", e[e.left = 2] = "left"
                    }(i = t.HSTextJustify || (t.HSTextJustify = {}));
                var u = t.HSTextNode = function() {
                        function e(e, t) {
                            return this.text = e, this.kind = t, t === a.HSTextNodeKind.emoji ? new c(e) : t === a.HSTextNodeKind.geometricShape ? new d(e) : void 0
                        }
                        return e.prototype.prevWhitespace = function() {
                            return this.kind === a.HSTextNodeKind.whitespace ? this : this.kind !== a.HSTextNodeKind.newline && this.prev ? this.prev.prevWhitespace() : null
                        }, e.prototype.tail = function() {
                            return this.next ? this.next.tail() : this
                        }, e.concat = function(e, t) {
                            if (e) {
                                var r = e.tail();
                                r.next = t, t && (t.prev = r)
                            }
                            return e || t
                        }, e.prototype.concat = function(t) {
                            return e.concat(this, t)
                        }, e.prototype.replace = function(e) {
                            e.prev = this.prev, e.prev && (e.prev.next = e);
                            var t = e.tail();
                            return t.next = this.next, t.next && (t.next.prev = t), e
                        }, e.prototype.flow = function(t, r, s) {
                            s = s || i.center;
                            var n = this,
                                o = {
                                    width: 0,
                                    height: 0
                                };

                            function h() {
                                var r = n.x + n.measure(t).width,
                                    i = n.y + e.LINE_HEIGHT;
                                o = {
                                    width: Math.max(r, o.width),
                                    height: i
                                }, n = n.next
                            }
                            for (; n;) {
                                var u = n.measure(t);
                                if (n.prev) {
                                    var c = n.prev.measure(t).width;
                                    n.x = n.prev.x + c, n.y = n.prev.y, n.lineBox = n.prev.lineBox
                                } else n.x = 0, n.y = 0, n.lineBox = new l;
                                if (n.lineBox.width = n.x + u.width, n.kind === a.HSTextNodeKind.newline) n.y += e.LINE_HEIGHT, n.x = 0, n.lineBox = new l, h();
                                else if (n.x + u.width > r) {
                                    var d = n.prevWhitespace();
                                    if (d) {
                                        var p = new e("\n", a.HSTextNodeKind.newline);
                                        n = d.replace(p)
                                    } else n = n.replace(n.forceLineBreak(t, r))
                                } else h()
                            }
                            return s === i.center && this.center(o), o
                        }, e.prototype.center = function(e) {
                            this.x += (e.width - this.lineBox.width) / 2, this.next && this.next.center(e)
                        }, e.prototype.measure = function(e) {
                            return this.kind === a.HSTextNodeKind.newline ? {
                                width: 0
                            } : e.measureText(this.text)
                        }, e.prototype.allNodes = function() {
                            return (this.next ? this.next.allNodes() : []).concat(this)
                        }, e.prototype.draw = function(e) {
                            return Promise.all(this.allNodes().map((function(t) {
                                return t.drawNode(e)
                            })))
                        }, e.prototype.drawNode = function(e) {
                            return e.fillText(this.text, this.x, this.y), null
                        }, e.prototype.forceLineBreak = function(t, r) {
                            for (var i = "", s = this.text, n = 0; n !== s.length; ++n) {
                                var o = i + s[n];
                                if (t.measureText(o).width > r) {
                                    var h = e.parse(i).head,
                                        l = new e("\n", a.HSTextNodeKind.newline);
                                    h.concat(l);
                                    var u = new e(this.text.substr(i.length), this.kind);
                                    return l.concat(u), h
                                }
                                i = o
                            }
                            return this
                        }, e.prototype.toString = function() {
                            return this.text + (this.next ? this.next.toString() : "")
                        }, e.fromString = function(t) {
                            return e.parse(t).head
                        }, e.parse = function(t) {
                            var r, i;
                            return a.HSTokenizer.tokenize(t).forEach((function(t) {
                                var s = new e(t.text, t.kind);
                                e.concat(r, s), r = s, i || (i = r)
                            })), {
                                head: i,
                                tail: r
                            }
                        }, e.MAX_LINE_WIDTH = 600, e.LINE_HEIGHT = 55, e
                    }(),
                    c = t.HSEmojiTextNode = function(e) {
                        function t(t) {
                            var r = e.call(this, t, null) || this;
                            return r.kind = a.HSTextNodeKind.emoji, r
                        }
                        return s.__extends(t, e), t.prototype.drawNode = function(r) {
                            var i = this;
                            return t.getImage({
                                text: this.text,
                                color: h.HSColor.hsbStringFromRgbString(r.fillStyle)
                            }).then((function(e) {
                                var s = (0, n.isIOSApp)() ? e.width : t.WIDTH,
                                    o = (0, n.isIOSApp)() ? e.height : t.HEIGHT;
                                r.drawImage(e, i.x, i.y, s, o)
                            })).catch((function(t) {
                                return e.prototype.drawNode.call(i, r)
                            }))
                        }, t.getImageInfo = function(e) {
                            return (0, n.isIOSApp)() ? (0, n.requestTextureFromApp)({
                                type: "emoji",
                                props: e
                            }).then((function(e) {
                                return {
                                    dataURI: e.dataURI,
                                    scaleFactor: window.devicePixelRatio
                                }
                            })) : Promise.resolve({
                                dataURI: n.emoji.getImage(e.text),
                                scaleFactor: 1
                            })
                        }, t.getImage = function(e) {
                            return this.getImageInfo(e).then((function(e) {
                                var t = e.dataURI;
                                return o.HSMain.HS_EMOJI_HOST && (t = t.replace("/assets", o.HSMain.HS_EMOJI_HOST)), (0, n.getImageFromUri)(t).then((function(t) {
                                    return t.width /= e.scaleFactor, t.height /= e.scaleFactor, t
                                }))
                            }))
                        }, t.prototype.measure = function(e) {
                            return {
                                width: t.WIDTH
                            }
                        }, t.prototype.forceLineBreak = function(e, r) {
                            var i = u.fromString("\n"),
                                s = new t(this.text);
                            return i.concat(s), i
                        }, t.HEIGHT = 40, t.WIDTH = 40, t
                    }(u),
                    d = t.HSGeometricShapeTextNode = function(e) {
                        function t(t) {
                            var r = e.call(this, t, null) || this;
                            return r.kind = a.HSTextNodeKind.geometricShape, r.kind = a.HSTextNodeKind.geometricShape, r
                        }
                        return s.__extends(t, e), t.prototype.drawNode = function(e) {
                            var r = e.font,
                                i = +e.font.match(/^\d*/),
                                s = Math.round(i * this.getScaleFactor()),
                                n = this.measure(e).width;
                            e.font = "".concat(s, "px ").concat(t.FONT_FAMILIES.join(", "));
                            var o = e.measureText(this.text).width;
                            return e.fillText(this.text, this.x + (n - o) / 2, this.y + n - o + 1.5), e.font = r, Promise.resolve(null)
                        }, t.prototype.getScaleFactor = function() {
                            return "" === this.text ? .85 : .81
                        }, t.prototype.measure = function(e) {
                            var r = e.font,
                                i = +e.font.match(/^\d*/);
                            e.font = "".concat(i, "px ").concat(t.FONT_FAMILIES.join(", "));
                            var s = e.measureText(this.text);
                            return e.font = r, s
                        }, t.FONT_FAMILIES = ["Avenir-Book", "STIXGeneral", "sans-serif"], t
                    }(u);
                window.HSLineBox = l, window.HSTextJustify = i, window.HSTextNode = u, window.HSEmojiTextNode = c, window.HSGeometricShapeTextNode = d
            },
            8539: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSTextTextureFactory = void 0;
                var i = r(655),
                    s = r(6745),
                    n = r(5074),
                    o = r(9005),
                    a = r(8362),
                    h = i.__importStar(r(8687)),
                    l = t.HSTextTextureFactory = function() {
                        function e() {}
                        return e.setFont = function(t, r) {
                            t.font = "".concat(r / 2, "px ").concat(e.FONT_FAMILIES.join(", ")), t.textAlign = "left", t.textBaseline = "top"
                        }, e.prototype.key = function(e) {
                            return JSON.stringify({
                                text: e.text,
                                color: e.color
                            })
                        }, e.prototype.buildAll = function(e, t) {
                            return this.build(e, t).then((function(e) {
                                return [e]
                            })).catch((function(e) {
                                return []
                            }))
                        }, e.prototype.build = function(e, t) {
                            var r = s.HSTextNode.fromString(t.text);
                            if (!r) return Promise.reject(null);
                            if (!(e = this.canvas(e, t, r))) return Promise.reject(null);
                            var i = e.getContext("2d");
                            return r.draw(i).then((function(t) {
                                return h.Texture.from(e)
                            }))
                        }, e.scaleUp = function() {
                            return n.HopscotchDrawingContext.MAX_TEXTURE_SIDE_LENGTH / s.HSTextNode.MAX_LINE_WIDTH
                        }, e.prototype.canvas = function(t, r, i) {
                            var n = t.getContext("2d");
                            e.setFont(n, r.fontSize);
                            var h = r.text,
                                l = a.HSColor.rgbWhiteColor;
                            (0, o.hasEmoji)(h) && (l = r.color);
                            var u = i.flow(n, s.HSTextNode.MAX_LINE_WIDTH);
                            if (0 === u.width || 0 === u.height) return null;
                            var c = r.sizePercentWidth / 100 || 1,
                                d = r.sizePercentHeight / 100 || 1,
                                p = e.scaleUp(),
                                f = Math.min(u.width * p * c, 4096),
                                m = Math.min(u.height * p * d, 4096);
                            return t.width = f, t.height = m, e.setFont(n, r.fontSize), n.scale(f / u.width, m / u.height), n.fillStyle = a.HSColor.rgbStringFromHSBString(l), t
                        }, e.FONT_FAMILIES = ["Avenir-Book", "Hiragino Sans", "sans-serif", "AppleSymbols"], e.instance = new e, e.textureCache = {}, e
                    }();
                window.HSTextTextureFactory = l
            },
            6595: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSTokenizer = t.HSToken = t.HSTextNodeKind = void 0;
                var i, s = r(9005);
                ! function(e) {
                    e[e.text = 0] = "text", e[e.whitespace = 1] = "whitespace", e[e.newline = 2] = "newline", e[e.emoji = 3] = "emoji", e[e.geometricShape = 4] = "geometricShape"
                }(i = t.HSTextNodeKind || (t.HSTextNodeKind = {}));
                var n = function(e, t) {
                    this.text = e, this.kind = t
                };
                t.HSToken = n;
                var o = t.HSTokenizer = function() {
                    function e() {}
                    return e.hasDrawableTokens = function(t) {
                        return null != t && /\S/.test(t) && !e.ONLY_VARIATION_SELECTORS.test(t)
                    }, e.tokenize = function(t) {
                        if (this.tokenizedStringsCache.has(t)) return this.tokenizedStringsCache.get(t);
                        var r, o = [],
                            a = 0,
                            h = null;
                        for (r = 0; r < t.length; r++)
                            if (" " === t[r] || "\t" === t[r]) h !== i.whitespace && (r > a && o.push(new n(t.substring(a, r), h)), a = r, h = i.whitespace);
                            else if ("\n" === t[r]) r > a && h !== i.whitespace && o.push(new n(t.substring(a, r), h)), a = r, h = i.newline;
                        else if (e.ZERO_WIDTH_JOINER.test(t[r]) && h === i.emoji) {
                            if (r += 1, this.isEmojiStartIndex(t, r)) {
                                var l = t.slice(r, r + 5).match(s.emoji.regex);
                                l && l[0] && (r += l[0].length - 1)
                            }
                        } else if (e.ONLY_VARIATION_SELECTORS.test(t[r]) && h !== i.text) {
                            if (r > a) {
                                var u = r;
                                h === i.emoji && (u = r + 1), o.push(new n(t.substring(a, u), h))
                            }
                            a = r + 1, h = null
                        } else if (this.isEmojiStartIndex(t, r)) {
                            r > a && o.push(new n(t.substring(a, r), h)), a = r, h = i.emoji;
                            var c = 5;
                            this.isUnicodeEmojiStartIndex(t, r) && (c = 2);
                            var d = t.slice(r, r + c),
                                p = e.emojiMatch(d);
                            p && (r += d.indexOf(p[0]) + (p[0].length - 1))
                        } else !s.iOS && e.GEOMETRIC_SHAPES.test(t[r]) ? (r > a && o.push(new n(t.substring(a, r), h)), a = r, h = i.geometricShape) : h !== i.text && (r > a && o.push(new n(t.substring(a, r), h)), a = r, h = i.text);
                        return r > a && null !== h && o.push(new n(t.substring(a, r), h)), this.clearTokenCacheIfNecessary(), this.tokenizedStringsCache.set(t, o), o
                    }, e.clearTokenCacheIfNecessary = function() {
                        this.tokenizedStringsCache.size > 30 && this.tokenizedStringsCache.delete(this.tokenizedStringsCache.keys().next().value)
                    }, e.isEmojiStartIndex = function(t, r) {
                        var i = t.slice(r, r + 5);
                        return e.startsWithEmojiRegex.test(i) || e.secondCharIsSurrogate.test(i)
                    }, e.isUnicodeEmojiStartIndex = function(t, r) {
                        var i = t.slice(r, r + 5);
                        return !(e.startsWithEmojiRegex.test(i) || e.fitzRegex.test(i))
                    }, e.emojiMatch = function(t) {
                        return t.match(s.emoji.regex) || t.match(e.secondCharIsSurrogate)
                    }, e.rangeOfFirstEmojiStartingAtIndex = function(e, t) {
                        var r = e.slice(t, t + 7).match(/[\ufe00-\ufe0f\u200d\u2640]$/);
                        return 0 === r.length ? t : e.indexOf(r[0]) + 1
                    }, e.ONLY_VARIATION_SELECTORS = /^[\ufe00-\ufe0f]*$/, e.ZERO_WIDTH_JOINER = /[\u200d]/, e.GEOMETRIC_SHAPES = /[\u25A0-\u25CF\u25E0-\u25E1\u25E6-\u25FF]/, e.tokenizedStringsCache = new Map, e.highSurrogates = "\ud800-\udbff", e.lowSurrogates = String.fromCharCode(56320) + "-" + String.fromCharCode(57343), e.surrogateRegex = RegExp("[".concat(e.lowSurrogates).concat(e.highSurrogates, "]")), e.secondCharIsSurrogate = RegExp("^.[".concat(e.lowSurrogates, "]")), e.startsWithEmojiRegex = RegExp("^".concat(s.emoji.regex.source)), e.fitzpatricks = String.fromCharCode(55356) + "[" + String.fromCharCode(57088) + "-" + String.fromCharCode(57343) + "]", e.fitzRegex = RegExp("".concat(e.fitzpatricks)), e
                }();
                window.HSTextNodeKind = i, window.HSToken = n, window.HSTokenizer = o
            },
            9134: (e, t, r) => {
                "use strict";
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.HSView = void 0;
                var i = r(655),
                    s = r(6595),
                    n = r(9005),
                    o = r(8539),
                    a = r(8935),
                    h = r(8980),
                    l = r(8232),
                    u = r(8362),
                    c = i.__importStar(r(8687)),
                    d = t.HSView = function() {
                        function e(e) {
                            this.props = e, this.sprite = new c.Sprite, this.canvas = null, this.textureExists = !1, this.onTextureBuild = null, this.buildTexture(), this.update(this.props)
                        }
                        return e.prototype.factory = function() {
                            return this.shouldDrawText() ? o.HSTextTextureFactory.instance : this.canDrawImage() ? a.HSImageTextureFactory.instance : h.HSCharacterTextureFactory.instance
                        }, e.prototype.imageSource = function() {
                            return this.sprite ? this.sprite.texture.baseTexture.resource.source : null
                        }, e.prototype.bounds = function() {
                            if (this.sprite) return this.sprite.getBounds()
                        }, e.prototype.width = function() {
                            return this.sprite.texture.baseTexture.width * this.sprite.scale.x
                        }, e.prototype.height = function() {
                            return this.sprite.texture.baseTexture.height * this.sprite.scale.y
                        }, e.prototype.shouldDrawText = function() {
                            return s.HSTokenizer.hasDrawableTokens(this.props.text)
                        }, e.prototype.canDrawImage = function() {
                            return !!this.props.imageName
                        }, e.prototype.buildTexture = function() {
                            var e = this;
                            this.createCanvasIfNeeded();
                            var t = this;
                            return this.hasEmoji = !!this.shouldDrawText() && (0, n.hasEmoji)(this.props.text), this.factory().build(this.canvas, this.props).then((function(r) {
                                return e.shouldDrawText() && r.update(), t.sprite.texture = r, t.sprite.anchor.x = .5, t.sprite.anchor.y = .5, t.originalWidth = t.sprite.texture.baseTexture.width, t.originalHeight = t.sprite.texture.baseTexture.height, t.textureExists = !0, t.onBuildCallback(), r
                            })).catch((function(e) {
                                (0, n.log)("error in building texture", e, t.props)
                            }))
                        }, e.prototype.onBuildCallback = function() {
                            var e = this.onTextureBuild;
                            this.onTextureBuild = null, e && e()
                        }, e.prototype.createCanvasIfNeeded = function() {
                            this.canvas || this.shouldDrawText() && (this.canvas = document.createElement("canvas"))
                        }, e.prototype.buildAllTextures = function() {
                            return this.factory().buildAll(this.canvas, this.props)
                        }, e.prototype.getOriginalScale = function(e, t, r) {
                            return isNaN(e) ? r === l.HSObjectType.text ? 1 / o.HSTextTextureFactory.scaleUp() : 1 : e / t
                        }, e.prototype.getSpriteScale = function(e, t, r, i, s, n) {
                            void 0 === n && (n = !1);
                            var o = this.getOriginalScale(t, e, s),
                                a = r * i * .01 * this.scaleForObjectType(s),
                                h = Math.abs(a),
                                l = a / h,
                                u = Math.min(h, 1024) * l * o;
                            return Math.round(e * u) / e * (n ? -1 : 1)
                        }, e.prototype.update = function(e) {
                            var t = this.props;
                            if (this.props = e, this.needsNewTexture(t) && this.buildTexture(), this.textureExists) {
                                var r = this.sprite.texture.baseTexture.width,
                                    i = this.sprite.texture.baseTexture.height;
                                this.sprite.scale.x = this.getSpriteScale(r, e.originalWidth, e.baseObjectScale, e.sizePercentWidth, this.props.type, e.isFlipped), this.sprite.scale.y = this.getSpriteScale(i, e.originalHeight, e.baseObjectScale, e.sizePercentHeight, this.props.type, !1), this.sprite.position.x = Math.round(e.x), this.sprite.position.y = Math.round(e.stageHeight - e.y), this.sprite.alpha = e.opacity, this.sprite.rotation = -1 * e.headingInRadians;
                                var s = e.color;
                                this.hasEmoji && (s = u.HSColor.rgbWhiteColor), this.sprite.tint = u.HSColor.hexToTint(s)
                            }
                        }, e.prototype.needsNewTexture = function(e) {
                            return e.text !== this.props.text || this.quantizedScaleY(e) !== this.quantizedScaleY(this.props) || this.quantizedScaleX(e) !== this.quantizedScaleX(this.props) || e.animationNumber !== this.props.animationNumber || e.type !== this.props.type || e.imageName !== this.props.imageName || e.color !== this.props.color && !(0, n.onlyEmoji)(e.text) && (0, n.hasEmoji)(e.text)
                        }, e.prototype.quantizedScaleY = function(e) {
                            var t = e.sizePercentHeight || 100;
                            return Math.ceil(.01 * t)
                        }, e.prototype.quantizedScaleX = function(e) {
                            var t = e.sizePercentWidth || 100;
                            return Math.ceil(.01 * t)
                        }, e.prototype.scaleForObjectType = function(e) {
                            return e === l.HSObjectType.hexagon ? 1.05 : 1
                        }, e.xmlSerializer = new XMLSerializer, e.svgCache = {}, e
                    }();
                window.HSView = d
            },
            655: (e, t, r) => {
                "use strict";
                r.r(t), r.d(t, {
                    __assign: () => n,
                    __asyncDelegator: () => w,
                    __asyncGenerator: () => x,
                    __asyncValues: () => O,
                    __await: () => E,
                    __awaiter: () => f,
                    __classPrivateFieldGet: () => R,
                    __classPrivateFieldIn: () => B,
                    __classPrivateFieldSet: () => I,
                    __createBinding: () => g,
                    __decorate: () => a,
                    __esDecorate: () => l,
                    __exportStar: () => y,
                    __extends: () => s,
                    __generator: () => m,
                    __importDefault: () => C,
                    __importStar: () => M,
                    __makeTemplateObject: () => A,
                    __metadata: () => p,
                    __param: () => h,
                    __propKey: () => c,
                    __read: () => v,
                    __rest: () => o,
                    __runInitializers: () => u,
                    __setFunctionName: () => d,
                    __spread: () => S,
                    __spreadArray: () => b,
                    __spreadArrays: () => T,
                    __values: () => _
                });
                var i = function(e, t) {
                    return i = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(e, t) {
                        e.__proto__ = t
                    } || function(e, t) {
                        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r])
                    }, i(e, t)
                };

                function s(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");

                    function r() {
                        this.constructor = e
                    }
                    i(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
                }
                var n = function() {
                    return n = Object.assign || function(e) {
                        for (var t, r = 1, i = arguments.length; r < i; r++)
                            for (var s in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
                        return e
                    }, n.apply(this, arguments)
                };

                function o(e, t) {
                    var r = {};
                    for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.indexOf(i) < 0 && (r[i] = e[i]);
                    if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
                        var s = 0;
                        for (i = Object.getOwnPropertySymbols(e); s < i.length; s++) t.indexOf(i[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, i[s]) && (r[i[s]] = e[i[s]])
                    }
                    return r
                }

                function a(e, t, r, i) {
                    var s, n = arguments.length,
                        o = n < 3 ? t : null === i ? i = Object.getOwnPropertyDescriptor(t, r) : i;
                    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, r, i);
                    else
                        for (var a = e.length - 1; a >= 0; a--)(s = e[a]) && (o = (n < 3 ? s(o) : n > 3 ? s(t, r, o) : s(t, r)) || o);
                    return n > 3 && o && Object.defineProperty(t, r, o), o
                }

                function h(e, t) {
                    return function(r, i) {
                        t(r, i, e)
                    }
                }

                function l(e, t, r, i, s, n) {
                    function o(e) {
                        if (void 0 !== e && "function" != typeof e) throw new TypeError("Function expected");
                        return e
                    }
                    for (var a, h = i.kind, l = "getter" === h ? "get" : "setter" === h ? "set" : "value", u = !t && e ? i.static ? e : e.prototype : null, c = t || (u ? Object.getOwnPropertyDescriptor(u, i.name) : {}), d = !1, p = r.length - 1; p >= 0; p--) {
                        var f = {};
                        for (var m in i) f[m] = "access" === m ? {} : i[m];
                        for (var m in i.access) f.access[m] = i.access[m];
                        f.addInitializer = function(e) {
                            if (d) throw new TypeError("Cannot add initializers after decoration has completed");
                            n.push(o(e || null))
                        };
                        var g = (0, r[p])("accessor" === h ? {
                            get: c.get,
                            set: c.set
                        } : c[l], f);
                        if ("accessor" === h) {
                            if (void 0 === g) continue;
                            if (null === g || "object" != typeof g) throw new TypeError("Object expected");
                            (a = o(g.get)) && (c.get = a), (a = o(g.set)) && (c.set = a), (a = o(g.init)) && s.push(a)
                        } else(a = o(g)) && ("field" === h ? s.push(a) : c[l] = a)
                    }
                    u && Object.defineProperty(u, i.name, c), d = !0
                }

                function u(e, t, r) {
                    for (var i = arguments.length > 2, s = 0; s < t.length; s++) r = i ? t[s].call(e, r) : t[s].call(e);
                    return i ? r : void 0
                }

                function c(e) {
                    return "symbol" == typeof e ? e : "".concat(e)
                }

                function d(e, t, r) {
                    return "symbol" == typeof t && (t = t.description ? "[".concat(t.description, "]") : ""), Object.defineProperty(e, "name", {
                        configurable: !0,
                        value: r ? "".concat(r, " ", t) : t
                    })
                }

                function p(e, t) {
                    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(e, t)
                }

                function f(e, t, r, i) {
                    return new(r || (r = Promise))((function(s, n) {
                        function o(e) {
                            try {
                                h(i.next(e))
                            } catch (e) {
                                n(e)
                            }
                        }

                        function a(e) {
                            try {
                                h(i.throw(e))
                            } catch (e) {
                                n(e)
                            }
                        }

                        function h(e) {
                            var t;
                            e.done ? s(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
                                e(t)
                            }))).then(o, a)
                        }
                        h((i = i.apply(e, t || [])).next())
                    }))
                }

                function m(e, t) {
                    var r, i, s, n, o = {
                        label: 0,
                        sent: function() {
                            if (1 & s[0]) throw s[1];
                            return s[1]
                        },
                        trys: [],
                        ops: []
                    };
                    return n = {
                        next: a(0),
                        throw: a(1),
                        return: a(2)
                    }, "function" == typeof Symbol && (n[Symbol.iterator] = function() {
                        return this
                    }), n;

                    function a(a) {
                        return function(h) {
                            return function(a) {
                                if (r) throw new TypeError("Generator is already executing.");
                                for (; n && (n = 0, a[0] && (o = 0)), o;) try {
                                    if (r = 1, i && (s = 2 & a[0] ? i.return : a[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, a[1])).done) return s;
                                    switch (i = 0, s && (a = [2 & a[0], s.value]), a[0]) {
                                        case 0:
                                        case 1:
                                            s = a;
                                            break;
                                        case 4:
                                            return o.label++, {
                                                value: a[1],
                                                done: !1
                                            };
                                        case 5:
                                            o.label++, i = a[1], a = [0];
                                            continue;
                                        case 7:
                                            a = o.ops.pop(), o.trys.pop();
                                            continue;
                                        default:
                                            if (!((s = (s = o.trys).length > 0 && s[s.length - 1]) || 6 !== a[0] && 2 !== a[0])) {
                                                o = 0;
                                                continue
                                            }
                                            if (3 === a[0] && (!s || a[1] > s[0] && a[1] < s[3])) {
                                                o.label = a[1];
                                                break
                                            }
                                            if (6 === a[0] && o.label < s[1]) {
                                                o.label = s[1], s = a;
                                                break
                                            }
                                            if (s && o.label < s[2]) {
                                                o.label = s[2], o.ops.push(a);
                                                break
                                            }
                                            s[2] && o.ops.pop(), o.trys.pop();
                                            continue
                                    }
                                    a = t.call(e, o)
                                } catch (e) {
                                    a = [6, e], i = 0
                                } finally {
                                    r = s = 0
                                }
                                if (5 & a[0]) throw a[1];
                                return {
                                    value: a[0] ? a[1] : void 0,
                                    done: !0
                                }
                            }([a, h])
                        }
                    }
                }
                var g = Object.create ? function(e, t, r, i) {
                    void 0 === i && (i = r);
                    var s = Object.getOwnPropertyDescriptor(t, r);
                    s && !("get" in s ? !t.__esModule : s.writable || s.configurable) || (s = {
                        enumerable: !0,
                        get: function() {
                            return t[r]
                        }
                    }), Object.defineProperty(e, i, s)
                } : function(e, t, r, i) {
                    void 0 === i && (i = r), e[i] = t[r]
                };

                function y(e, t) {
                    for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || g(t, e, r)
                }

                function _(e) {
                    var t = "function" == typeof Symbol && Symbol.iterator,
                        r = t && e[t],
                        i = 0;
                    if (r) return r.call(e);
                    if (e && "number" == typeof e.length) return {
                        next: function() {
                            return e && i >= e.length && (e = void 0), {
                                value: e && e[i++],
                                done: !e
                            }
                        }
                    };
                    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
                }

                function v(e, t) {
                    var r = "function" == typeof Symbol && e[Symbol.iterator];
                    if (!r) return e;
                    var i, s, n = r.call(e),
                        o = [];
                    try {
                        for (;
                            (void 0 === t || t-- > 0) && !(i = n.next()).done;) o.push(i.value)
                    } catch (e) {
                        s = {
                            error: e
                        }
                    } finally {
                        try {
                            i && !i.done && (r = n.return) && r.call(n)
                        } finally {
                            if (s) throw s.error
                        }
                    }
                    return o
                }

                function S() {
                    for (var e = [], t = 0; t < arguments.length; t++) e = e.concat(v(arguments[t]));
                    return e
                }

                function T() {
                    for (var e = 0, t = 0, r = arguments.length; t < r; t++) e += arguments[t].length;
                    var i = Array(e),
                        s = 0;
                    for (t = 0; t < r; t++)
                        for (var n = arguments[t], o = 0, a = n.length; o < a; o++, s++) i[s] = n[o];
                    return i
                }

                function b(e, t, r) {
                    if (r || 2 === arguments.length)
                        for (var i, s = 0, n = t.length; s < n; s++) !i && s in t || (i || (i = Array.prototype.slice.call(t, 0, s)), i[s] = t[s]);
                    return e.concat(i || Array.prototype.slice.call(t))
                }

                function E(e) {
                    return this instanceof E ? (this.v = e, this) : new E(e)
                }

                function x(e, t, r) {
                    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                    var i, s = r.apply(e, t || []),
                        n = [];
                    return i = {}, o("next"), o("throw"), o("return"), i[Symbol.asyncIterator] = function() {
                        return this
                    }, i;

                    function o(e) {
                        s[e] && (i[e] = function(t) {
                            return new Promise((function(r, i) {
                                n.push([e, t, r, i]) > 1 || a(e, t)
                            }))
                        })
                    }

                    function a(e, t) {
                        try {
                            (r = s[e](t)).value instanceof E ? Promise.resolve(r.value.v).then(h, l) : u(n[0][2], r)
                        } catch (e) {
                            u(n[0][3], e)
                        }
                        var r
                    }

                    function h(e) {
                        a("next", e)
                    }

                    function l(e) {
                        a("throw", e)
                    }

                    function u(e, t) {
                        e(t), n.shift(), n.length && a(n[0][0], n[0][1])
                    }
                }

                function w(e) {
                    var t, r;
                    return t = {}, i("next"), i("throw", (function(e) {
                        throw e
                    })), i("return"), t[Symbol.iterator] = function() {
                        return this
                    }, t;

                    function i(i, s) {
                        t[i] = e[i] ? function(t) {
                            return (r = !r) ? {
                                value: E(e[i](t)),
                                done: !1
                            } : s ? s(t) : t
                        } : s
                    }
                }

                function O(e) {
                    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
                    var t, r = e[Symbol.asyncIterator];
                    return r ? r.call(e) : (e = _(e), t = {}, i("next"), i("throw"), i("return"), t[Symbol.asyncIterator] = function() {
                        return this
                    }, t);

                    function i(r) {
                        t[r] = e[r] && function(t) {
                            return new Promise((function(i, s) {
                                ! function(e, t, r, i) {
                                    Promise.resolve(i).then((function(t) {
                                        e({
                                            value: t,
                                            done: r
                                        })
                                    }), t)
                                }(i, s, (t = e[r](t)).done, t.value)
                            }))
                        }
                    }
                }

                function A(e, t) {
                    return Object.defineProperty ? Object.defineProperty(e, "raw", {
                        value: t
                    }) : e.raw = t, e
                }
                var P = Object.create ? function(e, t) {
                    Object.defineProperty(e, "default", {
                        enumerable: !0,
                        value: t
                    })
                } : function(e, t) {
                    e.default = t
                };

                function M(e) {
                    if (e && e.__esModule) return e;
                    var t = {};
                    if (null != e)
                        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && g(t, e, r);
                    return P(t, e), t
                }

                function C(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function R(e, t, r, i) {
                    if ("a" === r && !i) throw new TypeError("Private accessor was defined without a getter");
                    if ("function" == typeof t ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
                    return "m" === r ? i : "a" === r ? i.call(e) : i ? i.value : t.get(e)
                }

                function I(e, t, r, i, s) {
                    if ("m" === i) throw new TypeError("Private method is not writable");
                    if ("a" === i && !s) throw new TypeError("Private accessor was defined without a setter");
                    if ("function" == typeof t ? e !== t || !s : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
                    return "a" === i ? s.call(e, r) : s ? s.value = r : t.set(e, r), r
                }

                function B(e, t) {
                    if (null === t || "object" != typeof t && "function" != typeof t) throw new TypeError("Cannot use 'in' operator on non-object");
                    return "function" == typeof e ? t === e : e.has(t)
                }
            },
            2511: function(e, t, r) {
                var i;
                e = r.nmd(e),
                    function(s) {
                        t && t.nodeType, e && e.nodeType;
                        var n = "object" == typeof r.g && r.g;
                        n.global !== n && n.window !== n && n.self;
                        var o, a = 2147483647,
                            h = 36,
                            l = 26,
                            u = 38,
                            c = 700,
                            d = /^xn--/,
                            p = /[^\x20-\x7E]/,
                            f = /[\x2E\u3002\uFF0E\uFF61]/g,
                            m = {
                                overflow: "Overflow: input needs wider integers to process",
                                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                                "invalid-input": "Invalid input"
                            },
                            g = h - 1,
                            y = Math.floor,
                            _ = String.fromCharCode;

                        function v(e) {
                            throw RangeError(m[e])
                        }

                        function S(e, t) {
                            for (var r = e.length, i = []; r--;) i[r] = t(e[r]);
                            return i
                        }

                        function T(e, t) {
                            var r = e.split("@"),
                                i = "";
                            return r.length > 1 && (i = r[0] + "@", e = r[1]), i + S((e = e.replace(f, ".")).split("."), t).join(".")
                        }

                        function b(e) {
                            for (var t, r, i = [], s = 0, n = e.length; s < n;)(t = e.charCodeAt(s++)) >= 55296 && t <= 56319 && s < n ? 56320 == (64512 & (r = e.charCodeAt(s++))) ? i.push(((1023 & t) << 10) + (1023 & r) + 65536) : (i.push(t), s--) : i.push(t);
                            return i
                        }

                        function E(e) {
                            return S(e, (function(e) {
                                var t = "";
                                return e > 65535 && (t += _((e -= 65536) >>> 10 & 1023 | 55296), e = 56320 | 1023 & e), t + _(e)
                            })).join("")
                        }

                        function x(e, t) {
                            return e + 22 + 75 * (e < 26) - ((0 != t) << 5)
                        }

                        function w(e, t, r) {
                            var i = 0;
                            for (e = r ? y(e / c) : e >> 1, e += y(e / t); e > g * l >> 1; i += h) e = y(e / g);
                            return y(i + (g + 1) * e / (e + u))
                        }

                        function O(e) {
                            var t, r, i, s, n, o, u, c, d, p, f, m = [],
                                g = e.length,
                                _ = 0,
                                S = 128,
                                T = 72;
                            for ((r = e.lastIndexOf("-")) < 0 && (r = 0), i = 0; i < r; ++i) e.charCodeAt(i) >= 128 && v("not-basic"), m.push(e.charCodeAt(i));
                            for (s = r > 0 ? r + 1 : 0; s < g;) {
                                for (n = _, o = 1, u = h; s >= g && v("invalid-input"), ((c = (f = e.charCodeAt(s++)) - 48 < 10 ? f - 22 : f - 65 < 26 ? f - 65 : f - 97 < 26 ? f - 97 : h) >= h || c > y((a - _) / o)) && v("overflow"), _ += c * o, !(c < (d = u <= T ? 1 : u >= T + l ? l : u - T)); u += h) o > y(a / (p = h - d)) && v("overflow"), o *= p;
                                T = w(_ - n, t = m.length + 1, 0 == n), y(_ / t) > a - S && v("overflow"), S += y(_ / t), _ %= t, m.splice(_++, 0, S)
                            }
                            return E(m)
                        }

                        function A(e) {
                            var t, r, i, s, n, o, u, c, d, p, f, m, g, S, T, E = [];
                            for (m = (e = b(e)).length, t = 128, r = 0, n = 72, o = 0; o < m; ++o)(f = e[o]) < 128 && E.push(_(f));
                            for (i = s = E.length, s && E.push("-"); i < m;) {
                                for (u = a, o = 0; o < m; ++o)(f = e[o]) >= t && f < u && (u = f);
                                for (u - t > y((a - r) / (g = i + 1)) && v("overflow"), r += (u - t) * g, t = u, o = 0; o < m; ++o)
                                    if ((f = e[o]) < t && ++r > a && v("overflow"), f == t) {
                                        for (c = r, d = h; !(c < (p = d <= n ? 1 : d >= n + l ? l : d - n)); d += h) T = c - p, S = h - p, E.push(_(x(p + T % S, 0))), c = y(T / S);
                                        E.push(_(x(c, 0))), n = w(r, g, i == s), r = 0, ++i
                                    }++ r, ++t
                            }
                            return E.join("")
                        }
                        o = {
                            version: "1.3.2",
                            ucs2: {
                                decode: b,
                                encode: E
                            },
                            decode: O,
                            encode: A,
                            toASCII: function(e) {
                                return T(e, (function(e) {
                                    return p.test(e) ? "xn--" + A(e) : e
                                }))
                            },
                            toUnicode: function(e) {
                                return T(e, (function(e) {
                                    return d.test(e) ? O(e.slice(4).toLowerCase()) : e
                                }))
                            }
                        }, void 0 === (i = function() {
                            return o
                        }.call(t, r, t, e)) || (e.exports = i)
                    }()
            },
            8575: (e, t, r) => {
                "use strict";
                var i = r(2511),
                    s = r(2502);

                function n() {
                    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null
                }
                t.parse = v, t.resolve = function(e, t) {
                    return v(e, !1, !0).resolve(t)
                }, t.resolveObject = function(e, t) {
                    return e ? v(e, !1, !0).resolveObject(t) : t
                }, t.format = function(e) {
                    return s.isString(e) && (e = v(e)), e instanceof n ? e.format() : n.prototype.format.call(e)
                }, t.Url = n;
                var o = /^([a-z0-9.+-]+:)/i,
                    a = /:[0-9]*$/,
                    h = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
                    l = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "\t"]),
                    u = ["'"].concat(l),
                    c = ["%", "/", "?", ";", "#"].concat(u),
                    d = ["/", "?", "#"],
                    p = /^[+a-z0-9A-Z_-]{0,63}$/,
                    f = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
                    m = {
                        javascript: !0,
                        "javascript:": !0
                    },
                    g = {
                        javascript: !0,
                        "javascript:": !0
                    },
                    y = {
                        http: !0,
                        https: !0,
                        ftp: !0,
                        gopher: !0,
                        file: !0,
                        "http:": !0,
                        "https:": !0,
                        "ftp:": !0,
                        "gopher:": !0,
                        "file:": !0
                    },
                    _ = r(7673);

                function v(e, t, r) {
                    if (e && s.isObject(e) && e instanceof n) return e;
                    var i = new n;
                    return i.parse(e, t, r), i
                }
                n.prototype.parse = function(e, t, r) {
                    if (!s.isString(e)) throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
                    var n = e.indexOf("?"),
                        a = -1 !== n && n < e.indexOf("#") ? "?" : "#",
                        l = e.split(a);
                    l[0] = l[0].replace(/\\/g, "/");
                    var v = e = l.join(a);
                    if (v = v.trim(), !r && 1 === e.split("#").length) {
                        var S = h.exec(v);
                        if (S) return this.path = v, this.href = v, this.pathname = S[1], S[2] ? (this.search = S[2], this.query = t ? _.parse(this.search.substr(1)) : this.search.substr(1)) : t && (this.search = "", this.query = {}), this
                    }
                    var T = o.exec(v);
                    if (T) {
                        var b = (T = T[0]).toLowerCase();
                        this.protocol = b, v = v.substr(T.length)
                    }
                    if (r || T || v.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                        var E = "//" === v.substr(0, 2);
                        !E || T && g[T] || (v = v.substr(2), this.slashes = !0)
                    }
                    if (!g[T] && (E || T && !y[T])) {
                        for (var x, w, O = -1, A = 0; A < d.length; A++) - 1 !== (P = v.indexOf(d[A])) && (-1 === O || P < O) && (O = P);
                        for (-1 !== (w = -1 === O ? v.lastIndexOf("@") : v.lastIndexOf("@", O)) && (x = v.slice(0, w), v = v.slice(w + 1), this.auth = decodeURIComponent(x)), O = -1, A = 0; A < c.length; A++) {
                            var P; - 1 !== (P = v.indexOf(c[A])) && (-1 === O || P < O) && (O = P)
                        } - 1 === O && (O = v.length), this.host = v.slice(0, O), v = v.slice(O), this.parseHost(), this.hostname = this.hostname || "";
                        var M = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
                        if (!M)
                            for (var C = this.hostname.split(/\./), R = (A = 0, C.length); A < R; A++) {
                                var I = C[A];
                                if (I && !I.match(p)) {
                                    for (var B = "", D = 0, H = I.length; D < H; D++) I.charCodeAt(D) > 127 ? B += "x" : B += I[D];
                                    if (!B.match(p)) {
                                        var k = C.slice(0, A),
                                            F = C.slice(A + 1),
                                            N = I.match(f);
                                        N && (k.push(N[1]), F.unshift(N[2])), F.length && (v = "/" + F.join(".") + v), this.hostname = k.join(".");
                                        break
                                    }
                                }
                            }
                        this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), M || (this.hostname = i.toASCII(this.hostname));
                        var L = this.port ? ":" + this.port : "",
                            j = this.hostname || "";
                        this.host = j + L, this.href += this.host, M && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== v[0] && (v = "/" + v))
                    }
                    if (!m[b])
                        for (A = 0, R = u.length; A < R; A++) {
                            var U = u[A];
                            if (-1 !== v.indexOf(U)) {
                                var G = encodeURIComponent(U);
                                G === U && (G = escape(U)), v = v.split(U).join(G)
                            }
                        }
                    var V = v.indexOf("#"); - 1 !== V && (this.hash = v.substr(V), v = v.slice(0, V));
                    var Y = v.indexOf("?");
                    if (-1 !== Y ? (this.search = v.substr(Y), this.query = v.substr(Y + 1), t && (this.query = _.parse(this.query)), v = v.slice(0, Y)) : t && (this.search = "", this.query = {}), v && (this.pathname = v), y[b] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
                        L = this.pathname || "";
                        var z = this.search || "";
                        this.path = L + z
                    }
                    return this.href = this.format(), this
                }, n.prototype.format = function() {
                    var e = this.auth || "";
                    e && (e = (e = encodeURIComponent(e)).replace(/%3A/i, ":"), e += "@");
                    var t = this.protocol || "",
                        r = this.pathname || "",
                        i = this.hash || "",
                        n = !1,
                        o = "";
                    this.host ? n = e + this.host : this.hostname && (n = e + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (n += ":" + this.port)), this.query && s.isObject(this.query) && Object.keys(this.query).length && (o = _.stringify(this.query));
                    var a = this.search || o && "?" + o || "";
                    return t && ":" !== t.substr(-1) && (t += ":"), this.slashes || (!t || y[t]) && !1 !== n ? (n = "//" + (n || ""), r && "/" !== r.charAt(0) && (r = "/" + r)) : n || (n = ""), i && "#" !== i.charAt(0) && (i = "#" + i), a && "?" !== a.charAt(0) && (a = "?" + a), t + n + (r = r.replace(/[?#]/g, (function(e) {
                        return encodeURIComponent(e)
                    }))) + (a = a.replace("#", "%23")) + i
                }, n.prototype.resolve = function(e) {
                    return this.resolveObject(v(e, !1, !0)).format()
                }, n.prototype.resolveObject = function(e) {
                    if (s.isString(e)) {
                        var t = new n;
                        t.parse(e, !1, !0), e = t
                    }
                    for (var r = new n, i = Object.keys(this), o = 0; o < i.length; o++) {
                        var a = i[o];
                        r[a] = this[a]
                    }
                    if (r.hash = e.hash, "" === e.href) return r.href = r.format(), r;
                    if (e.slashes && !e.protocol) {
                        for (var h = Object.keys(e), l = 0; l < h.length; l++) {
                            var u = h[l];
                            "protocol" !== u && (r[u] = e[u])
                        }
                        return y[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), r.href = r.format(), r
                    }
                    if (e.protocol && e.protocol !== r.protocol) {
                        if (!y[e.protocol]) {
                            for (var c = Object.keys(e), d = 0; d < c.length; d++) {
                                var p = c[d];
                                r[p] = e[p]
                            }
                            return r.href = r.format(), r
                        }
                        if (r.protocol = e.protocol, e.host || g[e.protocol]) r.pathname = e.pathname;
                        else {
                            for (var f = (e.pathname || "").split("/"); f.length && !(e.host = f.shift()););
                            e.host || (e.host = ""), e.hostname || (e.hostname = ""), "" !== f[0] && f.unshift(""), f.length < 2 && f.unshift(""), r.pathname = f.join("/")
                        }
                        if (r.search = e.search, r.query = e.query, r.host = e.host || "", r.auth = e.auth, r.hostname = e.hostname || e.host, r.port = e.port, r.pathname || r.search) {
                            var m = r.pathname || "",
                                _ = r.search || "";
                            r.path = m + _
                        }
                        return r.slashes = r.slashes || e.slashes, r.href = r.format(), r
                    }
                    var v = r.pathname && "/" === r.pathname.charAt(0),
                        S = e.host || e.pathname && "/" === e.pathname.charAt(0),
                        T = S || v || r.host && e.pathname,
                        b = T,
                        E = r.pathname && r.pathname.split("/") || [],
                        x = (f = e.pathname && e.pathname.split("/") || [], r.protocol && !y[r.protocol]);
                    if (x && (r.hostname = "", r.port = null, r.host && ("" === E[0] ? E[0] = r.host : E.unshift(r.host)), r.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && ("" === f[0] ? f[0] = e.host : f.unshift(e.host)), e.host = null), T = T && ("" === f[0] || "" === E[0])), S) r.host = e.host || "" === e.host ? e.host : r.host, r.hostname = e.hostname || "" === e.hostname ? e.hostname : r.hostname, r.search = e.search, r.query = e.query, E = f;
                    else if (f.length) E || (E = []), E.pop(), E = E.concat(f), r.search = e.search, r.query = e.query;
                    else if (!s.isNullOrUndefined(e.search)) return x && (r.hostname = r.host = E.shift(), (M = !!(r.host && r.host.indexOf("@") > 0) && r.host.split("@")) && (r.auth = M.shift(), r.host = r.hostname = M.shift())), r.search = e.search, r.query = e.query, s.isNull(r.pathname) && s.isNull(r.search) || (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
                    if (!E.length) return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
                    for (var w = E.slice(-1)[0], O = (r.host || e.host || E.length > 1) && ("." === w || ".." === w) || "" === w, A = 0, P = E.length; P >= 0; P--) "." === (w = E[P]) ? E.splice(P, 1) : ".." === w ? (E.splice(P, 1), A++) : A && (E.splice(P, 1), A--);
                    if (!T && !b)
                        for (; A--; A) E.unshift("..");
                    !T || "" === E[0] || E[0] && "/" === E[0].charAt(0) || E.unshift(""), O && "/" !== E.join("/").substr(-1) && E.push("");
                    var M, C = "" === E[0] || E[0] && "/" === E[0].charAt(0);
                    return x && (r.hostname = r.host = C ? "" : E.length ? E.shift() : "", (M = !!(r.host && r.host.indexOf("@") > 0) && r.host.split("@")) && (r.auth = M.shift(), r.host = r.hostname = M.shift())), (T = T || r.host && E.length) && !C && E.unshift(""), E.length ? r.pathname = E.join("/") : (r.pathname = null, r.path = null), s.isNull(r.pathname) && s.isNull(r.search) || (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = e.auth || r.auth, r.slashes = r.slashes || e.slashes, r.href = r.format(), r
                }, n.prototype.parseHost = function() {
                    var e = this.host,
                        t = a.exec(e);
                    t && (":" !== (t = t[0]) && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e)
                }
            },
            2502: e => {
                "use strict";
                e.exports = {
                    isString: function(e) {
                        return "string" == typeof e
                    },
                    isObject: function(e) {
                        return "object" == typeof e && null !== e
                    },
                    isNull: function(e) {
                        return null === e
                    },
                    isNullOrUndefined: function(e) {
                        return null == e
                    }
                }
            },
            7406: () => {
                ! function e(t, r, i) {
                    function s(o, a) {
                        if (!r[o]) {
                            if (!t[o]) {
                                if (n) return n(o, !0);
                                var h = new Error("Cannot find module '" + o + "'");
                                throw h.code = "MODULE_NOT_FOUND", h
                            }
                            var l = r[o] = {
                                exports: {}
                            };
                            t[o][0].call(l.exports, (function(e) {
                                return s(t[o][1][e] || e)
                            }), l, l.exports, e, t, r, i)
                        }
                        return r[o].exports
                    }
                    for (var n = void 0, o = 0; o < i.length; o++) s(i[o]);
                    return s
                }({
                    1: [function(e, t, r) {
                        (function(t) {
                            var i = e("path");

                            function s(e) {
                                e = e.replace(/[\ufe00-\ufe0f]/g, "");
                                for (var t = [], i = 0; i < e.length; i++) t.push(("0000" + e.charCodeAt(i).toString(16)).slice(-4));
                                return r.basePath.replace(/\/$/, "") + "/" + t.join("-") + ".png"
                            }
                            r.imageDir = i.join(t, "images"), r.basePath = r.imageDir, r.regex = e("./regex"), r.nativeSupport = function() {
                                if ("undefined" == typeof document) return !1;
                                var e = document.createElement("canvas");
                                if (!e.getContext) return !1;
                                var t = e.getContext("2d");
                                return t.textBaseline = "top", t.font = "32px sans-serif", t.fillText("", 0, 0), 0 !== t.getImageData(16, 16, 1, 1).data[0]
                            }();
                            var n = new RegExp("^(" + r.regex.toString().slice(1, -2) + ")$");
                            r.getImage = function(e) {
                                return n.test(e) ? s(e) : null
                            }, r.replace = function(e) {
                                return e = "" + e, r.nativeSupport ? e : e.replace(r.regex, (function(e) {
                                    return '<img class="emoji" src="' + s(e) + '" alt="' + e + '">'
                                }))
                            }
                        }).call(this, "/")
                    }, {
                        "./regex": 3,
                        path: 4
                    }],
                    2: [function(e, t, r) {
                        window.emoji = window.emoji || e("./index.js")
                    }, {
                        "./index.js": 1
                    }],
                    3: [function(e, t, r) {
                        t.exports = /(\uD83C[\uDDE6-\uDDFF])?(\u00a9|\u00ae|[\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2640\u2642\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303d\u3297\u3299]|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff]|[#*0-9]\uFE0F\u20E3)\uFE0F?(\ud83c[\udffb-\udfff])?(\u200d(\u00a9|\u00ae|\u2695\uFE0F|\uD83C\uDF93|\uD83C\uDFEB|\u2696\uFE0F|\uD83C\uDF3E|\uD83C\uDF73|\uD83D\uDD27|\uD83C\uDFED|\uD83D\uDCBC|\uD83D\uDD2C|\uD83D\uDCBB|\uD83C\uDFA4|\uD83C\uDFA8|\u2708\uFE0F|\uD83D\uDE80|\uD83D\uDC8B|\uD83D\uDE92|\u2764\uFE0F|\uD83D\uDC66|\uD83D\uDC67|\uD83D\uDC68|\uD83D\uDC69|\uD83D\uDC6A|\uD83D\uDC91|\u2640|\u2642|\ud83c[\ud000-\udfff]|\ud83d[\ud000-\udfff]|\ud83e[\ud000-\udfff]|[#*0-9]\uFE0F\u20E3)\uFE0F?)*/g
                    }, {}],
                    4: [function(e, t, r) {
                        (function(e) {
                            function t(e, t) {
                                for (var r = 0, i = e.length - 1; i >= 0; i--) {
                                    var s = e[i];
                                    "." === s ? e.splice(i, 1) : ".." === s ? (e.splice(i, 1), r++) : r && (e.splice(i, 1), r--)
                                }
                                if (t)
                                    for (; r--; r) e.unshift("..");
                                return e
                            }
                            var i = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,
                                s = function(e) {
                                    return i.exec(e).slice(1)
                                };

                            function n(e, t) {
                                if (e.filter) return e.filter(t);
                                for (var r = [], i = 0; i < e.length; i++) t(e[i], i, e) && r.push(e[i]);
                                return r
                            }
                            r.resolve = function() {
                                for (var r = "", i = !1, s = arguments.length - 1; s >= -1 && !i; s--) {
                                    var o = s >= 0 ? arguments[s] : e.cwd();
                                    if ("string" != typeof o) throw new TypeError("Arguments to path.resolve must be strings");
                                    o && (r = o + "/" + r, i = "/" === o.charAt(0))
                                }
                                return (i ? "/" : "") + (r = t(n(r.split("/"), (function(e) {
                                    return !!e
                                })), !i).join("/")) || "."
                            }, r.normalize = function(e) {
                                var i = r.isAbsolute(e),
                                    s = "/" === o(e, -1);
                                return (e = t(n(e.split("/"), (function(e) {
                                    return !!e
                                })), !i).join("/")) || i || (e = "."), e && s && (e += "/"), (i ? "/" : "") + e
                            }, r.isAbsolute = function(e) {
                                return "/" === e.charAt(0)
                            }, r.join = function() {
                                var e = Array.prototype.slice.call(arguments, 0);
                                return r.normalize(n(e, (function(e, t) {
                                    if ("string" != typeof e) throw new TypeError("Arguments to path.join must be strings");
                                    return e
                                })).join("/"))
                            }, r.relative = function(e, t) {
                                function i(e) {
                                    for (var t = 0; t < e.length && "" === e[t]; t++);
                                    for (var r = e.length - 1; r >= 0 && "" === e[r]; r--);
                                    return t > r ? [] : e.slice(t, r - t + 1)
                                }
                                e = r.resolve(e).substr(1), t = r.resolve(t).substr(1);
                                for (var s = i(e.split("/")), n = i(t.split("/")), o = Math.min(s.length, n.length), a = o, h = 0; h < o; h++)
                                    if (s[h] !== n[h]) {
                                        a = h;
                                        break
                                    } var l = [];
                                for (h = a; h < s.length; h++) l.push("..");
                                return (l = l.concat(n.slice(a))).join("/")
                            }, r.sep = "/", r.delimiter = ":", r.dirname = function(e) {
                                var t = s(e),
                                    r = t[0],
                                    i = t[1];
                                return r || i ? (i && (i = i.substr(0, i.length - 1)), r + i) : "."
                            }, r.basename = function(e, t) {
                                var r = s(e)[2];
                                return t && r.substr(-1 * t.length) === t && (r = r.substr(0, r.length - t.length)), r
                            }, r.extname = function(e) {
                                return s(e)[3]
                            };
                            var o = function(e, t, r) {
                                return e.substr(t, r)
                            }
                        }).call(this, e("_process"))
                    }, {
                        _process: 5
                    }],
                    5: [function(e, t, r) {
                        var i, s = t.exports = {},
                            n = [],
                            o = !1,
                            a = -1;

                        function h() {
                            o = !1, i.length ? n = i.concat(n) : a = -1, n.length && l()
                        }

                        function l() {
                            if (!o) {
                                var e = setTimeout(h);
                                o = !0;
                                for (var t = n.length; t;) {
                                    for (i = n, n = []; ++a < t;) i && i[a].run();
                                    a = -1, t = n.length
                                }
                                i = null, o = !1, clearTimeout(e)
                            }
                        }

                        function u(e, t) {
                            this.fun = e, this.array = t
                        }

                        function c() {}
                        s.nextTick = function(e) {
                            var t = new Array(arguments.length - 1);
                            if (arguments.length > 1)
                                for (var r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
                            n.push(new u(e, t)), 1 !== n.length || o || setTimeout(l, 0)
                        }, u.prototype.run = function() {
                            this.fun.apply(null, this.array)
                        }, s.title = "browser", s.browser = !0, s.env = {}, s.argv = [], s.version = "", s.versions = {}, s.on = c, s.addListener = c, s.once = c, s.off = c, s.removeListener = c, s.removeAllListeners = c, s.emit = c, s.binding = function(e) {
                            throw new Error("process.binding is not supported")
                        }, s.cwd = function() {
                            return "/"
                        }, s.chdir = function(e) {
                            throw new Error("process.chdir is not supported")
                        }, s.umask = function() {
                            return 0
                        }
                    }, {}]
                }, {}, [2])
            }
        },
        t = {};

    function r(i) {
        var s = t[i];
        if (void 0 !== s) return s.exports;
        var n = t[i] = {
            id: i,
            loaded: !1,
            exports: {}
        };
        return e[i].call(n.exports, n, n.exports, r), n.loaded = !0, n.exports
    }
    r.d = (e, t) => {
        for (var i in t) r.o(t, i) && !r.o(e, i) && Object.defineProperty(e, i, {
            enumerable: !0,
            get: t[i]
        })
    }, r.g = function() {
        if ("object" == typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" == typeof window) return window
        }
    }(), r.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), r.r = e => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }, r.nmd = e => (e.paths = [], e.children || (e.children = []), e), r(7406), r(8519)
})();